/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool";
import { LatticeClient } from "../../src/Client";

describe("Tasking", () => {
    test("createTask", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            version: { taskId: "taskId", definitionVersion: 1, statusVersion: 1 },
            displayName: "displayName",
            specification: { "@type": "@type" },
            createdBy: {
                system: { serviceName: "serviceName", entityId: "entityId", managesOwnScheduling: true },
                user: { userId: "userId" },
                team: { entityId: "entityId", members: [{}] },
            },
            lastUpdatedBy: {
                system: { serviceName: "serviceName", entityId: "entityId", managesOwnScheduling: true },
                user: { userId: "userId" },
                team: { entityId: "entityId", members: [{}] },
            },
            lastUpdateTime: "2024-01-15T09:30:00Z",
            status: {
                status: "STATUS_INVALID",
                taskError: { code: "ERROR_CODE_INVALID", message: "message" },
                progress: { "@type": "@type" },
                result: { "@type": "@type" },
                startTime: "2024-01-15T09:30:00Z",
                estimate: { "@type": "@type" },
                allocation: { activeAgents: [{}] },
            },
            scheduledTime: "2024-01-15T09:30:00Z",
            relations: { parentTaskId: "parentTaskId" },
            description: "description",
            isExecutedElsewhere: true,
            createTime: "2024-01-15T09:30:00Z",
            replication: { staleTime: "2024-01-15T09:30:00Z" },
            initialEntities: [{ snapshot: true }],
            owner: { entityId: "entityId" },
        };
        server
            .mockEndpoint()
            .post("/api/v1/tasks")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.tasking.createTask();
        expect(response).toEqual({
            version: {
                taskId: "taskId",
                definitionVersion: 1,
                statusVersion: 1,
            },
            displayName: "displayName",
            specification: {
                "@type": "@type",
            },
            createdBy: {
                system: {
                    serviceName: "serviceName",
                    entityId: "entityId",
                    managesOwnScheduling: true,
                },
                user: {
                    userId: "userId",
                },
                team: {
                    entityId: "entityId",
                    members: [{}],
                },
            },
            lastUpdatedBy: {
                system: {
                    serviceName: "serviceName",
                    entityId: "entityId",
                    managesOwnScheduling: true,
                },
                user: {
                    userId: "userId",
                },
                team: {
                    entityId: "entityId",
                    members: [{}],
                },
            },
            lastUpdateTime: "2024-01-15T09:30:00Z",
            status: {
                status: "STATUS_INVALID",
                taskError: {
                    code: "ERROR_CODE_INVALID",
                    message: "message",
                },
                progress: {
                    "@type": "@type",
                },
                result: {
                    "@type": "@type",
                },
                startTime: "2024-01-15T09:30:00Z",
                estimate: {
                    "@type": "@type",
                },
                allocation: {
                    activeAgents: [{}],
                },
            },
            scheduledTime: "2024-01-15T09:30:00Z",
            relations: {
                parentTaskId: "parentTaskId",
            },
            description: "description",
            isExecutedElsewhere: true,
            createTime: "2024-01-15T09:30:00Z",
            replication: {
                staleTime: "2024-01-15T09:30:00Z",
            },
            initialEntities: [
                {
                    snapshot: true,
                },
            ],
            owner: {
                entityId: "entityId",
            },
        });
    });

    test("getTask", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            version: { taskId: "taskId", definitionVersion: 1, statusVersion: 1 },
            displayName: "displayName",
            specification: { "@type": "@type" },
            createdBy: {
                system: { serviceName: "serviceName", entityId: "entityId", managesOwnScheduling: true },
                user: { userId: "userId" },
                team: { entityId: "entityId", members: [{}] },
            },
            lastUpdatedBy: {
                system: { serviceName: "serviceName", entityId: "entityId", managesOwnScheduling: true },
                user: { userId: "userId" },
                team: { entityId: "entityId", members: [{}] },
            },
            lastUpdateTime: "2024-01-15T09:30:00Z",
            status: {
                status: "STATUS_INVALID",
                taskError: { code: "ERROR_CODE_INVALID", message: "message" },
                progress: { "@type": "@type" },
                result: { "@type": "@type" },
                startTime: "2024-01-15T09:30:00Z",
                estimate: { "@type": "@type" },
                allocation: { activeAgents: [{}] },
            },
            scheduledTime: "2024-01-15T09:30:00Z",
            relations: { parentTaskId: "parentTaskId" },
            description: "description",
            isExecutedElsewhere: true,
            createTime: "2024-01-15T09:30:00Z",
            replication: { staleTime: "2024-01-15T09:30:00Z" },
            initialEntities: [{ snapshot: true }],
            owner: { entityId: "entityId" },
        };
        server
            .mockEndpoint()
            .get("/api/v1/tasks/taskId")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.tasking.getTask("taskId");
        expect(response).toEqual({
            version: {
                taskId: "taskId",
                definitionVersion: 1,
                statusVersion: 1,
            },
            displayName: "displayName",
            specification: {
                "@type": "@type",
            },
            createdBy: {
                system: {
                    serviceName: "serviceName",
                    entityId: "entityId",
                    managesOwnScheduling: true,
                },
                user: {
                    userId: "userId",
                },
                team: {
                    entityId: "entityId",
                    members: [{}],
                },
            },
            lastUpdatedBy: {
                system: {
                    serviceName: "serviceName",
                    entityId: "entityId",
                    managesOwnScheduling: true,
                },
                user: {
                    userId: "userId",
                },
                team: {
                    entityId: "entityId",
                    members: [{}],
                },
            },
            lastUpdateTime: "2024-01-15T09:30:00Z",
            status: {
                status: "STATUS_INVALID",
                taskError: {
                    code: "ERROR_CODE_INVALID",
                    message: "message",
                },
                progress: {
                    "@type": "@type",
                },
                result: {
                    "@type": "@type",
                },
                startTime: "2024-01-15T09:30:00Z",
                estimate: {
                    "@type": "@type",
                },
                allocation: {
                    activeAgents: [{}],
                },
            },
            scheduledTime: "2024-01-15T09:30:00Z",
            relations: {
                parentTaskId: "parentTaskId",
            },
            description: "description",
            isExecutedElsewhere: true,
            createTime: "2024-01-15T09:30:00Z",
            replication: {
                staleTime: "2024-01-15T09:30:00Z",
            },
            initialEntities: [
                {
                    snapshot: true,
                },
            ],
            owner: {
                entityId: "entityId",
            },
        });
    });

    test("updateTaskStatus", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            version: { taskId: "taskId", definitionVersion: 1, statusVersion: 1 },
            displayName: "displayName",
            specification: { "@type": "@type" },
            createdBy: {
                system: { serviceName: "serviceName", entityId: "entityId", managesOwnScheduling: true },
                user: { userId: "userId" },
                team: { entityId: "entityId", members: [{}] },
            },
            lastUpdatedBy: {
                system: { serviceName: "serviceName", entityId: "entityId", managesOwnScheduling: true },
                user: { userId: "userId" },
                team: { entityId: "entityId", members: [{}] },
            },
            lastUpdateTime: "2024-01-15T09:30:00Z",
            status: {
                status: "STATUS_INVALID",
                taskError: { code: "ERROR_CODE_INVALID", message: "message" },
                progress: { "@type": "@type" },
                result: { "@type": "@type" },
                startTime: "2024-01-15T09:30:00Z",
                estimate: { "@type": "@type" },
                allocation: { activeAgents: [{}] },
            },
            scheduledTime: "2024-01-15T09:30:00Z",
            relations: { parentTaskId: "parentTaskId" },
            description: "description",
            isExecutedElsewhere: true,
            createTime: "2024-01-15T09:30:00Z",
            replication: { staleTime: "2024-01-15T09:30:00Z" },
            initialEntities: [{ snapshot: true }],
            owner: { entityId: "entityId" },
        };
        server
            .mockEndpoint()
            .put("/api/v1/tasks/taskId/status")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.tasking.updateTaskStatus("taskId");
        expect(response).toEqual({
            version: {
                taskId: "taskId",
                definitionVersion: 1,
                statusVersion: 1,
            },
            displayName: "displayName",
            specification: {
                "@type": "@type",
            },
            createdBy: {
                system: {
                    serviceName: "serviceName",
                    entityId: "entityId",
                    managesOwnScheduling: true,
                },
                user: {
                    userId: "userId",
                },
                team: {
                    entityId: "entityId",
                    members: [{}],
                },
            },
            lastUpdatedBy: {
                system: {
                    serviceName: "serviceName",
                    entityId: "entityId",
                    managesOwnScheduling: true,
                },
                user: {
                    userId: "userId",
                },
                team: {
                    entityId: "entityId",
                    members: [{}],
                },
            },
            lastUpdateTime: "2024-01-15T09:30:00Z",
            status: {
                status: "STATUS_INVALID",
                taskError: {
                    code: "ERROR_CODE_INVALID",
                    message: "message",
                },
                progress: {
                    "@type": "@type",
                },
                result: {
                    "@type": "@type",
                },
                startTime: "2024-01-15T09:30:00Z",
                estimate: {
                    "@type": "@type",
                },
                allocation: {
                    activeAgents: [{}],
                },
            },
            scheduledTime: "2024-01-15T09:30:00Z",
            relations: {
                parentTaskId: "parentTaskId",
            },
            description: "description",
            isExecutedElsewhere: true,
            createTime: "2024-01-15T09:30:00Z",
            replication: {
                staleTime: "2024-01-15T09:30:00Z",
            },
            initialEntities: [
                {
                    snapshot: true,
                },
            ],
            owner: {
                entityId: "entityId",
            },
        });
    });

    test("queryTasks", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            tasks: [
                {
                    displayName: "displayName",
                    lastUpdateTime: "2024-01-15T09:30:00Z",
                    scheduledTime: "2024-01-15T09:30:00Z",
                    description: "description",
                    isExecutedElsewhere: true,
                    createTime: "2024-01-15T09:30:00Z",
                    initialEntities: [{}],
                },
            ],
            nextPageToken: "nextPageToken",
        };
        server
            .mockEndpoint()
            .post("/api/v1/tasks/query")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.tasking.queryTasks();
        expect(response).toEqual({
            tasks: [
                {
                    displayName: "displayName",
                    lastUpdateTime: "2024-01-15T09:30:00Z",
                    scheduledTime: "2024-01-15T09:30:00Z",
                    description: "description",
                    isExecutedElsewhere: true,
                    createTime: "2024-01-15T09:30:00Z",
                    initialEntities: [{}],
                },
            ],
            nextPageToken: "nextPageToken",
        });
    });

    test("listenAsAgent", async () => {
        const server = mockServerPool.createServer();
        const client = new LatticeClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            executeRequest: {
                task: {
                    displayName: "displayName",
                    lastUpdateTime: "2024-01-15T09:30:00Z",
                    scheduledTime: "2024-01-15T09:30:00Z",
                    description: "description",
                    isExecutedElsewhere: true,
                    createTime: "2024-01-15T09:30:00Z",
                    initialEntities: [{}],
                },
            },
            cancelRequest: { taskId: "taskId" },
            completeRequest: { taskId: "taskId" },
        };
        server
            .mockEndpoint()
            .post("/api/v1/agent/listen")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.tasking.listenAsAgent();
        expect(response).toEqual({
            executeRequest: {
                task: {
                    displayName: "displayName",
                    lastUpdateTime: "2024-01-15T09:30:00Z",
                    scheduledTime: "2024-01-15T09:30:00Z",
                    description: "description",
                    isExecutedElsewhere: true,
                    createTime: "2024-01-15T09:30:00Z",
                    initialEntities: [{}],
                },
            },
            cancelRequest: {
                taskId: "taskId",
            },
            completeRequest: {
                taskId: "taskId",
            },
        });
    });
});
