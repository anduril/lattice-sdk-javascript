// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/communicationsmanager/v1/common.pub.proto (package anduril.communicationsmanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { EntityIntegrationRuleDetails } from "./entity.pub_pb.js";
import { Statement } from "../../entitymanager/v1/filter.pub_pb.js";
import { DynamicStatement } from "../../entitymanager/v1/filter_dynamic.pub_pb.js";
import { Statement as Statement$1 } from "../../blobs/v1/filter.pub_pb.js";
import { CdsDestination } from "./cross_domain.pub_pb.js";

/**
 * The type of distribution rule event.
 *
 * @generated from enum anduril.communicationsmanager.v1.EventType
 */
export enum EventType {
  /**
   * @generated from enum value: EVENT_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * Rule was created.
   *
   * @generated from enum value: EVENT_TYPE_CREATED = 1;
   */
  CREATED = 1,

  /**
   * Rule was updated.
   *
   * @generated from enum value: EVENT_TYPE_UPDATE = 2;
   */
  UPDATE = 2,

  /**
   * Rule was deleted.
   *
   * @generated from enum value: EVENT_TYPE_DELETED = 3;
   */
  DELETED = 3,

  /**
   * Rule already existed, but sent on a new stream connection.
   *
   * @generated from enum value: EVENT_TYPE_PREEXISTING = 4;
   */
  PREEXISTING = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(EventType)
proto3.util.setEnumType(EventType, "anduril.communicationsmanager.v1.EventType", [
  { no: 0, name: "EVENT_TYPE_INVALID" },
  { no: 1, name: "EVENT_TYPE_CREATED" },
  { no: 2, name: "EVENT_TYPE_UPDATE" },
  { no: 3, name: "EVENT_TYPE_DELETED" },
  { no: 4, name: "EVENT_TYPE_PREEXISTING" },
]);

/**
 * Event representing a type of distribution rule change.
 *
 * @generated from message anduril.communicationsmanager.v1.DistributionRuleEvent
 */
export class DistributionRuleEvent extends Message<DistributionRuleEvent> {
  /**
   * The type of distribution rule event.
   *
   * @generated from field: anduril.communicationsmanager.v1.EventType event_type = 1;
   */
  eventType = EventType.INVALID;

  /**
   * @generated from field: google.protobuf.Timestamp time = 2;
   */
  time?: Timestamp;

  /**
   * @generated from field: anduril.communicationsmanager.v1.DistributionRule distribution_rule = 3;
   */
  distributionRule?: DistributionRule;

  constructor(data?: PartialMessage<DistributionRuleEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.DistributionRuleEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event_type", kind: "enum", T: proto3.getEnumType(EventType) },
    { no: 2, name: "time", kind: "message", T: Timestamp },
    { no: 3, name: "distribution_rule", kind: "message", T: DistributionRule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DistributionRuleEvent {
    return new DistributionRuleEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DistributionRuleEvent {
    return new DistributionRuleEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DistributionRuleEvent {
    return new DistributionRuleEvent().fromJsonString(jsonString, options);
  }

  static equals(a: DistributionRuleEvent | PlainMessage<DistributionRuleEvent> | undefined, b: DistributionRuleEvent | PlainMessage<DistributionRuleEvent> | undefined): boolean {
    return proto3.util.equals(DistributionRuleEvent, a, b);
  }
}

/**
 * @generated from message anduril.communicationsmanager.v1.RuleEvent
 */
export class RuleEvent extends Message<RuleEvent> {
  /**
   * @generated from field: anduril.communicationsmanager.v1.EventType event_type = 1;
   */
  eventType = EventType.INVALID;

  /**
   * @generated from field: google.protobuf.Timestamp time = 2;
   */
  time?: Timestamp;

  /**
   * @generated from field: anduril.communicationsmanager.v1.Rule rule = 3;
   */
  rule?: Rule;

  constructor(data?: PartialMessage<RuleEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.RuleEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event_type", kind: "enum", T: proto3.getEnumType(EventType) },
    { no: 2, name: "time", kind: "message", T: Timestamp },
    { no: 3, name: "rule", kind: "message", T: Rule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RuleEvent {
    return new RuleEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RuleEvent {
    return new RuleEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RuleEvent {
    return new RuleEvent().fromJsonString(jsonString, options);
  }

  static equals(a: RuleEvent | PlainMessage<RuleEvent> | undefined, b: RuleEvent | PlainMessage<RuleEvent> | undefined): boolean {
    return proto3.util.equals(RuleEvent, a, b);
  }
}

/**
 * @generated from message anduril.communicationsmanager.v1.Rule
 */
export class Rule extends Message<Rule> {
  /**
   * Uniquely identifies a rule across hosts. If unset, the operation is
   * treated as a creation operation by the implementing service.
   *
   * @generated from field: string rule_id = 1;
   */
  ruleId = "";

  /**
   * The version of this rule.
   *
   * @generated from field: int64 version_num = 2;
   */
  versionNum = protoInt64.zero;

  /**
   * Whether or not this rule is enabled.
   *
   * @generated from field: bool enabled = 3;
   */
  enabled = false;

  /**
   * Human readable name associated with the rule.
   *
   * @generated from field: string name = 4;
   */
  name = "";

  /**
   * Type of rule and details regarding that rule.
   *
   * @generated from oneof anduril.communicationsmanager.v1.Rule.type
   */
  type: {
    /**
     * @generated from field: anduril.communicationsmanager.v1.DistributionRule distribution_rule = 5;
     */
    value: DistributionRule;
    case: "distributionRule";
  } | {
    /**
     * @generated from field: anduril.communicationsmanager.v1.IntegrationRule integration_rule = 6;
     */
    value: IntegrationRule;
    case: "integrationRule";
  } | {
    /**
     * @generated from field: anduril.communicationsmanager.v1.CrossDomainRule cross_domain_rule = 9;
     */
    value: CrossDomainRule;
    case: "crossDomainRule";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Email of the user who last modified the rule.
   *
   * @generated from field: string last_modified_by_user = 7;
   */
  lastModifiedByUser = "";

  /**
   * Unix epoch timestamp in milliseconds of when the rule was last modified.
   *
   * @generated from field: int64 last_modified_time_unix_epoch_ms = 8;
   */
  lastModifiedTimeUnixEpochMs = protoInt64.zero;

  constructor(data?: PartialMessage<Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.Rule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "distribution_rule", kind: "message", T: DistributionRule, oneof: "type" },
    { no: 6, name: "integration_rule", kind: "message", T: IntegrationRule, oneof: "type" },
    { no: 9, name: "cross_domain_rule", kind: "message", T: CrossDomainRule, oneof: "type" },
    { no: 7, name: "last_modified_by_user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "last_modified_time_unix_epoch_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rule {
    return new Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rule {
    return new Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rule {
    return new Rule().fromJsonString(jsonString, options);
  }

  static equals(a: Rule | PlainMessage<Rule> | undefined, b: Rule | PlainMessage<Rule> | undefined): boolean {
    return proto3.util.equals(Rule, a, b);
  }
}

/**
 * @generated from message anduril.communicationsmanager.v1.IntegrationRule
 */
export class IntegrationRule extends Message<IntegrationRule> {
  /**
   * Uniquely identifies an integration on a node.
   *
   * @generated from field: string integration_name = 1;
   */
  integrationName = "";

  /**
   * Producer hostId, equivalent to the rule's source.
   *
   * @generated from field: string host_id = 2;
   */
  hostId = "";

  /**
   * @generated from oneof anduril.communicationsmanager.v1.IntegrationRule.details
   */
  details: {
    /**
     * @generated from field: anduril.communicationsmanager.v1.EntityIntegrationRuleDetails entity_integration_rule_details = 3;
     */
    value: EntityIntegrationRuleDetails;
    case: "entityIntegrationRuleDetails";
  } | {
    /**
     * @generated from field: anduril.communicationsmanager.v1.BlobDistributionRuleDetails blob_integration_rule_details = 4;
     */
    value: BlobDistributionRuleDetails;
    case: "blobIntegrationRuleDetails";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<IntegrationRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.IntegrationRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integration_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "host_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "entity_integration_rule_details", kind: "message", T: EntityIntegrationRuleDetails, oneof: "details" },
    { no: 4, name: "blob_integration_rule_details", kind: "message", T: BlobDistributionRuleDetails, oneof: "details" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationRule {
    return new IntegrationRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationRule {
    return new IntegrationRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationRule {
    return new IntegrationRule().fromJsonString(jsonString, options);
  }

  static equals(a: IntegrationRule | PlainMessage<IntegrationRule> | undefined, b: IntegrationRule | PlainMessage<IntegrationRule> | undefined): boolean {
    return proto3.util.equals(IntegrationRule, a, b);
  }
}

/**
 * Distribution rules are conjunctive (AND) when applied at the producer.
 * This implies that given a primitive datum, if the datum satisfies a
 * producer rule AND a consumer rule, it will be broadcast to the network.
 *
 * @generated from message anduril.communicationsmanager.v1.DistributionRule
 */
export class DistributionRule extends Message<DistributionRule> {
  /**
   * Uniquely identifies a rule across hosts. If unset, the operation is
   * treated as a creation operation by the implementing service.
   *
   * TO BE DEPRECATED
   *
   * @generated from field: string rule_id = 1;
   */
  ruleId = "";

  /**
   * Deprecated: use version_num instead.
   *
   * @generated from field: string version = 2 [deprecated = true];
   * @deprecated
   */
  version = "";

  /**
   * Whether or not this rule is enabled.
   *
   * TO BE DEPRECATED
   *
   * @generated from field: bool enabled = 3;
   */
  enabled = false;

  /**
   * Deprecated: use sources instead.
   *
   * @generated from field: anduril.communicationsmanager.v1.Source source = 4 [deprecated = true];
   * @deprecated
   */
  source?: Source;

  /**
   * Used by consumer nodes to identify the source of the data to which they
   * are subscribing. In the case of an 'all' source, only a single entry should be present.
   *
   * @generated from field: repeated anduril.communicationsmanager.v1.Source sources = 8 [deprecated = true];
   * @deprecated
   */
  sources: Source[] = [];

  /**
   * Used by producers to direct publish traffic. If unset, publish for this
   * rule may be directed to all consumers.
   *
   * @generated from field: anduril.communicationsmanager.v1.Destination destination = 5 [deprecated = true];
   * @deprecated
   */
  destination?: Destination;

  /**
   * The details which inform how this primitive data is distributed.
   *
   * @generated from oneof anduril.communicationsmanager.v1.DistributionRule.details
   */
  details: {
    /**
     * Provides the fine-grained details controlling how entities are distributed.
     *
     * @generated from field: anduril.communicationsmanager.v1.EntityDistributionRuleDetails entity_details = 6;
     */
    value: EntityDistributionRuleDetails;
    case: "entityDetails";
  } | {
    /**
     * Provides the fine-grained detials controlling how blobs are distributed.
     *
     * @generated from field: anduril.communicationsmanager.v1.BlobDistributionRuleDetails blob_details = 13;
     */
    value: BlobDistributionRuleDetails;
    case: "blobDetails";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Determines the priority with which messages passing this rule are sent. Valid values are in the range of [0, 7].
   * 0 is the lowest and 7 is the highest priority.
   *
   * @generated from field: uint32 priority = 7;
   */
  priority = 0;

  /**
   * Human readable description describing the DistributionRule.
   *
   * TO BE DEPRECATED
   *
   * @generated from field: string description = 9;
   */
  description = "";

  /**
   * Human readable name associated with the rule.
   *
   * TO BE DEPRECATED
   *
   * @generated from field: string name = 10;
   */
  name = "";

  /**
   * The version of this distribution rule.
   *
   * TO BE DEPRECATED
   *
   * @generated from field: int64 version_num = 11;
   */
  versionNum = protoInt64.zero;

  /**
   * Contains the definition for either an inbound rule []source -> destination relationship or an outbound rule
   * source -> []destinations relationship. This will define the rule mechanism, where outbound rules are a deny-list
   * and inbound rules are an allow-list.
   *
   * @generated from field: anduril.communicationsmanager.v1.SourceDestinationDirectionalControl source_destination_directional_control = 12;
   */
  sourceDestinationDirectionalControl?: SourceDestinationDirectionalControl;

  constructor(data?: PartialMessage<DistributionRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.DistributionRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rule_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "source", kind: "message", T: Source },
    { no: 8, name: "sources", kind: "message", T: Source, repeated: true },
    { no: 5, name: "destination", kind: "message", T: Destination },
    { no: 6, name: "entity_details", kind: "message", T: EntityDistributionRuleDetails, oneof: "details" },
    { no: 13, name: "blob_details", kind: "message", T: BlobDistributionRuleDetails, oneof: "details" },
    { no: 7, name: "priority", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 9, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "version_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 12, name: "source_destination_directional_control", kind: "message", T: SourceDestinationDirectionalControl },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DistributionRule {
    return new DistributionRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DistributionRule {
    return new DistributionRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DistributionRule {
    return new DistributionRule().fromJsonString(jsonString, options);
  }

  static equals(a: DistributionRule | PlainMessage<DistributionRule> | undefined, b: DistributionRule | PlainMessage<DistributionRule> | undefined): boolean {
    return proto3.util.equals(DistributionRule, a, b);
  }
}

/**
 * @generated from message anduril.communicationsmanager.v1.SourceDestinationDirectionalControl
 */
export class SourceDestinationDirectionalControl extends Message<SourceDestinationDirectionalControl> {
  /**
   * @generated from oneof anduril.communicationsmanager.v1.SourceDestinationDirectionalControl.source_destination
   */
  sourceDestination: {
    /**
     * @generated from field: anduril.communicationsmanager.v1.InboundRuleSourceDestination inbound_rule_source_destination = 1;
     */
    value: InboundRuleSourceDestination;
    case: "inboundRuleSourceDestination";
  } | {
    /**
     * @generated from field: anduril.communicationsmanager.v1.OutboundRuleSourceDestination outbound_rule_source_destination = 2;
     */
    value: OutboundRuleSourceDestination;
    case: "outboundRuleSourceDestination";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SourceDestinationDirectionalControl>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.SourceDestinationDirectionalControl";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inbound_rule_source_destination", kind: "message", T: InboundRuleSourceDestination, oneof: "source_destination" },
    { no: 2, name: "outbound_rule_source_destination", kind: "message", T: OutboundRuleSourceDestination, oneof: "source_destination" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SourceDestinationDirectionalControl {
    return new SourceDestinationDirectionalControl().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SourceDestinationDirectionalControl {
    return new SourceDestinationDirectionalControl().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SourceDestinationDirectionalControl {
    return new SourceDestinationDirectionalControl().fromJsonString(jsonString, options);
  }

  static equals(a: SourceDestinationDirectionalControl | PlainMessage<SourceDestinationDirectionalControl> | undefined, b: SourceDestinationDirectionalControl | PlainMessage<SourceDestinationDirectionalControl> | undefined): boolean {
    return proto3.util.equals(SourceDestinationDirectionalControl, a, b);
  }
}

/**
 * Many destinations to one source. The source will block data from being sent to the destinations when matched by
 * a filter statement. Rule is owned by the source.
 *
 * @generated from message anduril.communicationsmanager.v1.OutboundRuleSourceDestination
 */
export class OutboundRuleSourceDestination extends Message<OutboundRuleSourceDestination> {
  /**
   * @generated from field: anduril.communicationsmanager.v1.Source source = 1;
   */
  source?: Source;

  /**
   * @generated from field: repeated anduril.communicationsmanager.v1.Destination destinations = 2;
   */
  destinations: Destination[] = [];

  constructor(data?: PartialMessage<OutboundRuleSourceDestination>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.OutboundRuleSourceDestination";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "message", T: Source },
    { no: 2, name: "destinations", kind: "message", T: Destination, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutboundRuleSourceDestination {
    return new OutboundRuleSourceDestination().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutboundRuleSourceDestination {
    return new OutboundRuleSourceDestination().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutboundRuleSourceDestination {
    return new OutboundRuleSourceDestination().fromJsonString(jsonString, options);
  }

  static equals(a: OutboundRuleSourceDestination | PlainMessage<OutboundRuleSourceDestination> | undefined, b: OutboundRuleSourceDestination | PlainMessage<OutboundRuleSourceDestination> | undefined): boolean {
    return proto3.util.equals(OutboundRuleSourceDestination, a, b);
  }
}

/**
 * Many sources to one Destination. The destination will request data from the sources
 * when matched by a filter statement. Rule is owned by the destination.
 *
 * @generated from message anduril.communicationsmanager.v1.InboundRuleSourceDestination
 */
export class InboundRuleSourceDestination extends Message<InboundRuleSourceDestination> {
  /**
   * @generated from field: repeated anduril.communicationsmanager.v1.Source sources = 1;
   */
  sources: Source[] = [];

  /**
   * @generated from field: anduril.communicationsmanager.v1.Destination destination = 2;
   */
  destination?: Destination;

  constructor(data?: PartialMessage<InboundRuleSourceDestination>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.InboundRuleSourceDestination";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sources", kind: "message", T: Source, repeated: true },
    { no: 2, name: "destination", kind: "message", T: Destination },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InboundRuleSourceDestination {
    return new InboundRuleSourceDestination().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InboundRuleSourceDestination {
    return new InboundRuleSourceDestination().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InboundRuleSourceDestination {
    return new InboundRuleSourceDestination().fromJsonString(jsonString, options);
  }

  static equals(a: InboundRuleSourceDestination | PlainMessage<InboundRuleSourceDestination> | undefined, b: InboundRuleSourceDestination | PlainMessage<InboundRuleSourceDestination> | undefined): boolean {
    return proto3.util.equals(InboundRuleSourceDestination, a, b);
  }
}

/**
 * A source from which primitive data are routed.
 *
 * @generated from message anduril.communicationsmanager.v1.Source
 */
export class Source extends Message<Source> {
  /**
   * The type of source.
   *
   * @generated from oneof anduril.communicationsmanager.v1.Source.source
   */
  source: {
    /**
     * The source is a particular asset ID.
     *
     * @generated from field: string asset_id = 1 [deprecated = true];
     * @deprecated
     */
    value: string;
    case: "assetId";
  } | {
    /**
     * The source is all sources. This selection is only used for inbound rules.
     *
     * @generated from field: bool all = 2;
     */
    value: boolean;
    case: "all";
  } | {
    /**
     * The source is a particular host ID.
     *
     * @generated from field: string host_id = 3;
     */
    value: string;
    case: "hostId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Source>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.Source";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "asset_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "source" },
    { no: 2, name: "all", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "source" },
    { no: 3, name: "host_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "source" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Source {
    return new Source().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Source {
    return new Source().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Source {
    return new Source().fromJsonString(jsonString, options);
  }

  static equals(a: Source | PlainMessage<Source> | undefined, b: Source | PlainMessage<Source> | undefined): boolean {
    return proto3.util.equals(Source, a, b);
  }
}

/**
 * A destination to which data are routed.
 *
 * @generated from message anduril.communicationsmanager.v1.Destination
 */
export class Destination extends Message<Destination> {
  /**
   * The type of destination.
   *
   * @generated from oneof anduril.communicationsmanager.v1.Destination.destination
   */
  destination: {
    /**
     * The destination is a particular asset ID.
     *
     * @generated from field: string asset_id = 1 [deprecated = true];
     * @deprecated
     */
    value: string;
    case: "assetId";
  } | {
    /**
     * The destination is a particular host ID.
     *
     * @generated from field: string host_id = 2;
     */
    value: string;
    case: "hostId";
  } | {
    /**
     * The destination is all destinations. This selection is only used for outbound rules.
     *
     * @generated from field: bool all = 3;
     */
    value: boolean;
    case: "all";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Destination>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.Destination";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "asset_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "destination" },
    { no: 2, name: "host_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "destination" },
    { no: 3, name: "all", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "destination" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Destination {
    return new Destination().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Destination {
    return new Destination().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Destination {
    return new Destination().fromJsonString(jsonString, options);
  }

  static equals(a: Destination | PlainMessage<Destination> | undefined, b: Destination | PlainMessage<Destination> | undefined): boolean {
    return proto3.util.equals(Destination, a, b);
  }
}

/**
 * Message to contain additional business logic for entities. Entity_Filter and Dynamic Statement are ANDed together
 * when both are present.
 *
 * @generated from message anduril.communicationsmanager.v1.EntityDistributionRuleDetails
 */
export class EntityDistributionRuleDetails extends Message<EntityDistributionRuleDetails> {
  /**
   * Controls the filtering which should be applied in the compliant service.
   * TO BE DEPRECATED, use entity_filter_selection
   *
   * @generated from field: anduril.entitymanager.v1.Statement entity_filter = 1;
   */
  entityFilter?: Statement;

  /**
   * @generated from oneof anduril.communicationsmanager.v1.EntityDistributionRuleDetails.entity_filter_selection
   */
  entityFilterSelection: {
    /**
     * Controls the filtering which should be applied in the compliant service.
     *
     * @generated from field: anduril.entitymanager.v1.Statement static_statement = 2;
     */
    value: Statement;
    case: "staticStatement";
  } | {
    /**
     * Used for matching location details.
     *
     * @generated from field: anduril.entitymanager.v1.DynamicStatement dynamic_statement = 3;
     */
    value: DynamicStatement;
    case: "dynamicStatement";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<EntityDistributionRuleDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.EntityDistributionRuleDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_filter", kind: "message", T: Statement },
    { no: 2, name: "static_statement", kind: "message", T: Statement, oneof: "entity_filter_selection" },
    { no: 3, name: "dynamic_statement", kind: "message", T: DynamicStatement, oneof: "entity_filter_selection" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EntityDistributionRuleDetails {
    return new EntityDistributionRuleDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EntityDistributionRuleDetails {
    return new EntityDistributionRuleDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EntityDistributionRuleDetails {
    return new EntityDistributionRuleDetails().fromJsonString(jsonString, options);
  }

  static equals(a: EntityDistributionRuleDetails | PlainMessage<EntityDistributionRuleDetails> | undefined, b: EntityDistributionRuleDetails | PlainMessage<EntityDistributionRuleDetails> | undefined): boolean {
    return proto3.util.equals(EntityDistributionRuleDetails, a, b);
  }
}

/**
 * @generated from message anduril.communicationsmanager.v1.BlobDistributionRuleDetails
 */
export class BlobDistributionRuleDetails extends Message<BlobDistributionRuleDetails> {
  /**
   * @generated from field: anduril.blobs.v1.Statement blob_filter = 1 [deprecated = true];
   * @deprecated
   */
  blobFilter?: Statement$1;

  /**
   * Controls blob filtering using disjoint matching, meaning only 1 statement needs to match.
   *
   * @generated from field: repeated anduril.blobs.v1.Statement blob_filters = 2;
   */
  blobFilters: Statement$1[] = [];

  constructor(data?: PartialMessage<BlobDistributionRuleDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.BlobDistributionRuleDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "blob_filter", kind: "message", T: Statement$1 },
    { no: 2, name: "blob_filters", kind: "message", T: Statement$1, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlobDistributionRuleDetails {
    return new BlobDistributionRuleDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlobDistributionRuleDetails {
    return new BlobDistributionRuleDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlobDistributionRuleDetails {
    return new BlobDistributionRuleDetails().fromJsonString(jsonString, options);
  }

  static equals(a: BlobDistributionRuleDetails | PlainMessage<BlobDistributionRuleDetails> | undefined, b: BlobDistributionRuleDetails | PlainMessage<BlobDistributionRuleDetails> | undefined): boolean {
    return proto3.util.equals(BlobDistributionRuleDetails, a, b);
  }
}

/**
 * CommunicationsManagerError message contents.
 *
 * @generated from message anduril.communicationsmanager.v1.CommunicationsManagerError
 */
export class CommunicationsManagerError extends Message<CommunicationsManagerError> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  constructor(data?: PartialMessage<CommunicationsManagerError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.CommunicationsManagerError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommunicationsManagerError {
    return new CommunicationsManagerError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommunicationsManagerError {
    return new CommunicationsManagerError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommunicationsManagerError {
    return new CommunicationsManagerError().fromJsonString(jsonString, options);
  }

  static equals(a: CommunicationsManagerError | PlainMessage<CommunicationsManagerError> | undefined, b: CommunicationsManagerError | PlainMessage<CommunicationsManagerError> | undefined): boolean {
    return proto3.util.equals(CommunicationsManagerError, a, b);
  }
}

/**
 * Rule to apply to Cross Domain, will function as an inbound filter which allows matching entities to pass through.
 *
 * @generated from message anduril.communicationsmanager.v1.CrossDomainRule
 */
export class CrossDomainRule extends Message<CrossDomainRule> {
  /**
   * @generated from oneof anduril.communicationsmanager.v1.CrossDomainRule.details
   */
  details: {
    /**
     * @generated from field: anduril.communicationsmanager.v1.EntityDistributionRuleDetails entity_details = 1;
     */
    value: EntityDistributionRuleDetails;
    case: "entityDetails";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Destination CDS to apply the rule to.
   *
   * @generated from field: anduril.communicationsmanager.v1.CdsDestination cds_destination = 2;
   */
  cdsDestination?: CdsDestination;

  constructor(data?: PartialMessage<CrossDomainRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.CrossDomainRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_details", kind: "message", T: EntityDistributionRuleDetails, oneof: "details" },
    { no: 2, name: "cds_destination", kind: "message", T: CdsDestination },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CrossDomainRule {
    return new CrossDomainRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CrossDomainRule {
    return new CrossDomainRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CrossDomainRule {
    return new CrossDomainRule().fromJsonString(jsonString, options);
  }

  static equals(a: CrossDomainRule | PlainMessage<CrossDomainRule> | undefined, b: CrossDomainRule | PlainMessage<CrossDomainRule> | undefined): boolean {
    return proto3.util.equals(CrossDomainRule, a, b);
  }
}

