// @generated by protoc-gen-es v1.7.2
// @generated from file anduril/communicationsmanager/v1/common.pub.proto (package anduril.communicationsmanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { EntityIntegrationRuleDetails } from "./entity.pub_pb.js";
import type { Statement } from "../../entitymanager/v1/filter.pub_pb.js";
import type { DynamicStatement } from "../../entitymanager/v1/filter_dynamic.pub_pb.js";
import type { Statement as Statement$1 } from "../../blobs/v1/filter.pub_pb.js";
import type { CdsDestination } from "./cross_domain.pub_pb.js";

/**
 * The type of distribution rule event.
 *
 * @generated from enum anduril.communicationsmanager.v1.EventType
 */
export declare enum EventType {
  /**
   * @generated from enum value: EVENT_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * Rule was created.
   *
   * @generated from enum value: EVENT_TYPE_CREATED = 1;
   */
  CREATED = 1,

  /**
   * Rule was updated.
   *
   * @generated from enum value: EVENT_TYPE_UPDATE = 2;
   */
  UPDATE = 2,

  /**
   * Rule was deleted.
   *
   * @generated from enum value: EVENT_TYPE_DELETED = 3;
   */
  DELETED = 3,

  /**
   * Rule already existed, but sent on a new stream connection.
   *
   * @generated from enum value: EVENT_TYPE_PREEXISTING = 4;
   */
  PREEXISTING = 4,
}

/**
 * Event representing a type of distribution rule change.
 *
 * @generated from message anduril.communicationsmanager.v1.DistributionRuleEvent
 */
export declare class DistributionRuleEvent extends Message<DistributionRuleEvent> {
  /**
   * The type of distribution rule event.
   *
   * @generated from field: anduril.communicationsmanager.v1.EventType event_type = 1;
   */
  eventType: EventType;

  /**
   * @generated from field: google.protobuf.Timestamp time = 2;
   */
  time?: Timestamp;

  /**
   * @generated from field: anduril.communicationsmanager.v1.DistributionRule distribution_rule = 3;
   */
  distributionRule?: DistributionRule;

  constructor(data?: PartialMessage<DistributionRuleEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.DistributionRuleEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DistributionRuleEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DistributionRuleEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DistributionRuleEvent;

  static equals(a: DistributionRuleEvent | PlainMessage<DistributionRuleEvent> | undefined, b: DistributionRuleEvent | PlainMessage<DistributionRuleEvent> | undefined): boolean;
}

/**
 * @generated from message anduril.communicationsmanager.v1.RuleEvent
 */
export declare class RuleEvent extends Message<RuleEvent> {
  /**
   * @generated from field: anduril.communicationsmanager.v1.EventType event_type = 1;
   */
  eventType: EventType;

  /**
   * @generated from field: google.protobuf.Timestamp time = 2;
   */
  time?: Timestamp;

  /**
   * @generated from field: anduril.communicationsmanager.v1.Rule rule = 3;
   */
  rule?: Rule;

  constructor(data?: PartialMessage<RuleEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.RuleEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RuleEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RuleEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RuleEvent;

  static equals(a: RuleEvent | PlainMessage<RuleEvent> | undefined, b: RuleEvent | PlainMessage<RuleEvent> | undefined): boolean;
}

/**
 * @generated from message anduril.communicationsmanager.v1.Rule
 */
export declare class Rule extends Message<Rule> {
  /**
   * Uniquely identifies a rule across hosts. If unset, the operation is
   * treated as a creation operation by the implementing service.
   *
   * @generated from field: string rule_id = 1;
   */
  ruleId: string;

  /**
   * The version of this rule.
   *
   * @generated from field: int64 version_num = 2;
   */
  versionNum: bigint;

  /**
   * Whether or not this rule is enabled.
   *
   * @generated from field: bool enabled = 3;
   */
  enabled: boolean;

  /**
   * Human readable name associated with the rule.
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * Type of rule and details regarding that rule.
   *
   * @generated from oneof anduril.communicationsmanager.v1.Rule.type
   */
  type: {
    /**
     * @generated from field: anduril.communicationsmanager.v1.DistributionRule distribution_rule = 5;
     */
    value: DistributionRule;
    case: "distributionRule";
  } | {
    /**
     * @generated from field: anduril.communicationsmanager.v1.IntegrationRule integration_rule = 6;
     */
    value: IntegrationRule;
    case: "integrationRule";
  } | {
    /**
     * @generated from field: anduril.communicationsmanager.v1.CrossDomainRule cross_domain_rule = 9;
     */
    value: CrossDomainRule;
    case: "crossDomainRule";
  } | { case: undefined; value?: undefined };

  /**
   * Email of the user who last modified the rule.
   *
   * @generated from field: string last_modified_by_user = 7;
   */
  lastModifiedByUser: string;

  /**
   * Unix epoch timestamp in milliseconds of when the rule was last modified.
   *
   * @generated from field: int64 last_modified_time_unix_epoch_ms = 8;
   */
  lastModifiedTimeUnixEpochMs: bigint;

  constructor(data?: PartialMessage<Rule>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.Rule";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rule;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rule;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rule;

  static equals(a: Rule | PlainMessage<Rule> | undefined, b: Rule | PlainMessage<Rule> | undefined): boolean;
}

/**
 * @generated from message anduril.communicationsmanager.v1.IntegrationRule
 */
export declare class IntegrationRule extends Message<IntegrationRule> {
  /**
   * Uniquely identifies an integration on a node.
   *
   * @generated from field: string integration_name = 1;
   */
  integrationName: string;

  /**
   * Producer hostId, equivalent to the rule's source.
   *
   * @generated from field: string host_id = 2;
   */
  hostId: string;

  /**
   * @generated from oneof anduril.communicationsmanager.v1.IntegrationRule.details
   */
  details: {
    /**
     * @generated from field: anduril.communicationsmanager.v1.EntityIntegrationRuleDetails entity_integration_rule_details = 3;
     */
    value: EntityIntegrationRuleDetails;
    case: "entityIntegrationRuleDetails";
  } | {
    /**
     * @generated from field: anduril.communicationsmanager.v1.BlobDistributionRuleDetails blob_integration_rule_details = 4;
     */
    value: BlobDistributionRuleDetails;
    case: "blobIntegrationRuleDetails";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<IntegrationRule>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.IntegrationRule";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegrationRule;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegrationRule;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegrationRule;

  static equals(a: IntegrationRule | PlainMessage<IntegrationRule> | undefined, b: IntegrationRule | PlainMessage<IntegrationRule> | undefined): boolean;
}

/**
 * Distribution rules are conjunctive (AND) when applied at the producer.
 * This implies that given a primitive datum, if the datum satisfies a
 * producer rule AND a consumer rule, it will be broadcast to the network.
 *
 * @generated from message anduril.communicationsmanager.v1.DistributionRule
 */
export declare class DistributionRule extends Message<DistributionRule> {
  /**
   * Uniquely identifies a rule across hosts. If unset, the operation is
   * treated as a creation operation by the implementing service.
   *
   * TO BE DEPRECATED
   *
   * @generated from field: string rule_id = 1;
   */
  ruleId: string;

  /**
   * Deprecated: use version_num instead.
   *
   * @generated from field: string version = 2 [deprecated = true];
   * @deprecated
   */
  version: string;

  /**
   * Whether or not this rule is enabled.
   *
   * TO BE DEPRECATED
   *
   * @generated from field: bool enabled = 3;
   */
  enabled: boolean;

  /**
   * Deprecated: use sources instead.
   *
   * @generated from field: anduril.communicationsmanager.v1.Source source = 4 [deprecated = true];
   * @deprecated
   */
  source?: Source;

  /**
   * Used by consumer nodes to identify the source of the data to which they
   * are subscribing. In the case of an 'all' source, only a single entry should be present.
   *
   * @generated from field: repeated anduril.communicationsmanager.v1.Source sources = 8 [deprecated = true];
   * @deprecated
   */
  sources: Source[];

  /**
   * Used by producers to direct publish traffic. If unset, publish for this
   * rule may be directed to all consumers.
   *
   * @generated from field: anduril.communicationsmanager.v1.Destination destination = 5 [deprecated = true];
   * @deprecated
   */
  destination?: Destination;

  /**
   * The details which inform how this primitive data is distributed.
   *
   * @generated from oneof anduril.communicationsmanager.v1.DistributionRule.details
   */
  details: {
    /**
     * Provides the fine-grained details controlling how entities are distributed.
     *
     * @generated from field: anduril.communicationsmanager.v1.EntityDistributionRuleDetails entity_details = 6;
     */
    value: EntityDistributionRuleDetails;
    case: "entityDetails";
  } | {
    /**
     * Provides the fine-grained detials controlling how blobs are distributed.
     *
     * @generated from field: anduril.communicationsmanager.v1.BlobDistributionRuleDetails blob_details = 13;
     */
    value: BlobDistributionRuleDetails;
    case: "blobDetails";
  } | { case: undefined; value?: undefined };

  /**
   * Determines the priority with which messages passing this rule are sent. Valid values are in the range of [0, 7].
   * 0 is the lowest and 7 is the highest priority.
   *
   * @generated from field: uint32 priority = 7;
   */
  priority: number;

  /**
   * Human readable description describing the DistributionRule.
   *
   * TO BE DEPRECATED
   *
   * @generated from field: string description = 9;
   */
  description: string;

  /**
   * Human readable name associated with the rule.
   *
   * TO BE DEPRECATED
   *
   * @generated from field: string name = 10;
   */
  name: string;

  /**
   * The version of this distribution rule.
   *
   * TO BE DEPRECATED
   *
   * @generated from field: int64 version_num = 11;
   */
  versionNum: bigint;

  /**
   * Contains the definition for either an inbound rule []source -> destination relationship or an outbound rule
   * source -> []destinations relationship. This will define the rule mechanism, where outbound rules are a deny-list
   * and inbound rules are an allow-list.
   *
   * @generated from field: anduril.communicationsmanager.v1.SourceDestinationDirectionalControl source_destination_directional_control = 12;
   */
  sourceDestinationDirectionalControl?: SourceDestinationDirectionalControl;

  constructor(data?: PartialMessage<DistributionRule>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.DistributionRule";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DistributionRule;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DistributionRule;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DistributionRule;

  static equals(a: DistributionRule | PlainMessage<DistributionRule> | undefined, b: DistributionRule | PlainMessage<DistributionRule> | undefined): boolean;
}

/**
 * @generated from message anduril.communicationsmanager.v1.SourceDestinationDirectionalControl
 */
export declare class SourceDestinationDirectionalControl extends Message<SourceDestinationDirectionalControl> {
  /**
   * @generated from oneof anduril.communicationsmanager.v1.SourceDestinationDirectionalControl.source_destination
   */
  sourceDestination: {
    /**
     * @generated from field: anduril.communicationsmanager.v1.InboundRuleSourceDestination inbound_rule_source_destination = 1;
     */
    value: InboundRuleSourceDestination;
    case: "inboundRuleSourceDestination";
  } | {
    /**
     * @generated from field: anduril.communicationsmanager.v1.OutboundRuleSourceDestination outbound_rule_source_destination = 2;
     */
    value: OutboundRuleSourceDestination;
    case: "outboundRuleSourceDestination";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<SourceDestinationDirectionalControl>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.SourceDestinationDirectionalControl";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SourceDestinationDirectionalControl;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SourceDestinationDirectionalControl;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SourceDestinationDirectionalControl;

  static equals(a: SourceDestinationDirectionalControl | PlainMessage<SourceDestinationDirectionalControl> | undefined, b: SourceDestinationDirectionalControl | PlainMessage<SourceDestinationDirectionalControl> | undefined): boolean;
}

/**
 * Many destinations to one source. The source will block data from being sent to the destinations when matched by
 * a filter statement. Rule is owned by the source.
 *
 * @generated from message anduril.communicationsmanager.v1.OutboundRuleSourceDestination
 */
export declare class OutboundRuleSourceDestination extends Message<OutboundRuleSourceDestination> {
  /**
   * @generated from field: anduril.communicationsmanager.v1.Source source = 1;
   */
  source?: Source;

  /**
   * @generated from field: repeated anduril.communicationsmanager.v1.Destination destinations = 2;
   */
  destinations: Destination[];

  constructor(data?: PartialMessage<OutboundRuleSourceDestination>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.OutboundRuleSourceDestination";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutboundRuleSourceDestination;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutboundRuleSourceDestination;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutboundRuleSourceDestination;

  static equals(a: OutboundRuleSourceDestination | PlainMessage<OutboundRuleSourceDestination> | undefined, b: OutboundRuleSourceDestination | PlainMessage<OutboundRuleSourceDestination> | undefined): boolean;
}

/**
 * Many sources to one Destination. The destination will request data from the sources
 * when matched by a filter statement. Rule is owned by the destination.
 *
 * @generated from message anduril.communicationsmanager.v1.InboundRuleSourceDestination
 */
export declare class InboundRuleSourceDestination extends Message<InboundRuleSourceDestination> {
  /**
   * @generated from field: repeated anduril.communicationsmanager.v1.Source sources = 1;
   */
  sources: Source[];

  /**
   * @generated from field: anduril.communicationsmanager.v1.Destination destination = 2;
   */
  destination?: Destination;

  constructor(data?: PartialMessage<InboundRuleSourceDestination>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.InboundRuleSourceDestination";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InboundRuleSourceDestination;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InboundRuleSourceDestination;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InboundRuleSourceDestination;

  static equals(a: InboundRuleSourceDestination | PlainMessage<InboundRuleSourceDestination> | undefined, b: InboundRuleSourceDestination | PlainMessage<InboundRuleSourceDestination> | undefined): boolean;
}

/**
 * A source from which primitive data are routed.
 *
 * @generated from message anduril.communicationsmanager.v1.Source
 */
export declare class Source extends Message<Source> {
  /**
   * The type of source.
   *
   * @generated from oneof anduril.communicationsmanager.v1.Source.source
   */
  source: {
    /**
     * The source is a particular asset ID.
     *
     * @generated from field: string asset_id = 1 [deprecated = true];
     * @deprecated
     */
    value: string;
    case: "assetId";
  } | {
    /**
     * The source is all sources. This selection is only used for inbound rules.
     *
     * @generated from field: bool all = 2;
     */
    value: boolean;
    case: "all";
  } | {
    /**
     * The source is a particular host ID.
     *
     * @generated from field: string host_id = 3;
     */
    value: string;
    case: "hostId";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Source>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.Source";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Source;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Source;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Source;

  static equals(a: Source | PlainMessage<Source> | undefined, b: Source | PlainMessage<Source> | undefined): boolean;
}

/**
 * A destination to which data are routed.
 *
 * @generated from message anduril.communicationsmanager.v1.Destination
 */
export declare class Destination extends Message<Destination> {
  /**
   * The type of destination.
   *
   * @generated from oneof anduril.communicationsmanager.v1.Destination.destination
   */
  destination: {
    /**
     * The destination is a particular asset ID.
     *
     * @generated from field: string asset_id = 1 [deprecated = true];
     * @deprecated
     */
    value: string;
    case: "assetId";
  } | {
    /**
     * The destination is a particular host ID.
     *
     * @generated from field: string host_id = 2;
     */
    value: string;
    case: "hostId";
  } | {
    /**
     * The destination is all destinations. This selection is only used for outbound rules.
     *
     * @generated from field: bool all = 3;
     */
    value: boolean;
    case: "all";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Destination>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.Destination";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Destination;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Destination;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Destination;

  static equals(a: Destination | PlainMessage<Destination> | undefined, b: Destination | PlainMessage<Destination> | undefined): boolean;
}

/**
 * Message to contain additional business logic for entities. Entity_Filter and Dynamic Statement are ANDed together
 * when both are present.
 *
 * @generated from message anduril.communicationsmanager.v1.EntityDistributionRuleDetails
 */
export declare class EntityDistributionRuleDetails extends Message<EntityDistributionRuleDetails> {
  /**
   * Controls the filtering which should be applied in the compliant service.
   * TO BE DEPRECATED, use entity_filter_selection
   *
   * @generated from field: anduril.entitymanager.v1.Statement entity_filter = 1;
   */
  entityFilter?: Statement;

  /**
   * @generated from oneof anduril.communicationsmanager.v1.EntityDistributionRuleDetails.entity_filter_selection
   */
  entityFilterSelection: {
    /**
     * Controls the filtering which should be applied in the compliant service.
     *
     * @generated from field: anduril.entitymanager.v1.Statement static_statement = 2;
     */
    value: Statement;
    case: "staticStatement";
  } | {
    /**
     * Used for matching location details.
     *
     * @generated from field: anduril.entitymanager.v1.DynamicStatement dynamic_statement = 3;
     */
    value: DynamicStatement;
    case: "dynamicStatement";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<EntityDistributionRuleDetails>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.EntityDistributionRuleDetails";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EntityDistributionRuleDetails;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EntityDistributionRuleDetails;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EntityDistributionRuleDetails;

  static equals(a: EntityDistributionRuleDetails | PlainMessage<EntityDistributionRuleDetails> | undefined, b: EntityDistributionRuleDetails | PlainMessage<EntityDistributionRuleDetails> | undefined): boolean;
}

/**
 * @generated from message anduril.communicationsmanager.v1.BlobDistributionRuleDetails
 */
export declare class BlobDistributionRuleDetails extends Message<BlobDistributionRuleDetails> {
  /**
   * @generated from field: anduril.blobs.v1.Statement blob_filter = 1 [deprecated = true];
   * @deprecated
   */
  blobFilter?: Statement$1;

  /**
   * Controls blob filtering using disjoint matching, meaning only 1 statement needs to match.
   *
   * @generated from field: repeated anduril.blobs.v1.Statement blob_filters = 2;
   */
  blobFilters: Statement$1[];

  constructor(data?: PartialMessage<BlobDistributionRuleDetails>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.BlobDistributionRuleDetails";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlobDistributionRuleDetails;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlobDistributionRuleDetails;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlobDistributionRuleDetails;

  static equals(a: BlobDistributionRuleDetails | PlainMessage<BlobDistributionRuleDetails> | undefined, b: BlobDistributionRuleDetails | PlainMessage<BlobDistributionRuleDetails> | undefined): boolean;
}

/**
 * CommunicationsManagerError message contents.
 *
 * @generated from message anduril.communicationsmanager.v1.CommunicationsManagerError
 */
export declare class CommunicationsManagerError extends Message<CommunicationsManagerError> {
  /**
   * @generated from field: string message = 1;
   */
  message: string;

  constructor(data?: PartialMessage<CommunicationsManagerError>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.CommunicationsManagerError";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommunicationsManagerError;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommunicationsManagerError;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommunicationsManagerError;

  static equals(a: CommunicationsManagerError | PlainMessage<CommunicationsManagerError> | undefined, b: CommunicationsManagerError | PlainMessage<CommunicationsManagerError> | undefined): boolean;
}

/**
 * Rule to apply to Cross Domain, will function as an inbound filter which allows matching entities to pass through.
 *
 * @generated from message anduril.communicationsmanager.v1.CrossDomainRule
 */
export declare class CrossDomainRule extends Message<CrossDomainRule> {
  /**
   * @generated from oneof anduril.communicationsmanager.v1.CrossDomainRule.details
   */
  details: {
    /**
     * @generated from field: anduril.communicationsmanager.v1.EntityDistributionRuleDetails entity_details = 1;
     */
    value: EntityDistributionRuleDetails;
    case: "entityDetails";
  } | { case: undefined; value?: undefined };

  /**
   * Destination CDS to apply the rule to.
   *
   * @generated from field: anduril.communicationsmanager.v1.CdsDestination cds_destination = 2;
   */
  cdsDestination?: CdsDestination;

  constructor(data?: PartialMessage<CrossDomainRule>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.communicationsmanager.v1.CrossDomainRule";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CrossDomainRule;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CrossDomainRule;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CrossDomainRule;

  static equals(a: CrossDomainRule | PlainMessage<CrossDomainRule> | undefined, b: CrossDomainRule | PlainMessage<CrossDomainRule> | undefined): boolean;
}

