// @generated by protoc-gen-es v1.7.2 with parameter "js_import_style=legacy_commonjs"
// @generated from file anduril/communicationsmanager/v1/common.pub.proto (package anduril.communicationsmanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

const { proto3, Timestamp } = require("@bufbuild/protobuf");
const { EntityIntegrationRuleDetails } = require("./entity.pub_pb.js");
const { Statement } = require("../../entitymanager/v1/filter.pub_pb.js");
const { DynamicStatement } = require("../../entitymanager/v1/filter_dynamic.pub_pb.js");
const { Statement: Statement$1 } = require("../../blobs/v1/filter.pub_pb.js");
const { CdsDestination } = require("./cross_domain.pub_pb.js");

/**
 * The type of distribution rule event.
 *
 * @generated from enum anduril.communicationsmanager.v1.EventType
 */
const EventType = proto3.makeEnum(
  "anduril.communicationsmanager.v1.EventType",
  [
    {no: 0, name: "EVENT_TYPE_INVALID", localName: "INVALID"},
    {no: 1, name: "EVENT_TYPE_CREATED", localName: "CREATED"},
    {no: 2, name: "EVENT_TYPE_UPDATE", localName: "UPDATE"},
    {no: 3, name: "EVENT_TYPE_DELETED", localName: "DELETED"},
    {no: 4, name: "EVENT_TYPE_PREEXISTING", localName: "PREEXISTING"},
  ],
);

/**
 * Event representing a type of distribution rule change.
 *
 * @generated from message anduril.communicationsmanager.v1.DistributionRuleEvent
 */
const DistributionRuleEvent = proto3.makeMessageType(
  "anduril.communicationsmanager.v1.DistributionRuleEvent",
  () => [
    { no: 1, name: "event_type", kind: "enum", T: proto3.getEnumType(EventType) },
    { no: 2, name: "time", kind: "message", T: Timestamp },
    { no: 3, name: "distribution_rule", kind: "message", T: DistributionRule },
  ],
);

/**
 * @generated from message anduril.communicationsmanager.v1.RuleEvent
 */
const RuleEvent = proto3.makeMessageType(
  "anduril.communicationsmanager.v1.RuleEvent",
  () => [
    { no: 1, name: "event_type", kind: "enum", T: proto3.getEnumType(EventType) },
    { no: 2, name: "time", kind: "message", T: Timestamp },
    { no: 3, name: "rule", kind: "message", T: Rule },
  ],
);

/**
 * @generated from message anduril.communicationsmanager.v1.Rule
 */
const Rule = proto3.makeMessageType(
  "anduril.communicationsmanager.v1.Rule",
  () => [
    { no: 1, name: "rule_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "distribution_rule", kind: "message", T: DistributionRule, oneof: "type" },
    { no: 6, name: "integration_rule", kind: "message", T: IntegrationRule, oneof: "type" },
    { no: 9, name: "cross_domain_rule", kind: "message", T: CrossDomainRule, oneof: "type" },
    { no: 7, name: "last_modified_by_user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "last_modified_time_unix_epoch_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ],
);

/**
 * @generated from message anduril.communicationsmanager.v1.IntegrationRule
 */
const IntegrationRule = proto3.makeMessageType(
  "anduril.communicationsmanager.v1.IntegrationRule",
  () => [
    { no: 1, name: "integration_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "host_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "entity_integration_rule_details", kind: "message", T: EntityIntegrationRuleDetails, oneof: "details" },
    { no: 4, name: "blob_integration_rule_details", kind: "message", T: BlobDistributionRuleDetails, oneof: "details" },
  ],
);

/**
 * Distribution rules are conjunctive (AND) when applied at the producer.
 * This implies that given a primitive datum, if the datum satisfies a
 * producer rule AND a consumer rule, it will be broadcast to the network.
 *
 * @generated from message anduril.communicationsmanager.v1.DistributionRule
 */
const DistributionRule = proto3.makeMessageType(
  "anduril.communicationsmanager.v1.DistributionRule",
  () => [
    { no: 1, name: "rule_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "source", kind: "message", T: Source },
    { no: 8, name: "sources", kind: "message", T: Source, repeated: true },
    { no: 5, name: "destination", kind: "message", T: Destination },
    { no: 6, name: "entity_details", kind: "message", T: EntityDistributionRuleDetails, oneof: "details" },
    { no: 13, name: "blob_details", kind: "message", T: BlobDistributionRuleDetails, oneof: "details" },
    { no: 7, name: "priority", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 9, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "version_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 12, name: "source_destination_directional_control", kind: "message", T: SourceDestinationDirectionalControl },
  ],
);

/**
 * @generated from message anduril.communicationsmanager.v1.SourceDestinationDirectionalControl
 */
const SourceDestinationDirectionalControl = proto3.makeMessageType(
  "anduril.communicationsmanager.v1.SourceDestinationDirectionalControl",
  () => [
    { no: 1, name: "inbound_rule_source_destination", kind: "message", T: InboundRuleSourceDestination, oneof: "source_destination" },
    { no: 2, name: "outbound_rule_source_destination", kind: "message", T: OutboundRuleSourceDestination, oneof: "source_destination" },
  ],
);

/**
 * Many destinations to one source. The source will block data from being sent to the destinations when matched by
 * a filter statement. Rule is owned by the source.
 *
 * @generated from message anduril.communicationsmanager.v1.OutboundRuleSourceDestination
 */
const OutboundRuleSourceDestination = proto3.makeMessageType(
  "anduril.communicationsmanager.v1.OutboundRuleSourceDestination",
  () => [
    { no: 1, name: "source", kind: "message", T: Source },
    { no: 2, name: "destinations", kind: "message", T: Destination, repeated: true },
  ],
);

/**
 * Many sources to one Destination. The destination will request data from the sources
 * when matched by a filter statement. Rule is owned by the destination.
 *
 * @generated from message anduril.communicationsmanager.v1.InboundRuleSourceDestination
 */
const InboundRuleSourceDestination = proto3.makeMessageType(
  "anduril.communicationsmanager.v1.InboundRuleSourceDestination",
  () => [
    { no: 1, name: "sources", kind: "message", T: Source, repeated: true },
    { no: 2, name: "destination", kind: "message", T: Destination },
  ],
);

/**
 * A source from which primitive data are routed.
 *
 * @generated from message anduril.communicationsmanager.v1.Source
 */
const Source = proto3.makeMessageType(
  "anduril.communicationsmanager.v1.Source",
  () => [
    { no: 1, name: "asset_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "source" },
    { no: 2, name: "all", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "source" },
    { no: 3, name: "host_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "source" },
  ],
);

/**
 * A destination to which data are routed.
 *
 * @generated from message anduril.communicationsmanager.v1.Destination
 */
const Destination = proto3.makeMessageType(
  "anduril.communicationsmanager.v1.Destination",
  () => [
    { no: 1, name: "asset_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "destination" },
    { no: 2, name: "host_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "destination" },
    { no: 3, name: "all", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "destination" },
  ],
);

/**
 * Message to contain additional business logic for entities. Entity_Filter and Dynamic Statement are ANDed together
 * when both are present.
 *
 * @generated from message anduril.communicationsmanager.v1.EntityDistributionRuleDetails
 */
const EntityDistributionRuleDetails = proto3.makeMessageType(
  "anduril.communicationsmanager.v1.EntityDistributionRuleDetails",
  () => [
    { no: 1, name: "entity_filter", kind: "message", T: Statement },
    { no: 2, name: "static_statement", kind: "message", T: Statement, oneof: "entity_filter_selection" },
    { no: 3, name: "dynamic_statement", kind: "message", T: DynamicStatement, oneof: "entity_filter_selection" },
  ],
);

/**
 * @generated from message anduril.communicationsmanager.v1.BlobDistributionRuleDetails
 */
const BlobDistributionRuleDetails = proto3.makeMessageType(
  "anduril.communicationsmanager.v1.BlobDistributionRuleDetails",
  () => [
    { no: 1, name: "blob_filter", kind: "message", T: Statement$1 },
    { no: 2, name: "blob_filters", kind: "message", T: Statement$1, repeated: true },
  ],
);

/**
 * CommunicationsManagerError message contents.
 *
 * @generated from message anduril.communicationsmanager.v1.CommunicationsManagerError
 */
const CommunicationsManagerError = proto3.makeMessageType(
  "anduril.communicationsmanager.v1.CommunicationsManagerError",
  () => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * Rule to apply to Cross Domain, will function as an inbound filter which allows matching entities to pass through.
 *
 * @generated from message anduril.communicationsmanager.v1.CrossDomainRule
 */
const CrossDomainRule = proto3.makeMessageType(
  "anduril.communicationsmanager.v1.CrossDomainRule",
  () => [
    { no: 1, name: "entity_details", kind: "message", T: EntityDistributionRuleDetails, oneof: "details" },
    { no: 2, name: "cds_destination", kind: "message", T: CdsDestination },
  ],
);


exports.EventType = EventType;
exports.DistributionRuleEvent = DistributionRuleEvent;
exports.RuleEvent = RuleEvent;
exports.Rule = Rule;
exports.IntegrationRule = IntegrationRule;
exports.DistributionRule = DistributionRule;
exports.SourceDestinationDirectionalControl = SourceDestinationDirectionalControl;
exports.OutboundRuleSourceDestination = OutboundRuleSourceDestination;
exports.InboundRuleSourceDestination = InboundRuleSourceDestination;
exports.Source = Source;
exports.Destination = Destination;
exports.EntityDistributionRuleDetails = EntityDistributionRuleDetails;
exports.BlobDistributionRuleDetails = BlobDistributionRuleDetails;
exports.CommunicationsManagerError = CommunicationsManagerError;
exports.CrossDomainRule = CrossDomainRule;
