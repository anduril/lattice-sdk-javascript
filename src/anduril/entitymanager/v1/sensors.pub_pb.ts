// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/entitymanager/v1/sensors.pub.proto (package anduril.entitymanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { DoubleValue, FloatValue, Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Pose, Position } from "./location.pub_pb.js";
import { FloatRange } from "./types.pub_pb.js";
import { FrequencyRange } from "./signal.pub_pb.js";

/**
 * Describes the current operational state of a system.
 *
 * @generated from enum anduril.entitymanager.v1.OperationalState
 */
export enum OperationalState {
  /**
   * @generated from enum value: OPERATIONAL_STATE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * sensor exists but is deliberately turned off
   *
   * @generated from enum value: OPERATIONAL_STATE_OFF = 1;
   */
  OFF = 1,

  /**
   * sensor is not operational but some reason other than being "Off" (e.g., equipment malfunction)
   *
   * @generated from enum value: OPERATIONAL_STATE_NON_OPERATIONAL = 2;
   */
  NON_OPERATIONAL = 2,

  /**
   * sensor is receiving information but in some reduced status (e.g., off calibration)
   *
   * @generated from enum value: OPERATIONAL_STATE_DEGRADED = 3;
   */
  DEGRADED = 3,

  /**
   * fully functional
   *
   * @generated from enum value: OPERATIONAL_STATE_OPERATIONAL = 4;
   */
  OPERATIONAL = 4,

  /**
   * sensor is being actively denied
   *
   * @generated from enum value: OPERATIONAL_STATE_DENIED = 5;
   */
  DENIED = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(OperationalState)
proto3.util.setEnumType(OperationalState, "anduril.entitymanager.v1.OperationalState", [
  { no: 0, name: "OPERATIONAL_STATE_INVALID" },
  { no: 1, name: "OPERATIONAL_STATE_OFF" },
  { no: 2, name: "OPERATIONAL_STATE_NON_OPERATIONAL" },
  { no: 3, name: "OPERATIONAL_STATE_DEGRADED" },
  { no: 4, name: "OPERATIONAL_STATE_OPERATIONAL" },
  { no: 5, name: "OPERATIONAL_STATE_DENIED" },
]);

/**
 * Enumerates the possible sensor modes which were active for this sensor field of view.
 *
 * @generated from enum anduril.entitymanager.v1.SensorMode
 */
export enum SensorMode {
  /**
   * @generated from enum value: SENSOR_MODE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: SENSOR_MODE_SEARCH = 1;
   */
  SEARCH = 1,

  /**
   * @generated from enum value: SENSOR_MODE_TRACK = 2;
   */
  TRACK = 2,

  /**
   * @generated from enum value: SENSOR_MODE_WEAPON_SUPPORT = 3;
   */
  WEAPON_SUPPORT = 3,

  /**
   * @generated from enum value: SENSOR_MODE_AUTO = 4;
   */
  AUTO = 4,

  /**
   * @generated from enum value: SENSOR_MODE_MUTE = 5;
   */
  MUTE = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(SensorMode)
proto3.util.setEnumType(SensorMode, "anduril.entitymanager.v1.SensorMode", [
  { no: 0, name: "SENSOR_MODE_INVALID" },
  { no: 1, name: "SENSOR_MODE_SEARCH" },
  { no: 2, name: "SENSOR_MODE_TRACK" },
  { no: 3, name: "SENSOR_MODE_WEAPON_SUPPORT" },
  { no: 4, name: "SENSOR_MODE_AUTO" },
  { no: 5, name: "SENSOR_MODE_MUTE" },
]);

/**
 * @generated from enum anduril.entitymanager.v1.SensorType
 */
export enum SensorType {
  /**
   * @generated from enum value: SENSOR_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: SENSOR_TYPE_RADAR = 1;
   */
  RADAR = 1,

  /**
   * @generated from enum value: SENSOR_TYPE_CAMERA = 2;
   */
  CAMERA = 2,

  /**
   * @generated from enum value: SENSOR_TYPE_TRANSPONDER = 3;
   */
  TRANSPONDER = 3,

  /**
   * @generated from enum value: SENSOR_TYPE_RF = 4;
   */
  RF = 4,

  /**
   * @generated from enum value: SENSOR_TYPE_GPS = 5;
   */
  GPS = 5,

  /**
   * @generated from enum value: SENSOR_TYPE_PTU_POS = 6;
   */
  PTU_POS = 6,

  /**
   * @generated from enum value: SENSOR_TYPE_WISP = 7;
   */
  WISP = 7,

  /**
   * @generated from enum value: SENSOR_TYPE_PERIMETER = 8;
   */
  PERIMETER = 8,

  /**
   * @generated from enum value: SENSOR_TYPE_SONAR = 9;
   */
  SONAR = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(SensorType)
proto3.util.setEnumType(SensorType, "anduril.entitymanager.v1.SensorType", [
  { no: 0, name: "SENSOR_TYPE_INVALID" },
  { no: 1, name: "SENSOR_TYPE_RADAR" },
  { no: 2, name: "SENSOR_TYPE_CAMERA" },
  { no: 3, name: "SENSOR_TYPE_TRANSPONDER" },
  { no: 4, name: "SENSOR_TYPE_RF" },
  { no: 5, name: "SENSOR_TYPE_GPS" },
  { no: 6, name: "SENSOR_TYPE_PTU_POS" },
  { no: 7, name: "SENSOR_TYPE_WISP" },
  { no: 8, name: "SENSOR_TYPE_PERIMETER" },
  { no: 9, name: "SENSOR_TYPE_SONAR" },
]);

/**
 * List of sensors available for an entity.
 *
 * @generated from message anduril.entitymanager.v1.Sensors
 */
export class Sensors extends Message<Sensors> {
  /**
   * @generated from field: repeated anduril.entitymanager.v1.Sensor sensors = 1;
   */
  sensors: Sensor[] = [];

  constructor(data?: PartialMessage<Sensors>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Sensors";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sensors", kind: "message", T: Sensor, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Sensors {
    return new Sensors().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Sensors {
    return new Sensors().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Sensors {
    return new Sensors().fromJsonString(jsonString, options);
  }

  static equals(a: Sensors | PlainMessage<Sensors> | undefined, b: Sensors | PlainMessage<Sensors> | undefined): boolean {
    return proto3.util.equals(Sensors, a, b);
  }
}

/**
 * Individual sensor configuration.
 *
 * @generated from message anduril.entitymanager.v1.Sensor
 */
export class Sensor extends Message<Sensor> {
  /**
   * This generally is used to indicate a specific type at a more detailed granularity. E.g. COMInt, LWIR or Echodyne
   *
   * @generated from field: string sensor_id = 1;
   */
  sensorId = "";

  /**
   * @generated from field: anduril.entitymanager.v1.OperationalState operational_state = 3;
   */
  operationalState = OperationalState.INVALID;

  /**
   * DEPRECATED -- use `fields_of_view` instead. This field will be marked deprecated and no longer populated by 11/26/2023.
   *
   * @generated from field: anduril.entitymanager.v1.FieldOfView field_of_view = 4;
   */
  fieldOfView?: FieldOfView;

  /**
   * The type of sensor
   *
   * @generated from field: anduril.entitymanager.v1.SensorType sensor_type = 5;
   */
  sensorType = SensorType.INVALID;

  /**
   * A human readable description of the sensor
   *
   * @generated from field: string sensor_description = 6;
   */
  sensorDescription = "";

  /**
   * RF configuration details of the sensor
   *
   * @generated from field: anduril.entitymanager.v1.RFConfiguration rf_configuraton = 7;
   */
  rfConfiguraton?: RFConfiguration;

  /**
   * Time of the latest detection from the sensor
   *
   * @generated from field: google.protobuf.Timestamp last_detection_timestamp = 8;
   */
  lastDetectionTimestamp?: Timestamp;

  /**
   * Multiple fields of view for a single sensor component
   *
   * @generated from field: repeated anduril.entitymanager.v1.FieldOfView fields_of_view = 9;
   */
  fieldsOfView: FieldOfView[] = [];

  constructor(data?: PartialMessage<Sensor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Sensor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sensor_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "operational_state", kind: "enum", T: proto3.getEnumType(OperationalState) },
    { no: 4, name: "field_of_view", kind: "message", T: FieldOfView },
    { no: 5, name: "sensor_type", kind: "enum", T: proto3.getEnumType(SensorType) },
    { no: 6, name: "sensor_description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "rf_configuraton", kind: "message", T: RFConfiguration },
    { no: 8, name: "last_detection_timestamp", kind: "message", T: Timestamp },
    { no: 9, name: "fields_of_view", kind: "message", T: FieldOfView, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Sensor {
    return new Sensor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Sensor {
    return new Sensor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Sensor {
    return new Sensor().fromJsonString(jsonString, options);
  }

  static equals(a: Sensor | PlainMessage<Sensor> | undefined, b: Sensor | PlainMessage<Sensor> | undefined): boolean {
    return proto3.util.equals(Sensor, a, b);
  }
}

/**
 * Sensor Field Of View closely resembling fov.proto SensorFieldOfView.
 *
 * @generated from message anduril.entitymanager.v1.FieldOfView
 */
export class FieldOfView extends Message<FieldOfView> {
  /**
   * The Id for one instance of a FieldOfView, persisted across multiple updates to provide continuity during
   * smoothing. This is relevant for sensors like an ESM or Radar where the dwell schedule is on the order of
   * milliseconds, making multiple FOVs a requirement for proper display of search and weapon support beams.
   *
   * @generated from field: int32 fov_id = 1;
   */
  fovId = 0;

  /**
   * The Id of the mount the sensor is on.
   *
   * @generated from field: string mount_id = 2;
   */
  mountId = "";

  /**
   * The field of view the sensor projected onto the ground.
   *
   * @generated from field: anduril.entitymanager.v1.ProjectedFrustum projected_frustum = 3;
   */
  projectedFrustum?: ProjectedFrustum;

  /**
   * Center ray of the frustum projected onto the ground.
   *
   * @generated from field: anduril.entitymanager.v1.Position projected_center_ray = 4;
   */
  projectedCenterRay?: Position;

  /**
   * The origin and direction of the center ray for this sensor relative to the ENU frame. A ray which is aligned with
   * the positive X axis in the sensor frame will be transformed into the ray along the sensor direction in the ENU
   * frame when transformed by the quaternion contained in this pose.
   *
   * @generated from field: anduril.entitymanager.v1.Pose center_ray_pose = 5;
   */
  centerRayPose?: Pose;

  /**
   * Horizontal field of view in radians.
   *
   * @generated from field: float horizontal_fov = 6;
   */
  horizontalFov = 0;

  /**
   * Vertical field of view in radians.
   *
   * @generated from field: float vertical_fov = 7;
   */
  verticalFov = 0;

  /**
   * Sensor range in meters.
   *
   * @generated from field: google.protobuf.FloatValue range = 8;
   */
  range?: number;

  /**
   * The mode that this sensor is currently in, used to display for context in the UI. Some sensors can emit multiple
   * sensor field of views with different modes, for example a radar can simultaneously search broadly and perform
   * tighter bounded tracking.
   *
   * @generated from field: anduril.entitymanager.v1.SensorMode mode = 9;
   */
  mode = SensorMode.INVALID;

  constructor(data?: PartialMessage<FieldOfView>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.FieldOfView";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fov_id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "mount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "projected_frustum", kind: "message", T: ProjectedFrustum },
    { no: 4, name: "projected_center_ray", kind: "message", T: Position },
    { no: 5, name: "center_ray_pose", kind: "message", T: Pose },
    { no: 6, name: "horizontal_fov", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 7, name: "vertical_fov", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 8, name: "range", kind: "message", T: FloatValue },
    { no: 9, name: "mode", kind: "enum", T: proto3.getEnumType(SensorMode) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldOfView {
    return new FieldOfView().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldOfView {
    return new FieldOfView().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldOfView {
    return new FieldOfView().fromJsonString(jsonString, options);
  }

  static equals(a: FieldOfView | PlainMessage<FieldOfView> | undefined, b: FieldOfView | PlainMessage<FieldOfView> | undefined): boolean {
    return proto3.util.equals(FieldOfView, a, b);
  }
}

/**
 * Represents a frustum in which which all four corner points project onto the ground. All points in this message
 * are optional, if the projection to the ground fails then they will not be populated.
 *
 * @generated from message anduril.entitymanager.v1.ProjectedFrustum
 */
export class ProjectedFrustum extends Message<ProjectedFrustum> {
  /**
   * Upper left point of the frustum.
   *
   * @generated from field: anduril.entitymanager.v1.Position upper_left = 1;
   */
  upperLeft?: Position;

  /**
   * Upper right point of the frustum.
   *
   * @generated from field: anduril.entitymanager.v1.Position upper_right = 2;
   */
  upperRight?: Position;

  /**
   * Bottom right point of the frustum.
   *
   * @generated from field: anduril.entitymanager.v1.Position bottom_right = 3;
   */
  bottomRight?: Position;

  /**
   * Bottom left point of the frustum.
   *
   * @generated from field: anduril.entitymanager.v1.Position bottom_left = 4;
   */
  bottomLeft?: Position;

  constructor(data?: PartialMessage<ProjectedFrustum>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.ProjectedFrustum";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "upper_left", kind: "message", T: Position },
    { no: 2, name: "upper_right", kind: "message", T: Position },
    { no: 3, name: "bottom_right", kind: "message", T: Position },
    { no: 4, name: "bottom_left", kind: "message", T: Position },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectedFrustum {
    return new ProjectedFrustum().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectedFrustum {
    return new ProjectedFrustum().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectedFrustum {
    return new ProjectedFrustum().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectedFrustum | PlainMessage<ProjectedFrustum> | undefined, b: ProjectedFrustum | PlainMessage<ProjectedFrustum> | undefined): boolean {
    return proto3.util.equals(ProjectedFrustum, a, b);
  }
}

/**
 * Represents RF configurations supported on this sensor.
 *
 * @generated from message anduril.entitymanager.v1.RFConfiguration
 */
export class RFConfiguration extends Message<RFConfiguration> {
  /**
   * Frequency ranges that are available for this sensor.
   *
   * @generated from field: repeated anduril.entitymanager.v1.FloatRange frequency_range = 1 [deprecated = true];
   * @deprecated
   */
  frequencyRange: FloatRange[] = [];

  /**
   * Bandwidth ranges that are available for this sensor.
   *
   * @generated from field: repeated anduril.entitymanager.v1.FloatRange bandwidth_range = 2 [deprecated = true];
   * @deprecated
   */
  bandwidthRange: FloatRange[] = [];

  /**
   * Frequency ranges that are available for this sensor.
   *
   * @generated from field: repeated anduril.entitymanager.v1.FrequencyRange frequency_range_hz = 3;
   */
  frequencyRangeHz: FrequencyRange[] = [];

  /**
   * Bandwidth ranges that are available for this sensor.
   *
   * @generated from field: repeated anduril.entitymanager.v1.BandwidthRange bandwidth_range_hz = 4;
   */
  bandwidthRangeHz: BandwidthRange[] = [];

  constructor(data?: PartialMessage<RFConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.RFConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "frequency_range", kind: "message", T: FloatRange, repeated: true },
    { no: 2, name: "bandwidth_range", kind: "message", T: FloatRange, repeated: true },
    { no: 3, name: "frequency_range_hz", kind: "message", T: FrequencyRange, repeated: true },
    { no: 4, name: "bandwidth_range_hz", kind: "message", T: BandwidthRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RFConfiguration {
    return new RFConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RFConfiguration {
    return new RFConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RFConfiguration {
    return new RFConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: RFConfiguration | PlainMessage<RFConfiguration> | undefined, b: RFConfiguration | PlainMessage<RFConfiguration> | undefined): boolean {
    return proto3.util.equals(RFConfiguration, a, b);
  }
}

/**
 * A component that describes the min and max bandwidths of a sensor
 *
 * @generated from message anduril.entitymanager.v1.BandwidthRange
 */
export class BandwidthRange extends Message<BandwidthRange> {
  /**
   * @generated from field: anduril.entitymanager.v1.Bandwidth minimum_bandwidth = 1;
   */
  minimumBandwidth?: Bandwidth;

  /**
   * @generated from field: anduril.entitymanager.v1.Bandwidth maximum_bandwidth = 2;
   */
  maximumBandwidth?: Bandwidth;

  constructor(data?: PartialMessage<BandwidthRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.BandwidthRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "minimum_bandwidth", kind: "message", T: Bandwidth },
    { no: 2, name: "maximum_bandwidth", kind: "message", T: Bandwidth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BandwidthRange {
    return new BandwidthRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BandwidthRange {
    return new BandwidthRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BandwidthRange {
    return new BandwidthRange().fromJsonString(jsonString, options);
  }

  static equals(a: BandwidthRange | PlainMessage<BandwidthRange> | undefined, b: BandwidthRange | PlainMessage<BandwidthRange> | undefined): boolean {
    return proto3.util.equals(BandwidthRange, a, b);
  }
}

/**
 * Describes the bandwidth of a signal
 *
 * @generated from message anduril.entitymanager.v1.Bandwidth
 */
export class Bandwidth extends Message<Bandwidth> {
  /**
   * @generated from field: google.protobuf.DoubleValue bandwidth_hz = 1;
   */
  bandwidthHz?: number;

  constructor(data?: PartialMessage<Bandwidth>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Bandwidth";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bandwidth_hz", kind: "message", T: DoubleValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Bandwidth {
    return new Bandwidth().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Bandwidth {
    return new Bandwidth().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Bandwidth {
    return new Bandwidth().fromJsonString(jsonString, options);
  }

  static equals(a: Bandwidth | PlainMessage<Bandwidth> | undefined, b: Bandwidth | PlainMessage<Bandwidth> | undefined): boolean {
    return proto3.util.equals(Bandwidth, a, b);
  }
}

