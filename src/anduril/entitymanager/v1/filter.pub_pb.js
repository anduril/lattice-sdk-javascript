// @generated by protoc-gen-es v1.7.2
// @generated from file anduril/entitymanager/v1/filter.pub.proto (package anduril.entitymanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { proto3, Timestamp } from "@bufbuild/protobuf";
import { Position } from "./location.pub_pb.js";
import { GeoPolygon } from "./geoentity.pub_pb.js";

/**
 * The Comparator specifies the set of supported comparison operations. It also provides the
 * mapping information about which comparators are supported for which values. Services that wish
 * to implement entity filters must provide validation functionality to strictly enforce these
 * mappings.
 *
 * @generated from enum anduril.entitymanager.v1.Comparator
 */
export const Comparator = proto3.makeEnum(
  "anduril.entitymanager.v1.Comparator",
  [
    {no: 0, name: "COMPARATOR_INVALID", localName: "INVALID"},
    {no: 11, name: "COMPARATOR_MATCH_ALL", localName: "MATCH_ALL"},
    {no: 1, name: "COMPARATOR_EQUALITY", localName: "EQUALITY"},
    {no: 9, name: "COMPARATOR_IN", localName: "IN"},
    {no: 2, name: "COMPARATOR_LESS_THAN", localName: "LESS_THAN"},
    {no: 3, name: "COMPARATOR_GREATER_THAN", localName: "GREATER_THAN"},
    {no: 4, name: "COMPARATOR_LESS_THAN_EQUAL_TO", localName: "LESS_THAN_EQUAL_TO"},
    {no: 5, name: "COMPARATOR_GREATER_THAN_EQUAL_TO", localName: "GREATER_THAN_EQUAL_TO"},
    {no: 6, name: "COMPARATOR_WITHIN", localName: "WITHIN"},
    {no: 7, name: "COMPARATOR_EXISTS", localName: "EXISTS"},
    {no: 8, name: "COMPARATOR_CASE_INSENSITIVE_EQUALITY", localName: "CASE_INSENSITIVE_EQUALITY"},
    {no: 10, name: "COMPARATOR_CASE_INSENSITIVE_EQUALITY_IN", localName: "CASE_INSENSITIVE_EQUALITY_IN"},
    {no: 12, name: "COMPARATOR_RANGE_CLOSED", localName: "RANGE_CLOSED"},
  ],
);

/**
 * The ListComparator determines how to compose statement evaluations for members of a list. For
 * example, if ANY_OF is specified, the ListOperation in which the ListComparator is embedded
 * will return TRUE if any of the values in the list returns true for the ListOperation's child
 * statement.
 *
 * @generated from enum anduril.entitymanager.v1.ListComparator
 */
export const ListComparator = proto3.makeEnum(
  "anduril.entitymanager.v1.ListComparator",
  [
    {no: 0, name: "LIST_COMPARATOR_INVALID", localName: "INVALID"},
    {no: 1, name: "LIST_COMPARATOR_ANY_OF", localName: "ANY_OF"},
  ],
);

/**
 * A Statement is the building block of the entity filter. The outermost statement is conceptually
 * the root node of an "expression tree" which allows for the construction of complete boolean
 * logic statements. Statements are formed by grouping sets of children statement(s) or predicate(s)
 * according to the boolean operation which is to be applied.
 *
 * For example, the criteria "take an action if an entity is hostile and an air vehicle" can be
 * represented as: Statement1: { AndOperation: { Predicate1, Predicate2 } }. Where Statement1
 * is the root of the expression tree, with an AND operation that is applied to children
 * predicates. The predicates themselves encode "entity is hostile" and "entity is air vehicle."
 *
 * @generated from message anduril.entitymanager.v1.Statement
 */
export const Statement = proto3.makeMessageType(
  "anduril.entitymanager.v1.Statement",
  () => [
    { no: 1, name: "and", kind: "message", T: AndOperation, oneof: "operation" },
    { no: 2, name: "or", kind: "message", T: OrOperation, oneof: "operation" },
    { no: 3, name: "not", kind: "message", T: NotOperation, oneof: "operation" },
    { no: 4, name: "list", kind: "message", T: ListOperation, oneof: "operation" },
    { no: 5, name: "predicate", kind: "message", T: Predicate, oneof: "operation" },
  ],
);

/**
 * The AndOperation represents the boolean AND operation, which is to be applied to the list of
 * children statement(s) or predicate(s).
 *
 * @generated from message anduril.entitymanager.v1.AndOperation
 */
export const AndOperation = proto3.makeMessageType(
  "anduril.entitymanager.v1.AndOperation",
  () => [
    { no: 1, name: "predicate_set", kind: "message", T: PredicateSet, oneof: "children" },
    { no: 2, name: "statement_set", kind: "message", T: StatementSet, oneof: "children" },
  ],
);

/**
 * The OrOperation represents the boolean OR operation, which is to be applied to the list of
 * children statement(s) or predicate(s).
 *
 * @generated from message anduril.entitymanager.v1.OrOperation
 */
export const OrOperation = proto3.makeMessageType(
  "anduril.entitymanager.v1.OrOperation",
  () => [
    { no: 1, name: "predicate_set", kind: "message", T: PredicateSet, oneof: "children" },
    { no: 2, name: "statement_set", kind: "message", T: StatementSet, oneof: "children" },
  ],
);

/**
 * The NotOperation represents the boolean NOT operation, which can only be applied to a single
 * child predicate or statement.
 *
 * @generated from message anduril.entitymanager.v1.NotOperation
 */
export const NotOperation = proto3.makeMessageType(
  "anduril.entitymanager.v1.NotOperation",
  () => [
    { no: 1, name: "predicate", kind: "message", T: Predicate, oneof: "child" },
    { no: 2, name: "statement", kind: "message", T: Statement, oneof: "child" },
  ],
);

/**
 * The ListOperation represents an operation against a proto list. If the list is of primitive proto
 * type (e.g. int32), paths in all child predicates should be left empty. If the list is of message
 * proto type (e.g. Sensor), paths in all child predicates should be relative to the list path.
 *
 * For example, the criteria "take an action if an entity has any sensor with sensor_id='sensor' and
 * OperationalState=STATE_OFF" would be modeled as:
 * Predicate1: { path: "sensor_id", comparator: EQUAL_TO, value: "sensor" }
 * Predicate2: { path: "operational_state", comparator: EQUAL_TO, value: STATE_OFF }
 *
 * Statement2: { AndOperation: PredicateSet: { <Predicate1>, <Predicate2> } }
 * ListOperation: { list_path: "sensors.sensors", list_comparator: ANY, statement: <Statement2> }
 * Statement1: { ListOperation: <ListOperation> }
 *
 * Note that in the above, the child predicates of the list operation have paths relative to the
 * list_path because the list is comprised of message not primitive types.
 *
 * @generated from message anduril.entitymanager.v1.ListOperation
 */
export const ListOperation = proto3.makeMessageType(
  "anduril.entitymanager.v1.ListOperation",
  () => [
    { no: 1, name: "list_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "list_comparator", kind: "enum", T: proto3.getEnumType(ListComparator) },
    { no: 3, name: "statement", kind: "message", T: Statement },
  ],
);

/**
 * The PredicateSet represents a list of predicates or "leaf nodes" in the expression tree, which
 * can be directly evaluated to a boolean TRUE/FALSE result.
 *
 * @generated from message anduril.entitymanager.v1.PredicateSet
 */
export const PredicateSet = proto3.makeMessageType(
  "anduril.entitymanager.v1.PredicateSet",
  () => [
    { no: 1, name: "predicates", kind: "message", T: Predicate, repeated: true },
  ],
);

/**
 * The StatementSet represents a list of statements or "tree nodes," each of which follow the same
 * behavior as the Statement proto message.
 *
 * @generated from message anduril.entitymanager.v1.StatementSet
 */
export const StatementSet = proto3.makeMessageType(
  "anduril.entitymanager.v1.StatementSet",
  () => [
    { no: 1, name: "statements", kind: "message", T: Statement, repeated: true },
  ],
);

/**
 * The Predicate fully encodes the information required to make an evaluation of an entity field
 * against a given static value, resulting in a boolean TRUE/FALSE result. The structure of a
 * predicate will always follow: "{entity-value} {comparator} {fixed-value}" where the entity value
 * is determined by the field path.
 *
 * For example, a predicate would read as: "{entity.location.velocity_enu} {LESS_THAN} {500kph}"
 *
 * @generated from message anduril.entitymanager.v1.Predicate
 */
export const Predicate = proto3.makeMessageType(
  "anduril.entitymanager.v1.Predicate",
  () => [
    { no: 1, name: "field_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: Value },
    { no: 3, name: "comparator", kind: "enum", T: proto3.getEnumType(Comparator) },
  ],
);

/**
 * The Value represents the information against which an entity field is evaluated. It is one of
 * a fixed set of types, each of which correspond to specific comparators. See "ComparatorType"
 * for the full list of Value <-> Comparator mappings.
 *
 * @generated from message anduril.entitymanager.v1.Value
 */
export const Value = proto3.makeMessageType(
  "anduril.entitymanager.v1.Value",
  () => [
    { no: 1, name: "boolean_type", kind: "message", T: BooleanType, oneof: "type" },
    { no: 2, name: "numeric_type", kind: "message", T: NumericType, oneof: "type" },
    { no: 3, name: "string_type", kind: "message", T: StringType, oneof: "type" },
    { no: 4, name: "enum_type", kind: "message", T: EnumType, oneof: "type" },
    { no: 5, name: "timestamp_type", kind: "message", T: TimestampType, oneof: "type" },
    { no: 6, name: "bounded_shape_type", kind: "message", T: BoundedShapeType, oneof: "type" },
    { no: 7, name: "position_type", kind: "message", T: PositionType, oneof: "type" },
    { no: 8, name: "heading_type", kind: "message", T: HeadingType, oneof: "type" },
    { no: 9, name: "list_type", kind: "message", T: ListType, oneof: "type" },
    { no: 10, name: "range_type", kind: "message", T: RangeType, oneof: "type" },
  ],
);

/**
 * The BooleanType represents a static boolean value.
 *
 * @generated from message anduril.entitymanager.v1.BooleanType
 */
export const BooleanType = proto3.makeMessageType(
  "anduril.entitymanager.v1.BooleanType",
  () => [
    { no: 1, name: "value", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * The NumericType represents static numeric values. It supports all numeric primitives supported
 * by the proto3 language specification.
 *
 * @generated from message anduril.entitymanager.v1.NumericType
 */
export const NumericType = proto3.makeMessageType(
  "anduril.entitymanager.v1.NumericType",
  () => [
    { no: 1, name: "double_value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "value" },
    { no: 2, name: "float_value", kind: "scalar", T: 2 /* ScalarType.FLOAT */, oneof: "value" },
    { no: 3, name: "int32_value", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "value" },
    { no: 4, name: "int64_value", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "value" },
    { no: 5, name: "uint32_value", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "value" },
    { no: 6, name: "uint64_value", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "value" },
  ],
);

/**
 * The StringType represents static string values.
 *
 * @generated from message anduril.entitymanager.v1.StringType
 */
export const StringType = proto3.makeMessageType(
  "anduril.entitymanager.v1.StringType",
  () => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * The EnumType represents members of well-known anduril ontologies, such as "disposition." When
 * such a value is specified, the evaluation library expects the integer representation of the enum
 * value. For example, a disposition derived from ontology.v1 such as "DISPOSITION_HOSTILE" should be
 * represented with the integer value 2.
 *
 * @generated from message anduril.entitymanager.v1.EnumType
 */
export const EnumType = proto3.makeMessageType(
  "anduril.entitymanager.v1.EnumType",
  () => [
    { no: 1, name: "value", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ],
);

/**
 * A List of Values for use with the IN comparator.
 *
 * @generated from message anduril.entitymanager.v1.ListType
 */
export const ListType = proto3.makeMessageType(
  "anduril.entitymanager.v1.ListType",
  () => [
    { no: 1, name: "values", kind: "message", T: Value, repeated: true },
  ],
);

/**
 * The TimestampType represents a static timestamp value.
 *
 * @generated from message anduril.entitymanager.v1.TimestampType
 */
export const TimestampType = proto3.makeMessageType(
  "anduril.entitymanager.v1.TimestampType",
  () => [
    { no: 1, name: "value", kind: "message", T: Timestamp },
  ],
);

/**
 * The PositionType represents any fixed LLA point in space.
 *
 * @generated from message anduril.entitymanager.v1.PositionType
 */
export const PositionType = proto3.makeMessageType(
  "anduril.entitymanager.v1.PositionType",
  () => [
    { no: 1, name: "value", kind: "message", T: Position },
  ],
);

/**
 * The BoundedShapeType represents any static fully-enclosed shape.
 *
 * @generated from message anduril.entitymanager.v1.BoundedShapeType
 */
export const BoundedShapeType = proto3.makeMessageType(
  "anduril.entitymanager.v1.BoundedShapeType",
  () => [
    { no: 1, name: "polygon_value", kind: "message", T: GeoPolygon, oneof: "value" },
  ],
);

/**
 * The HeadingType represents the heading in degrees for an entity's
 * attitudeEnu quaternion to be compared against. Defaults between a range of 0 to 360
 *
 * @generated from message anduril.entitymanager.v1.HeadingType
 */
export const HeadingType = proto3.makeMessageType(
  "anduril.entitymanager.v1.HeadingType",
  () => [
    { no: 1, name: "value", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ],
);

/**
 * The RangeType represents a numeric range.
 * Whether endpoints are included are based on the comparator used.
 * Both endpoints must be of the same numeric type.
 *
 * @generated from message anduril.entitymanager.v1.RangeType
 */
export const RangeType = proto3.makeMessageType(
  "anduril.entitymanager.v1.RangeType",
  () => [
    { no: 1, name: "start", kind: "message", T: NumericType },
    { no: 2, name: "end", kind: "message", T: NumericType },
  ],
);

