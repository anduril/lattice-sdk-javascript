// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/entitymanager/v1/relationship.pub.proto (package anduril.entitymanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Sensors } from "./sensors.pub_pb.js";

/**
 * The relationships between this entity and other entities in the battlespace.
 *
 * @generated from message anduril.entitymanager.v1.Relationships
 */
export class Relationships extends Message<Relationships> {
  /**
   * @generated from field: repeated anduril.entitymanager.v1.Relationship relationships = 1;
   */
  relationships: Relationship[] = [];

  constructor(data?: PartialMessage<Relationships>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Relationships";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relationships", kind: "message", T: Relationship, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Relationships {
    return new Relationships().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Relationships {
    return new Relationships().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Relationships {
    return new Relationships().fromJsonString(jsonString, options);
  }

  static equals(a: Relationships | PlainMessage<Relationships> | undefined, b: Relationships | PlainMessage<Relationships> | undefined): boolean {
    return proto3.util.equals(Relationships, a, b);
  }
}

/**
 * The relationship component indicates a relationship to another entity.
 *
 * @generated from message anduril.entitymanager.v1.Relationship
 */
export class Relationship extends Message<Relationship> {
  /**
   * The entity ID to which this entity is related.
   *
   * @generated from field: string related_entity_id = 1;
   */
  relatedEntityId = "";

  /**
   * A unique identifier for this relationship. Allows removing or updating relationships.
   *
   * @generated from field: string relationship_id = 2;
   */
  relationshipId = "";

  /**
   * The relationship type
   *
   * @generated from field: anduril.entitymanager.v1.RelationshipType relationship_type = 3;
   */
  relationshipType?: RelationshipType;

  constructor(data?: PartialMessage<Relationship>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Relationship";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "related_entity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "relationship_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "relationship_type", kind: "message", T: RelationshipType },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Relationship {
    return new Relationship().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Relationship {
    return new Relationship().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Relationship {
    return new Relationship().fromJsonString(jsonString, options);
  }

  static equals(a: Relationship | PlainMessage<Relationship> | undefined, b: Relationship | PlainMessage<Relationship> | undefined): boolean {
    return proto3.util.equals(Relationship, a, b);
  }
}

/**
 * Determines the type of relationship between this entity and another.
 *
 * @generated from message anduril.entitymanager.v1.RelationshipType
 */
export class RelationshipType extends Message<RelationshipType> {
  /**
   * @generated from oneof anduril.entitymanager.v1.RelationshipType.type
   */
  type: {
    /**
     * @generated from field: anduril.entitymanager.v1.Tether tether = 1;
     */
    value: Tether;
    case: "tether";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.TrackedBy tracked_by = 2;
     */
    value: TrackedBy;
    case: "trackedBy";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.Configure configure = 3;
     */
    value: Configure;
    case: "configure";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.GroupChild group_child = 4;
     */
    value: GroupChild;
    case: "groupChild";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.GroupParent group_parent = 5;
     */
    value: GroupParent;
    case: "groupParent";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.MergedFrom merged_from = 6;
     */
    value: MergedFrom;
    case: "mergedFrom";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RelationshipType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.RelationshipType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tether", kind: "message", T: Tether, oneof: "type" },
    { no: 2, name: "tracked_by", kind: "message", T: TrackedBy, oneof: "type" },
    { no: 3, name: "configure", kind: "message", T: Configure, oneof: "type" },
    { no: 4, name: "group_child", kind: "message", T: GroupChild, oneof: "type" },
    { no: 5, name: "group_parent", kind: "message", T: GroupParent, oneof: "type" },
    { no: 6, name: "merged_from", kind: "message", T: MergedFrom, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RelationshipType {
    return new RelationshipType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RelationshipType {
    return new RelationshipType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RelationshipType {
    return new RelationshipType().fromJsonString(jsonString, options);
  }

  static equals(a: RelationshipType | PlainMessage<RelationshipType> | undefined, b: RelationshipType | PlainMessage<RelationshipType> | undefined): boolean {
    return proto3.util.equals(RelationshipType, a, b);
  }
}

/**
 * A tether relationship indicates that this entity should take the position of the other entity.
 *
 * @generated from message anduril.entitymanager.v1.Tether
 */
export class Tether extends Message<Tether> {
  constructor(data?: PartialMessage<Tether>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Tether";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Tether {
    return new Tether().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Tether {
    return new Tether().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Tether {
    return new Tether().fromJsonString(jsonString, options);
  }

  static equals(a: Tether | PlainMessage<Tether> | undefined, b: Tether | PlainMessage<Tether> | undefined): boolean {
    return proto3.util.equals(Tether, a, b);
  }
}

/**
 * Describes the relationship between the entity being tracked ("tracked entity") and the entity that is
 * performing the tracking ("tracking entity").
 *
 * @generated from message anduril.entitymanager.v1.TrackedBy
 */
export class TrackedBy extends Message<TrackedBy> {
  /**
   * Sensor details of the tracking entity's sensors that were active and tracking the tracked entity. This may be
   * a subset of the total sensors available on the tracking entity.
   *
   * @generated from field: anduril.entitymanager.v1.Sensors actively_tracking_sensors = 1;
   */
  activelyTrackingSensors?: Sensors;

  /**
   * Latest time that any sensor in actively_tracking_sensors detected the tracked entity.
   *
   * @generated from field: google.protobuf.Timestamp last_measurement_timestamp = 2;
   */
  lastMeasurementTimestamp?: Timestamp;

  constructor(data?: PartialMessage<TrackedBy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.TrackedBy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "actively_tracking_sensors", kind: "message", T: Sensors },
    { no: 2, name: "last_measurement_timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrackedBy {
    return new TrackedBy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrackedBy {
    return new TrackedBy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrackedBy {
    return new TrackedBy().fromJsonString(jsonString, options);
  }

  static equals(a: TrackedBy | PlainMessage<TrackedBy> | undefined, b: TrackedBy | PlainMessage<TrackedBy> | undefined): boolean {
    return proto3.util.equals(TrackedBy, a, b);
  }
}

/**
 * A configure relationship indicates that this entity is a configuration on other entity.
 *
 * @generated from message anduril.entitymanager.v1.Configure
 */
export class Configure extends Message<Configure> {
  constructor(data?: PartialMessage<Configure>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Configure";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Configure {
    return new Configure().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Configure {
    return new Configure().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Configure {
    return new Configure().fromJsonString(jsonString, options);
  }

  static equals(a: Configure | PlainMessage<Configure> | undefined, b: Configure | PlainMessage<Configure> | undefined): boolean {
    return proto3.util.equals(Configure, a, b);
  }
}

/**
 * A GroupChild relationship is a uni-directional relationship indicating that (1) this entity
 * represents an Entity Group and (2) the related entity is a child member of this group. The presence of this
 * relationship alone determines that the type of group is an Entity Group.
 *
 * @generated from message anduril.entitymanager.v1.GroupChild
 */
export class GroupChild extends Message<GroupChild> {
  constructor(data?: PartialMessage<GroupChild>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.GroupChild";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GroupChild {
    return new GroupChild().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GroupChild {
    return new GroupChild().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GroupChild {
    return new GroupChild().fromJsonString(jsonString, options);
  }

  static equals(a: GroupChild | PlainMessage<GroupChild> | undefined, b: GroupChild | PlainMessage<GroupChild> | undefined): boolean {
    return proto3.util.equals(GroupChild, a, b);
  }
}

/**
 * A GroupParent relationship is a uni-directional relationship indicating that this entity is a member of
 * the Entity Group represented by the related entity. The presence of this relationship alone determines that
 * the type of group that this entity is a member of is an Entity Group.
 *
 * @generated from message anduril.entitymanager.v1.GroupParent
 */
export class GroupParent extends Message<GroupParent> {
  constructor(data?: PartialMessage<GroupParent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.GroupParent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GroupParent {
    return new GroupParent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GroupParent {
    return new GroupParent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GroupParent {
    return new GroupParent().fromJsonString(jsonString, options);
  }

  static equals(a: GroupParent | PlainMessage<GroupParent> | undefined, b: GroupParent | PlainMessage<GroupParent> | undefined): boolean {
    return proto3.util.equals(GroupParent, a, b);
  }
}

/**
 * A MergedFrom relationship is a uni-directional relationship indicating that this entity is a merged entity whose
 * data has at least partially been merged from the related entity.
 *
 * @generated from message anduril.entitymanager.v1.MergedFrom
 */
export class MergedFrom extends Message<MergedFrom> {
  constructor(data?: PartialMessage<MergedFrom>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.MergedFrom";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MergedFrom {
    return new MergedFrom().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MergedFrom {
    return new MergedFrom().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MergedFrom {
    return new MergedFrom().fromJsonString(jsonString, options);
  }

  static equals(a: MergedFrom | PlainMessage<MergedFrom> | undefined, b: MergedFrom | PlainMessage<MergedFrom> | undefined): boolean {
    return proto3.util.equals(MergedFrom, a, b);
  }
}

