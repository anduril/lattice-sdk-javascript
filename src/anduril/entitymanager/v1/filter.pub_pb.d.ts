// @generated by protoc-gen-es v1.7.2
// @generated from file anduril/entitymanager/v1/filter.pub.proto (package anduril.entitymanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Position } from "./location.pub_pb.js";
import type { GeoPolygon } from "./geoentity.pub_pb.js";

/**
 * The Comparator specifies the set of supported comparison operations. It also provides the
 * mapping information about which comparators are supported for which values. Services that wish
 * to implement entity filters must provide validation functionality to strictly enforce these
 * mappings.
 *
 * @generated from enum anduril.entitymanager.v1.Comparator
 */
export declare enum Comparator {
  /**
   * @generated from enum value: COMPARATOR_INVALID = 0;
   */
  INVALID = 0,

  /**
   * Comparators for: boolean, numeric, string, enum, position, timestamp, positions, and bounded shapes.
   *
   * @generated from enum value: COMPARATOR_MATCH_ALL = 11;
   */
  MATCH_ALL = 11,

  /**
   * Comparators for: boolean, numeric, string, enum, position, and timestamp.
   *
   * @generated from enum value: COMPARATOR_EQUALITY = 1;
   */
  EQUALITY = 1,

  /**
   * @generated from enum value: COMPARATOR_IN = 9;
   */
  IN = 9,

  /**
   * Comparators for: numeric, string, and timestamp.
   *
   * @generated from enum value: COMPARATOR_LESS_THAN = 2;
   */
  LESS_THAN = 2,

  /**
   * @generated from enum value: COMPARATOR_GREATER_THAN = 3;
   */
  GREATER_THAN = 3,

  /**
   * @generated from enum value: COMPARATOR_LESS_THAN_EQUAL_TO = 4;
   */
  LESS_THAN_EQUAL_TO = 4,

  /**
   * @generated from enum value: COMPARATOR_GREATER_THAN_EQUAL_TO = 5;
   */
  GREATER_THAN_EQUAL_TO = 5,

  /**
   * Comparators for: positions and bounded shapes.
   *
   * @generated from enum value: COMPARATOR_WITHIN = 6;
   */
  WITHIN = 6,

  /**
   * Comparators for: existential checks.
   * TRUE if path to field exists (parent message is present), and either:
   *   1. the field is a primitive: all values including default pass check.
   *   2. the field is a message and set/present.
   *   3. the field is repeated or map with size > 0.
   * FALSE unless path exists and one of the above 3 conditions is met
   *
   * @generated from enum value: COMPARATOR_EXISTS = 7;
   */
  EXISTS = 7,

  /**
   * Comparator for string type only.
   *
   * @generated from enum value: COMPARATOR_CASE_INSENSITIVE_EQUALITY = 8;
   */
  CASE_INSENSITIVE_EQUALITY = 8,

  /**
   * @generated from enum value: COMPARATOR_CASE_INSENSITIVE_EQUALITY_IN = 10;
   */
  CASE_INSENSITIVE_EQUALITY_IN = 10,

  /**
   * Comparators for range types only.
   * Closed (inclusive endpoints) [a, b]
   *
   * @generated from enum value: COMPARATOR_RANGE_CLOSED = 12;
   */
  RANGE_CLOSED = 12,
}

/**
 * The ListComparator determines how to compose statement evaluations for members of a list. For
 * example, if ANY_OF is specified, the ListOperation in which the ListComparator is embedded
 * will return TRUE if any of the values in the list returns true for the ListOperation's child
 * statement.
 *
 * @generated from enum anduril.entitymanager.v1.ListComparator
 */
export declare enum ListComparator {
  /**
   * @generated from enum value: LIST_COMPARATOR_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: LIST_COMPARATOR_ANY_OF = 1;
   */
  ANY_OF = 1,
}

/**
 * A Statement is the building block of the entity filter. The outermost statement is conceptually
 * the root node of an "expression tree" which allows for the construction of complete boolean
 * logic statements. Statements are formed by grouping sets of children statement(s) or predicate(s)
 * according to the boolean operation which is to be applied.
 *
 * For example, the criteria "take an action if an entity is hostile and an air vehicle" can be
 * represented as: Statement1: { AndOperation: { Predicate1, Predicate2 } }. Where Statement1
 * is the root of the expression tree, with an AND operation that is applied to children
 * predicates. The predicates themselves encode "entity is hostile" and "entity is air vehicle."
 *
 * @generated from message anduril.entitymanager.v1.Statement
 */
export declare class Statement extends Message<Statement> {
  /**
   * @generated from oneof anduril.entitymanager.v1.Statement.operation
   */
  operation: {
    /**
     * @generated from field: anduril.entitymanager.v1.AndOperation and = 1;
     */
    value: AndOperation;
    case: "and";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.OrOperation or = 2;
     */
    value: OrOperation;
    case: "or";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.NotOperation not = 3;
     */
    value: NotOperation;
    case: "not";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.ListOperation list = 4;
     */
    value: ListOperation;
    case: "list";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.Predicate predicate = 5;
     */
    value: Predicate;
    case: "predicate";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Statement>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.Statement";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Statement;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Statement;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Statement;

  static equals(a: Statement | PlainMessage<Statement> | undefined, b: Statement | PlainMessage<Statement> | undefined): boolean;
}

/**
 * The AndOperation represents the boolean AND operation, which is to be applied to the list of
 * children statement(s) or predicate(s).
 *
 * @generated from message anduril.entitymanager.v1.AndOperation
 */
export declare class AndOperation extends Message<AndOperation> {
  /**
   * @generated from oneof anduril.entitymanager.v1.AndOperation.children
   */
  children: {
    /**
     * @generated from field: anduril.entitymanager.v1.PredicateSet predicate_set = 1;
     */
    value: PredicateSet;
    case: "predicateSet";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.StatementSet statement_set = 2;
     */
    value: StatementSet;
    case: "statementSet";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<AndOperation>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.AndOperation";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AndOperation;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AndOperation;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AndOperation;

  static equals(a: AndOperation | PlainMessage<AndOperation> | undefined, b: AndOperation | PlainMessage<AndOperation> | undefined): boolean;
}

/**
 * The OrOperation represents the boolean OR operation, which is to be applied to the list of
 * children statement(s) or predicate(s).
 *
 * @generated from message anduril.entitymanager.v1.OrOperation
 */
export declare class OrOperation extends Message<OrOperation> {
  /**
   * @generated from oneof anduril.entitymanager.v1.OrOperation.children
   */
  children: {
    /**
     * @generated from field: anduril.entitymanager.v1.PredicateSet predicate_set = 1;
     */
    value: PredicateSet;
    case: "predicateSet";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.StatementSet statement_set = 2;
     */
    value: StatementSet;
    case: "statementSet";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<OrOperation>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.OrOperation";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrOperation;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrOperation;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrOperation;

  static equals(a: OrOperation | PlainMessage<OrOperation> | undefined, b: OrOperation | PlainMessage<OrOperation> | undefined): boolean;
}

/**
 * The NotOperation represents the boolean NOT operation, which can only be applied to a single
 * child predicate or statement.
 *
 * @generated from message anduril.entitymanager.v1.NotOperation
 */
export declare class NotOperation extends Message<NotOperation> {
  /**
   * @generated from oneof anduril.entitymanager.v1.NotOperation.child
   */
  child: {
    /**
     * @generated from field: anduril.entitymanager.v1.Predicate predicate = 1;
     */
    value: Predicate;
    case: "predicate";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.Statement statement = 2;
     */
    value: Statement;
    case: "statement";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<NotOperation>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.NotOperation";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotOperation;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotOperation;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotOperation;

  static equals(a: NotOperation | PlainMessage<NotOperation> | undefined, b: NotOperation | PlainMessage<NotOperation> | undefined): boolean;
}

/**
 * The ListOperation represents an operation against a proto list. If the list is of primitive proto
 * type (e.g. int32), paths in all child predicates should be left empty. If the list is of message
 * proto type (e.g. Sensor), paths in all child predicates should be relative to the list path.
 *
 * For example, the criteria "take an action if an entity has any sensor with sensor_id='sensor' and
 * OperationalState=STATE_OFF" would be modeled as:
 * Predicate1: { path: "sensor_id", comparator: EQUAL_TO, value: "sensor" }
 * Predicate2: { path: "operational_state", comparator: EQUAL_TO, value: STATE_OFF }
 *
 * Statement2: { AndOperation: PredicateSet: { <Predicate1>, <Predicate2> } }
 * ListOperation: { list_path: "sensors.sensors", list_comparator: ANY, statement: <Statement2> }
 * Statement1: { ListOperation: <ListOperation> }
 *
 * Note that in the above, the child predicates of the list operation have paths relative to the
 * list_path because the list is comprised of message not primitive types.
 *
 * @generated from message anduril.entitymanager.v1.ListOperation
 */
export declare class ListOperation extends Message<ListOperation> {
  /**
   * The list_path specifies the repeated field on an entity to which this operation applies.
   *
   * @generated from field: string list_path = 1;
   */
  listPath: string;

  /**
   * The list_comparator specifies how to compose the boolean results from the child statement
   * for each member of the specified list.
   *
   * @generated from field: anduril.entitymanager.v1.ListComparator list_comparator = 2;
   */
  listComparator: ListComparator;

  /**
   * The statement is a new expression tree conceptually rooted at type of the list. It determines
   * how each member of the list is evaluated.
   *
   * @generated from field: anduril.entitymanager.v1.Statement statement = 3;
   */
  statement?: Statement;

  constructor(data?: PartialMessage<ListOperation>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.ListOperation";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListOperation;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListOperation;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListOperation;

  static equals(a: ListOperation | PlainMessage<ListOperation> | undefined, b: ListOperation | PlainMessage<ListOperation> | undefined): boolean;
}

/**
 * The PredicateSet represents a list of predicates or "leaf nodes" in the expression tree, which
 * can be directly evaluated to a boolean TRUE/FALSE result.
 *
 * @generated from message anduril.entitymanager.v1.PredicateSet
 */
export declare class PredicateSet extends Message<PredicateSet> {
  /**
   * @generated from field: repeated anduril.entitymanager.v1.Predicate predicates = 1;
   */
  predicates: Predicate[];

  constructor(data?: PartialMessage<PredicateSet>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.PredicateSet";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PredicateSet;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PredicateSet;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PredicateSet;

  static equals(a: PredicateSet | PlainMessage<PredicateSet> | undefined, b: PredicateSet | PlainMessage<PredicateSet> | undefined): boolean;
}

/**
 * The StatementSet represents a list of statements or "tree nodes," each of which follow the same
 * behavior as the Statement proto message.
 *
 * @generated from message anduril.entitymanager.v1.StatementSet
 */
export declare class StatementSet extends Message<StatementSet> {
  /**
   * @generated from field: repeated anduril.entitymanager.v1.Statement statements = 1;
   */
  statements: Statement[];

  constructor(data?: PartialMessage<StatementSet>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.StatementSet";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatementSet;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatementSet;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatementSet;

  static equals(a: StatementSet | PlainMessage<StatementSet> | undefined, b: StatementSet | PlainMessage<StatementSet> | undefined): boolean;
}

/**
 * The Predicate fully encodes the information required to make an evaluation of an entity field
 * against a given static value, resulting in a boolean TRUE/FALSE result. The structure of a
 * predicate will always follow: "{entity-value} {comparator} {fixed-value}" where the entity value
 * is determined by the field path.
 *
 * For example, a predicate would read as: "{entity.location.velocity_enu} {LESS_THAN} {500kph}"
 *
 * @generated from message anduril.entitymanager.v1.Predicate
 */
export declare class Predicate extends Message<Predicate> {
  /**
   * The field_path determines which field on an entity is being referenced in this predicate. For
   * example: correlated.primary_entity_id would be primary_entity_id in correlated component.
   *
   * @generated from field: string field_path = 1;
   */
  fieldPath: string;

  /**
   * The value determines the fixed value against which the entity field is to be compared.
   * In the case of COMPARATOR_MATCH_ALL, the value contents do not matter as long as the Value is a supported
   * type.
   *
   * @generated from field: anduril.entitymanager.v1.Value value = 2;
   */
  value?: Value;

  /**
   * The comparator determines the manner in which the entity field and static value are compared.
   * Comparators may only be applied to certain values. For example, the WITHIN comparator cannot
   * be used for a boolean value comparison.
   *
   * @generated from field: anduril.entitymanager.v1.Comparator comparator = 3;
   */
  comparator: Comparator;

  constructor(data?: PartialMessage<Predicate>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.Predicate";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Predicate;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Predicate;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Predicate;

  static equals(a: Predicate | PlainMessage<Predicate> | undefined, b: Predicate | PlainMessage<Predicate> | undefined): boolean;
}

/**
 * The Value represents the information against which an entity field is evaluated. It is one of
 * a fixed set of types, each of which correspond to specific comparators. See "ComparatorType"
 * for the full list of Value <-> Comparator mappings.
 *
 * @generated from message anduril.entitymanager.v1.Value
 */
export declare class Value extends Message<Value> {
  /**
   * @generated from oneof anduril.entitymanager.v1.Value.type
   */
  type: {
    /**
     * @generated from field: anduril.entitymanager.v1.BooleanType boolean_type = 1;
     */
    value: BooleanType;
    case: "booleanType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.NumericType numeric_type = 2;
     */
    value: NumericType;
    case: "numericType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.StringType string_type = 3;
     */
    value: StringType;
    case: "stringType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.EnumType enum_type = 4;
     */
    value: EnumType;
    case: "enumType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.TimestampType timestamp_type = 5;
     */
    value: TimestampType;
    case: "timestampType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.BoundedShapeType bounded_shape_type = 6;
     */
    value: BoundedShapeType;
    case: "boundedShapeType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.PositionType position_type = 7;
     */
    value: PositionType;
    case: "positionType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.HeadingType heading_type = 8;
     */
    value: HeadingType;
    case: "headingType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.ListType list_type = 9;
     */
    value: ListType;
    case: "listType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.RangeType range_type = 10;
     */
    value: RangeType;
    case: "rangeType";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Value>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.Value";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Value;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Value;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Value;

  static equals(a: Value | PlainMessage<Value> | undefined, b: Value | PlainMessage<Value> | undefined): boolean;
}

/**
 * The BooleanType represents a static boolean value.
 *
 * @generated from message anduril.entitymanager.v1.BooleanType
 */
export declare class BooleanType extends Message<BooleanType> {
  /**
   * @generated from field: bool value = 1;
   */
  value: boolean;

  constructor(data?: PartialMessage<BooleanType>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.BooleanType";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BooleanType;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BooleanType;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BooleanType;

  static equals(a: BooleanType | PlainMessage<BooleanType> | undefined, b: BooleanType | PlainMessage<BooleanType> | undefined): boolean;
}

/**
 * The NumericType represents static numeric values. It supports all numeric primitives supported
 * by the proto3 language specification.
 *
 * @generated from message anduril.entitymanager.v1.NumericType
 */
export declare class NumericType extends Message<NumericType> {
  /**
   * @generated from oneof anduril.entitymanager.v1.NumericType.value
   */
  value: {
    /**
     * @generated from field: double double_value = 1;
     */
    value: number;
    case: "doubleValue";
  } | {
    /**
     * @generated from field: float float_value = 2;
     */
    value: number;
    case: "floatValue";
  } | {
    /**
     * @generated from field: int32 int32_value = 3;
     */
    value: number;
    case: "int32Value";
  } | {
    /**
     * @generated from field: int64 int64_value = 4;
     */
    value: bigint;
    case: "int64Value";
  } | {
    /**
     * @generated from field: uint32 uint32_value = 5;
     */
    value: number;
    case: "uint32Value";
  } | {
    /**
     * @generated from field: uint64 uint64_value = 6;
     */
    value: bigint;
    case: "uint64Value";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<NumericType>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.NumericType";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NumericType;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NumericType;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NumericType;

  static equals(a: NumericType | PlainMessage<NumericType> | undefined, b: NumericType | PlainMessage<NumericType> | undefined): boolean;
}

/**
 * The StringType represents static string values.
 *
 * @generated from message anduril.entitymanager.v1.StringType
 */
export declare class StringType extends Message<StringType> {
  /**
   * @generated from field: string value = 1;
   */
  value: string;

  constructor(data?: PartialMessage<StringType>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.StringType";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringType;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringType;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringType;

  static equals(a: StringType | PlainMessage<StringType> | undefined, b: StringType | PlainMessage<StringType> | undefined): boolean;
}

/**
 * The EnumType represents members of well-known anduril ontologies, such as "disposition." When
 * such a value is specified, the evaluation library expects the integer representation of the enum
 * value. For example, a disposition derived from ontology.v1 such as "DISPOSITION_HOSTILE" should be
 * represented with the integer value 2.
 *
 * @generated from message anduril.entitymanager.v1.EnumType
 */
export declare class EnumType extends Message<EnumType> {
  /**
   * @generated from field: int32 value = 1;
   */
  value: number;

  constructor(data?: PartialMessage<EnumType>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.EnumType";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnumType;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnumType;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnumType;

  static equals(a: EnumType | PlainMessage<EnumType> | undefined, b: EnumType | PlainMessage<EnumType> | undefined): boolean;
}

/**
 * A List of Values for use with the IN comparator.
 *
 * @generated from message anduril.entitymanager.v1.ListType
 */
export declare class ListType extends Message<ListType> {
  /**
   * @generated from field: repeated anduril.entitymanager.v1.Value values = 1;
   */
  values: Value[];

  constructor(data?: PartialMessage<ListType>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.ListType";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListType;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListType;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListType;

  static equals(a: ListType | PlainMessage<ListType> | undefined, b: ListType | PlainMessage<ListType> | undefined): boolean;
}

/**
 * The TimestampType represents a static timestamp value.
 *
 * @generated from message anduril.entitymanager.v1.TimestampType
 */
export declare class TimestampType extends Message<TimestampType> {
  /**
   * @generated from field: google.protobuf.Timestamp value = 1;
   */
  value?: Timestamp;

  constructor(data?: PartialMessage<TimestampType>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.TimestampType";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimestampType;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimestampType;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimestampType;

  static equals(a: TimestampType | PlainMessage<TimestampType> | undefined, b: TimestampType | PlainMessage<TimestampType> | undefined): boolean;
}

/**
 * The PositionType represents any fixed LLA point in space.
 *
 * @generated from message anduril.entitymanager.v1.PositionType
 */
export declare class PositionType extends Message<PositionType> {
  /**
   * @generated from field: anduril.entitymanager.v1.Position value = 1;
   */
  value?: Position;

  constructor(data?: PartialMessage<PositionType>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.PositionType";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PositionType;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PositionType;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PositionType;

  static equals(a: PositionType | PlainMessage<PositionType> | undefined, b: PositionType | PlainMessage<PositionType> | undefined): boolean;
}

/**
 * The BoundedShapeType represents any static fully-enclosed shape.
 *
 * @generated from message anduril.entitymanager.v1.BoundedShapeType
 */
export declare class BoundedShapeType extends Message<BoundedShapeType> {
  /**
   * @generated from oneof anduril.entitymanager.v1.BoundedShapeType.value
   */
  value: {
    /**
     * @generated from field: anduril.entitymanager.v1.GeoPolygon polygon_value = 1;
     */
    value: GeoPolygon;
    case: "polygonValue";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<BoundedShapeType>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.BoundedShapeType";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BoundedShapeType;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BoundedShapeType;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BoundedShapeType;

  static equals(a: BoundedShapeType | PlainMessage<BoundedShapeType> | undefined, b: BoundedShapeType | PlainMessage<BoundedShapeType> | undefined): boolean;
}

/**
 * The HeadingType represents the heading in degrees for an entity's
 * attitudeEnu quaternion to be compared against. Defaults between a range of 0 to 360
 *
 * @generated from message anduril.entitymanager.v1.HeadingType
 */
export declare class HeadingType extends Message<HeadingType> {
  /**
   * @generated from field: int32 value = 1;
   */
  value: number;

  constructor(data?: PartialMessage<HeadingType>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.HeadingType";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeadingType;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeadingType;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeadingType;

  static equals(a: HeadingType | PlainMessage<HeadingType> | undefined, b: HeadingType | PlainMessage<HeadingType> | undefined): boolean;
}

/**
 * The RangeType represents a numeric range.
 * Whether endpoints are included are based on the comparator used.
 * Both endpoints must be of the same numeric type.
 *
 * @generated from message anduril.entitymanager.v1.RangeType
 */
export declare class RangeType extends Message<RangeType> {
  /**
   * @generated from field: anduril.entitymanager.v1.NumericType start = 1;
   */
  start?: NumericType;

  /**
   * @generated from field: anduril.entitymanager.v1.NumericType end = 2;
   */
  end?: NumericType;

  constructor(data?: PartialMessage<RangeType>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.RangeType";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RangeType;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RangeType;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RangeType;

  static equals(a: RangeType | PlainMessage<RangeType> | undefined, b: RangeType | PlainMessage<RangeType> | undefined): boolean;
}

