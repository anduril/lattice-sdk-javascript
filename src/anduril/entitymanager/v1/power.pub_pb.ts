// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/entitymanager/v1/power.pub.proto (package anduril.entitymanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { BoolValue, DoubleValue, Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum anduril.entitymanager.v1.PowerStatus
 */
export enum PowerStatus {
  /**
   * @generated from enum value: POWER_STATUS_INVALID = 0;
   */
  INVALID = 0,

  /**
   * Indeterminate condition of whether the power system is present or absent.
   *
   * @generated from enum value: POWER_STATUS_UNKNOWN = 1;
   */
  UNKNOWN = 1,

  /**
   * Power system is not configured/present. This is considered a normal/expected condition, as opposed to the
   * system is expected to be present but is missing.
   *
   * @generated from enum value: POWER_STATUS_NOT_PRESENT = 2;
   */
  NOT_PRESENT = 2,

  /**
   * Power system is present and operating normally.
   *
   * @generated from enum value: POWER_STATUS_OPERATING = 3;
   */
  OPERATING = 3,

  /**
   * Power system is present and is in an expected disabled state. For example, if the generator was shut off for
   * operational reasons.
   *
   * @generated from enum value: POWER_STATUS_DISABLED = 4;
   */
  DISABLED = 4,

  /**
   * Power system is non-functional.
   *
   * @generated from enum value: POWER_STATUS_ERROR = 5;
   */
  ERROR = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(PowerStatus)
proto3.util.setEnumType(PowerStatus, "anduril.entitymanager.v1.PowerStatus", [
  { no: 0, name: "POWER_STATUS_INVALID" },
  { no: 1, name: "POWER_STATUS_UNKNOWN" },
  { no: 2, name: "POWER_STATUS_NOT_PRESENT" },
  { no: 3, name: "POWER_STATUS_OPERATING" },
  { no: 4, name: "POWER_STATUS_DISABLED" },
  { no: 5, name: "POWER_STATUS_ERROR" },
]);

/**
 * @generated from enum anduril.entitymanager.v1.PowerType
 */
export enum PowerType {
  /**
   * @generated from enum value: POWER_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: POWER_TYPE_UNKNOWN = 1;
   */
  UNKNOWN = 1,

  /**
   * @generated from enum value: POWER_TYPE_GAS = 2;
   */
  GAS = 2,

  /**
   * @generated from enum value: POWER_TYPE_BATTERY = 3;
   */
  BATTERY = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(PowerType)
proto3.util.setEnumType(PowerType, "anduril.entitymanager.v1.PowerType", [
  { no: 0, name: "POWER_TYPE_INVALID" },
  { no: 1, name: "POWER_TYPE_UNKNOWN" },
  { no: 2, name: "POWER_TYPE_GAS" },
  { no: 3, name: "POWER_TYPE_BATTERY" },
]);

/**
 * Represents the state of power sources connected to this entity.
 *
 * @generated from message anduril.entitymanager.v1.PowerState
 */
export class PowerState extends Message<PowerState> {
  /**
   * @generated from field: map<string, anduril.entitymanager.v1.PowerSource> source_id_to_state = 5;
   */
  sourceIdToState: { [key: string]: PowerSource } = {};

  /**
   * @generated from field: anduril.entitymanager.v1.PowerStatus power_status = 1 [deprecated = true];
   * @deprecated
   */
  powerStatus = PowerStatus.INVALID;

  /**
   * @generated from field: anduril.entitymanager.v1.PowerType power_type = 2 [deprecated = true];
   * @deprecated
   */
  powerType = PowerType.INVALID;

  /**
   * @generated from field: anduril.entitymanager.v1.PowerLevel power_level = 3 [deprecated = true];
   * @deprecated
   */
  powerLevel?: PowerLevel;

  /**
   * @generated from field: repeated string messages = 4 [deprecated = true];
   * @deprecated
   */
  messages: string[] = [];

  constructor(data?: PartialMessage<PowerState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.PowerState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "source_id_to_state", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: PowerSource} },
    { no: 1, name: "power_status", kind: "enum", T: proto3.getEnumType(PowerStatus) },
    { no: 2, name: "power_type", kind: "enum", T: proto3.getEnumType(PowerType) },
    { no: 3, name: "power_level", kind: "message", T: PowerLevel },
    { no: 4, name: "messages", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PowerState {
    return new PowerState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PowerState {
    return new PowerState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PowerState {
    return new PowerState().fromJsonString(jsonString, options);
  }

  static equals(a: PowerState | PlainMessage<PowerState> | undefined, b: PowerState | PlainMessage<PowerState> | undefined): boolean {
    return proto3.util.equals(PowerState, a, b);
  }
}

/**
 * Represents the state of a single power source that is connected to this entity.
 *
 * @generated from message anduril.entitymanager.v1.PowerSource
 */
export class PowerSource extends Message<PowerSource> {
  /**
   * Status of the power source.
   *
   * @generated from field: anduril.entitymanager.v1.PowerStatus power_status = 1;
   */
  powerStatus = PowerStatus.INVALID;

  /**
   * Used to determine the type of power source.
   *
   * @generated from field: anduril.entitymanager.v1.PowerType power_type = 2;
   */
  powerType = PowerType.INVALID;

  /**
   * Power level of the system. If absent, the power level is assumed to be unknown.
   *
   * @generated from field: anduril.entitymanager.v1.PowerLevel power_level = 3;
   */
  powerLevel?: PowerLevel;

  /**
   * Set of human-readable messages with status of the power system. Typically this would be used in an error state
   * to provide additional error information. This can also be used for informational messages.
   *
   * @generated from field: repeated string messages = 4;
   */
  messages: string[] = [];

  /**
   * Whether the power source is offloadable. If the value is missing (as opposed to false) then the entity does not
   * report whether the power source is offloadable.
   *
   * @generated from field: google.protobuf.BoolValue offloadable = 5;
   */
  offloadable?: boolean;

  constructor(data?: PartialMessage<PowerSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.PowerSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "power_status", kind: "enum", T: proto3.getEnumType(PowerStatus) },
    { no: 2, name: "power_type", kind: "enum", T: proto3.getEnumType(PowerType) },
    { no: 3, name: "power_level", kind: "message", T: PowerLevel },
    { no: 4, name: "messages", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "offloadable", kind: "message", T: BoolValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PowerSource {
    return new PowerSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PowerSource {
    return new PowerSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PowerSource {
    return new PowerSource().fromJsonString(jsonString, options);
  }

  static equals(a: PowerSource | PlainMessage<PowerSource> | undefined, b: PowerSource | PlainMessage<PowerSource> | undefined): boolean {
    return proto3.util.equals(PowerSource, a, b);
  }
}

/**
 * Represents the power level of a system.
 *
 * @generated from message anduril.entitymanager.v1.PowerLevel
 */
export class PowerLevel extends Message<PowerLevel> {
  /**
   * Total power capacity of the system.
   *
   * @generated from field: float capacity = 1;
   */
  capacity = 0;

  /**
   * Remaining power capacity of the system.
   *
   * @generated from field: float remaining = 2;
   */
  remaining = 0;

  /**
   * Percent of power remaining.
   *
   * @generated from field: float percent_remaining = 3;
   */
  percentRemaining = 0;

  /**
   * Voltage of the power source subsystem, as reported by the power source. If the source does not report this value
   * this field will be null.
   *
   * @generated from field: google.protobuf.DoubleValue voltage = 4;
   */
  voltage?: number;

  /**
   * Current in amps of the power source subsystem, as reported by the power source. If the source does not
   * report this value this field will be null.
   *
   * @generated from field: google.protobuf.DoubleValue current_amps = 5;
   */
  currentAmps?: number;

  /**
   * Estimated minutes until empty. Calculated with consumption at the moment, as reported by the power source. If the source does not
   * report this value this field will be null.
   *
   * @generated from field: google.protobuf.DoubleValue run_time_to_empty_mins = 6;
   */
  runTimeToEmptyMins?: number;

  /**
   * Fuel consumption rate in liters per second.
   *
   * @generated from field: google.protobuf.DoubleValue consumption_rate_l_per_s = 7;
   */
  consumptionRateLPerS?: number;

  constructor(data?: PartialMessage<PowerLevel>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.PowerLevel";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "capacity", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "remaining", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "percent_remaining", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "voltage", kind: "message", T: DoubleValue },
    { no: 5, name: "current_amps", kind: "message", T: DoubleValue },
    { no: 6, name: "run_time_to_empty_mins", kind: "message", T: DoubleValue },
    { no: 7, name: "consumption_rate_l_per_s", kind: "message", T: DoubleValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PowerLevel {
    return new PowerLevel().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PowerLevel {
    return new PowerLevel().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PowerLevel {
    return new PowerLevel().fromJsonString(jsonString, options);
  }

  static equals(a: PowerLevel | PlainMessage<PowerLevel> | undefined, b: PowerLevel | PlainMessage<PowerLevel> | undefined): boolean {
    return proto3.util.equals(PowerLevel, a, b);
  }
}

