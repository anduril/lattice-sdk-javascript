// @generated by protoc-gen-es v2.2.0 with parameter "import_extension=js"
// @generated from file anduril/entitymanager/v1/sensors.pub.proto (package anduril.entitymanager.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import type { Pose, Position } from "./location.pub_pb.js";
import type { FrequencyRange } from "./signal.pub_pb.js";

/**
 * Describes the file anduril/entitymanager/v1/sensors.pub.proto.
 */
export declare const file_anduril_entitymanager_v1_sensors_pub: GenFile;

/**
 * List of sensors available for an entity.
 *
 * @generated from message anduril.entitymanager.v1.Sensors
 */
export declare type Sensors = Message<"anduril.entitymanager.v1.Sensors"> & {
  /**
   * @generated from field: repeated anduril.entitymanager.v1.Sensor sensors = 1;
   */
  sensors: Sensor[];
};

/**
 * Describes the message anduril.entitymanager.v1.Sensors.
 * Use `create(SensorsSchema)` to create a new message.
 */
export declare const SensorsSchema: GenMessage<Sensors>;

/**
 * Individual sensor configuration.
 *
 * @generated from message anduril.entitymanager.v1.Sensor
 */
export declare type Sensor = Message<"anduril.entitymanager.v1.Sensor"> & {
  /**
   * This generally is used to indicate a specific type at a more detailed granularity. E.g. COMInt or LWIR
   *
   * @generated from field: string sensor_id = 1;
   */
  sensorId: string;

  /**
   * @generated from field: anduril.entitymanager.v1.OperationalState operational_state = 3;
   */
  operationalState: OperationalState;

  /**
   * The type of sensor
   *
   * @generated from field: anduril.entitymanager.v1.SensorType sensor_type = 5;
   */
  sensorType: SensorType;

  /**
   * A human readable description of the sensor
   *
   * @generated from field: string sensor_description = 6;
   */
  sensorDescription: string;

  /**
   * RF configuration details of the sensor
   *
   * @generated from field: anduril.entitymanager.v1.RFConfiguration rf_configuraton = 7;
   */
  rfConfiguraton?: RFConfiguration;

  /**
   * Time of the latest detection from the sensor
   *
   * @generated from field: google.protobuf.Timestamp last_detection_timestamp = 8;
   */
  lastDetectionTimestamp?: Timestamp;

  /**
   * Multiple fields of view for a single sensor component
   *
   * @generated from field: repeated anduril.entitymanager.v1.FieldOfView fields_of_view = 9;
   */
  fieldsOfView: FieldOfView[];
};

/**
 * Describes the message anduril.entitymanager.v1.Sensor.
 * Use `create(SensorSchema)` to create a new message.
 */
export declare const SensorSchema: GenMessage<Sensor>;

/**
 * Sensor Field Of View closely resembling fov.proto SensorFieldOfView.
 *
 * @generated from message anduril.entitymanager.v1.FieldOfView
 */
export declare type FieldOfView = Message<"anduril.entitymanager.v1.FieldOfView"> & {
  /**
   * The Id for one instance of a FieldOfView, persisted across multiple updates to provide continuity during
   * smoothing. This is relevant for sensors where the dwell schedule is on the order of
   * milliseconds, making multiple FOVs a requirement for proper display of search beams.
   *
   * @generated from field: int32 fov_id = 1;
   */
  fovId: number;

  /**
   * The Id of the mount the sensor is on.
   *
   * @generated from field: string mount_id = 2;
   */
  mountId: string;

  /**
   * The field of view the sensor projected onto the ground.
   *
   * @generated from field: anduril.entitymanager.v1.ProjectedFrustum projected_frustum = 3;
   */
  projectedFrustum?: ProjectedFrustum;

  /**
   * Center ray of the frustum projected onto the ground.
   *
   * @generated from field: anduril.entitymanager.v1.Position projected_center_ray = 4;
   */
  projectedCenterRay?: Position;

  /**
   * The origin and direction of the center ray for this sensor relative to the ENU frame. A ray which is aligned with
   * the positive X axis in the sensor frame will be transformed into the ray along the sensor direction in the ENU
   * frame when transformed by the quaternion contained in this pose.
   *
   * @generated from field: anduril.entitymanager.v1.Pose center_ray_pose = 5;
   */
  centerRayPose?: Pose;

  /**
   * Horizontal field of view in radians.
   *
   * @generated from field: float horizontal_fov = 6;
   */
  horizontalFov: number;

  /**
   * Vertical field of view in radians.
   *
   * @generated from field: float vertical_fov = 7;
   */
  verticalFov: number;

  /**
   * Sensor range in meters.
   *
   * @generated from field: google.protobuf.FloatValue range = 8;
   */
  range?: number;

  /**
   * The mode that this sensor is currently in, used to display for context in the UI. Some sensors can emit multiple
   * sensor field of views with different modes, for example a radar can simultaneously search broadly and perform
   * tighter bounded tracking.
   *
   * @generated from field: anduril.entitymanager.v1.SensorMode mode = 9;
   */
  mode: SensorMode;
};

/**
 * Describes the message anduril.entitymanager.v1.FieldOfView.
 * Use `create(FieldOfViewSchema)` to create a new message.
 */
export declare const FieldOfViewSchema: GenMessage<FieldOfView>;

/**
 * Represents a frustum in which which all four corner points project onto the ground. All points in this message
 * are optional, if the projection to the ground fails then they will not be populated.
 *
 * @generated from message anduril.entitymanager.v1.ProjectedFrustum
 */
export declare type ProjectedFrustum = Message<"anduril.entitymanager.v1.ProjectedFrustum"> & {
  /**
   * Upper left point of the frustum.
   *
   * @generated from field: anduril.entitymanager.v1.Position upper_left = 1;
   */
  upperLeft?: Position;

  /**
   * Upper right point of the frustum.
   *
   * @generated from field: anduril.entitymanager.v1.Position upper_right = 2;
   */
  upperRight?: Position;

  /**
   * Bottom right point of the frustum.
   *
   * @generated from field: anduril.entitymanager.v1.Position bottom_right = 3;
   */
  bottomRight?: Position;

  /**
   * Bottom left point of the frustum.
   *
   * @generated from field: anduril.entitymanager.v1.Position bottom_left = 4;
   */
  bottomLeft?: Position;
};

/**
 * Describes the message anduril.entitymanager.v1.ProjectedFrustum.
 * Use `create(ProjectedFrustumSchema)` to create a new message.
 */
export declare const ProjectedFrustumSchema: GenMessage<ProjectedFrustum>;

/**
 * Represents RF configurations supported on this sensor.
 *
 * @generated from message anduril.entitymanager.v1.RFConfiguration
 */
export declare type RFConfiguration = Message<"anduril.entitymanager.v1.RFConfiguration"> & {
  /**
   * Frequency ranges that are available for this sensor.
   *
   * @generated from field: repeated anduril.entitymanager.v1.FrequencyRange frequency_range_hz = 3;
   */
  frequencyRangeHz: FrequencyRange[];

  /**
   * Bandwidth ranges that are available for this sensor.
   *
   * @generated from field: repeated anduril.entitymanager.v1.BandwidthRange bandwidth_range_hz = 4;
   */
  bandwidthRangeHz: BandwidthRange[];
};

/**
 * Describes the message anduril.entitymanager.v1.RFConfiguration.
 * Use `create(RFConfigurationSchema)` to create a new message.
 */
export declare const RFConfigurationSchema: GenMessage<RFConfiguration>;

/**
 * A component that describes the min and max bandwidths of a sensor
 *
 * @generated from message anduril.entitymanager.v1.BandwidthRange
 */
export declare type BandwidthRange = Message<"anduril.entitymanager.v1.BandwidthRange"> & {
  /**
   * @generated from field: anduril.entitymanager.v1.Bandwidth minimum_bandwidth = 1;
   */
  minimumBandwidth?: Bandwidth;

  /**
   * @generated from field: anduril.entitymanager.v1.Bandwidth maximum_bandwidth = 2;
   */
  maximumBandwidth?: Bandwidth;
};

/**
 * Describes the message anduril.entitymanager.v1.BandwidthRange.
 * Use `create(BandwidthRangeSchema)` to create a new message.
 */
export declare const BandwidthRangeSchema: GenMessage<BandwidthRange>;

/**
 * Describes the bandwidth of a signal
 *
 * @generated from message anduril.entitymanager.v1.Bandwidth
 */
export declare type Bandwidth = Message<"anduril.entitymanager.v1.Bandwidth"> & {
  /**
   * @generated from field: google.protobuf.DoubleValue bandwidth_hz = 1;
   */
  bandwidthHz?: number;
};

/**
 * Describes the message anduril.entitymanager.v1.Bandwidth.
 * Use `create(BandwidthSchema)` to create a new message.
 */
export declare const BandwidthSchema: GenMessage<Bandwidth>;

/**
 * Describes the current operational state of a system.
 *
 * @generated from enum anduril.entitymanager.v1.OperationalState
 */
export enum OperationalState {
  /**
   * @generated from enum value: OPERATIONAL_STATE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * sensor exists but is deliberately turned off
   *
   * @generated from enum value: OPERATIONAL_STATE_OFF = 1;
   */
  OFF = 1,

  /**
   * sensor is not operational but some reason other than being "Off" (e.g., equipment malfunction)
   *
   * @generated from enum value: OPERATIONAL_STATE_NON_OPERATIONAL = 2;
   */
  NON_OPERATIONAL = 2,

  /**
   * sensor is receiving information but in some reduced status (e.g., off calibration)
   *
   * @generated from enum value: OPERATIONAL_STATE_DEGRADED = 3;
   */
  DEGRADED = 3,

  /**
   * fully functional
   *
   * @generated from enum value: OPERATIONAL_STATE_OPERATIONAL = 4;
   */
  OPERATIONAL = 4,

  /**
   * sensor is being actively denied
   *
   * @generated from enum value: OPERATIONAL_STATE_DENIED = 5;
   */
  DENIED = 5,
}

/**
 * Describes the enum anduril.entitymanager.v1.OperationalState.
 */
export declare const OperationalStateSchema: GenEnum<OperationalState>;

/**
 * Enumerates the possible sensor modes which were active for this sensor field of view.
 *
 * @generated from enum anduril.entitymanager.v1.SensorMode
 */
export enum SensorMode {
  /**
   * @generated from enum value: SENSOR_MODE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: SENSOR_MODE_SEARCH = 1;
   */
  SEARCH = 1,

  /**
   * @generated from enum value: SENSOR_MODE_TRACK = 2;
   */
  TRACK = 2,

  /**
   * @generated from enum value: SENSOR_MODE_WEAPON_SUPPORT = 3;
   */
  WEAPON_SUPPORT = 3,

  /**
   * @generated from enum value: SENSOR_MODE_AUTO = 4;
   */
  AUTO = 4,

  /**
   * @generated from enum value: SENSOR_MODE_MUTE = 5;
   */
  MUTE = 5,
}

/**
 * Describes the enum anduril.entitymanager.v1.SensorMode.
 */
export declare const SensorModeSchema: GenEnum<SensorMode>;

/**
 * @generated from enum anduril.entitymanager.v1.SensorType
 */
export enum SensorType {
  /**
   * @generated from enum value: SENSOR_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: SENSOR_TYPE_RADAR = 1;
   */
  RADAR = 1,

  /**
   * @generated from enum value: SENSOR_TYPE_CAMERA = 2;
   */
  CAMERA = 2,

  /**
   * @generated from enum value: SENSOR_TYPE_TRANSPONDER = 3;
   */
  TRANSPONDER = 3,

  /**
   * @generated from enum value: SENSOR_TYPE_RF = 4;
   */
  RF = 4,

  /**
   * @generated from enum value: SENSOR_TYPE_GPS = 5;
   */
  GPS = 5,

  /**
   * @generated from enum value: SENSOR_TYPE_PTU_POS = 6;
   */
  PTU_POS = 6,

  /**
   * @generated from enum value: SENSOR_TYPE_PERIMETER = 8;
   */
  PERIMETER = 8,

  /**
   * @generated from enum value: SENSOR_TYPE_SONAR = 9;
   */
  SONAR = 9,
}

/**
 * Describes the enum anduril.entitymanager.v1.SensorType.
 */
export declare const SensorTypeSchema: GenEnum<SensorType>;

