// @generated by protoc-gen-es v2.2.0 with parameter "import_extension=js"
// @generated from file anduril/entitymanager/v1/entity_manager_grpcapi.pub.proto (package anduril.entitymanager.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";
import type { Entity, Provenance } from "./entity.pub_pb.js";
import type { OverrideStatus } from "./types.pub_pb.js";
import type { Statement } from "./filter.pub_pb.js";
import type { RateLimit } from "./rate_limit.pub_pb.js";
import type { Timestamp } from "@bufbuild/protobuf/wkt";

/**
 * Describes the file anduril/entitymanager/v1/entity_manager_grpcapi.pub.proto.
 */
export declare const file_anduril_entitymanager_v1_entity_manager_grpcapi_pub: GenFile;

/**
 * @generated from message anduril.entitymanager.v1.PublishEntityRequest
 */
export declare type PublishEntityRequest = Message<"anduril.entitymanager.v1.PublishEntityRequest"> & {
  /**
   * Sends an entity object to publish.
   * Required fields:
   *   * expiry_time. This must be in the future, but less than 30 days from now.
   *   * provenance.data_type. If using the deprecated provenance.source, migrate to data_type.
   *   * provenance.source_update_time. This can be earlier than the RPC call if the data entered is older.
   *   * aliases.name
   *   * ontology.template
   * For additional required fields that are determined by template, see com.anduril.entitymanager.v1.Template.
   * if an entity_id is provided, Entity Manager updates the entity. If no entity_id is provided, it creates an entity.
   *
   * @generated from field: anduril.entitymanager.v1.Entity entity = 1;
   */
  entity?: Entity;
};

/**
 * Describes the message anduril.entitymanager.v1.PublishEntityRequest.
 * Use `create(PublishEntityRequestSchema)` to create a new message.
 */
export declare const PublishEntityRequestSchema: GenMessage<PublishEntityRequest>;

/**
 * @generated from message anduril.entitymanager.v1.PublishEntityResponse
 */
export declare type PublishEntityResponse = Message<"anduril.entitymanager.v1.PublishEntityResponse"> & {
};

/**
 * Describes the message anduril.entitymanager.v1.PublishEntityResponse.
 * Use `create(PublishEntityResponseSchema)` to create a new message.
 */
export declare const PublishEntityResponseSchema: GenMessage<PublishEntityResponse>;

/**
 * @generated from message anduril.entitymanager.v1.PublishEntitiesRequest
 */
export declare type PublishEntitiesRequest = Message<"anduril.entitymanager.v1.PublishEntitiesRequest"> & {
  /**
   * Sends a stream of entity objects to publish.
   * Each entity requires the following fields:
   *   * expiry_time. This must be in the future, but less than 30 days from now.
   *   * provenance.data_type. If using the deprecated provenance.source, migrate to data_type.
   *   * provenance.source_update_time. This can be earlier than the RPC call if the data entered is older.
   *   * aliases.name
   *   * ontology.template
   * For additional required fields that are determined by template, see com.anduril.entitymanager.v1.Template.
   * If an entity_id is provided, the entity updates. If no entity_id is provided, the entity is created.
   *
   * @generated from field: anduril.entitymanager.v1.Entity entity = 1;
   */
  entity?: Entity;
};

/**
 * Describes the message anduril.entitymanager.v1.PublishEntitiesRequest.
 * Use `create(PublishEntitiesRequestSchema)` to create a new message.
 */
export declare const PublishEntitiesRequestSchema: GenMessage<PublishEntitiesRequest>;

/**
 * After the stream closes, the server returns an empty message indicating success. The server will silently
 * drop invalid entities from the client stream. The client must reopen the stream if it's canceled due to
 * an End of File (EOF) or timeout.
 *
 * @generated from message anduril.entitymanager.v1.PublishEntitiesResponse
 */
export declare type PublishEntitiesResponse = Message<"anduril.entitymanager.v1.PublishEntitiesResponse"> & {
};

/**
 * Describes the message anduril.entitymanager.v1.PublishEntitiesResponse.
 * Use `create(PublishEntitiesResponseSchema)` to create a new message.
 */
export declare const PublishEntitiesResponseSchema: GenMessage<PublishEntitiesResponse>;

/**
 * @generated from message anduril.entitymanager.v1.GetEntityRequest
 */
export declare type GetEntityRequest = Message<"anduril.entitymanager.v1.GetEntityRequest"> & {
  /**
   * the GUID of this entity to query
   *
   * @generated from field: string entity_id = 1;
   */
  entityId: string;
};

/**
 * Describes the message anduril.entitymanager.v1.GetEntityRequest.
 * Use `create(GetEntityRequestSchema)` to create a new message.
 */
export declare const GetEntityRequestSchema: GenMessage<GetEntityRequest>;

/**
 * @generated from message anduril.entitymanager.v1.GetEntityResponse
 */
export declare type GetEntityResponse = Message<"anduril.entitymanager.v1.GetEntityResponse"> & {
  /**
   * an Entity object that corresponds with the requested entityId
   *
   * @generated from field: anduril.entitymanager.v1.Entity entity = 1;
   */
  entity?: Entity;
};

/**
 * Describes the message anduril.entitymanager.v1.GetEntityResponse.
 * Use `create(GetEntityResponseSchema)` to create a new message.
 */
export declare const GetEntityResponseSchema: GenMessage<GetEntityResponse>;

/**
 * @generated from message anduril.entitymanager.v1.OverrideEntityRequest
 */
export declare type OverrideEntityRequest = Message<"anduril.entitymanager.v1.OverrideEntityRequest"> & {
  /**
   * The entity containing the overwritten fields. The service will extract the overridable fields from the entity
   * object and ignore any other fields.
   *
   * @generated from field: anduril.entitymanager.v1.Entity entity = 1;
   */
  entity?: Entity;

  /**
   * The field paths that will be extracted from the Entity and saved as an override. Only fields marked overridable can
   * be overridden.
   *
   * @generated from field: repeated string field_path = 2;
   */
  fieldPath: string[];

  /**
   * Additional information about the source of the override
   *
   * @generated from field: anduril.entitymanager.v1.Provenance provenance = 3;
   */
  provenance?: Provenance;
};

/**
 * Describes the message anduril.entitymanager.v1.OverrideEntityRequest.
 * Use `create(OverrideEntityRequestSchema)` to create a new message.
 */
export declare const OverrideEntityRequestSchema: GenMessage<OverrideEntityRequest>;

/**
 * @generated from message anduril.entitymanager.v1.OverrideEntityResponse
 */
export declare type OverrideEntityResponse = Message<"anduril.entitymanager.v1.OverrideEntityResponse"> & {
  /**
   * The status of the override request.
   *
   * @generated from field: anduril.entitymanager.v1.OverrideStatus status = 1;
   */
  status: OverrideStatus;
};

/**
 * Describes the message anduril.entitymanager.v1.OverrideEntityResponse.
 * Use `create(OverrideEntityResponseSchema)` to create a new message.
 */
export declare const OverrideEntityResponseSchema: GenMessage<OverrideEntityResponse>;

/**
 * @generated from message anduril.entitymanager.v1.RemoveEntityOverrideRequest
 */
export declare type RemoveEntityOverrideRequest = Message<"anduril.entitymanager.v1.RemoveEntityOverrideRequest"> & {
  /**
   * The entity ID that the override will be removed from
   *
   * @generated from field: string entity_id = 1;
   */
  entityId: string;

  /**
   * The field paths to remove from the override store for the provided entityId.
   *
   * @generated from field: repeated string field_path = 2;
   */
  fieldPath: string[];
};

/**
 * Describes the message anduril.entitymanager.v1.RemoveEntityOverrideRequest.
 * Use `create(RemoveEntityOverrideRequestSchema)` to create a new message.
 */
export declare const RemoveEntityOverrideRequestSchema: GenMessage<RemoveEntityOverrideRequest>;

/**
 * void response but with placeholder for future optional fields.
 *
 * @generated from message anduril.entitymanager.v1.RemoveEntityOverrideResponse
 */
export declare type RemoveEntityOverrideResponse = Message<"anduril.entitymanager.v1.RemoveEntityOverrideResponse"> & {
};

/**
 * Describes the message anduril.entitymanager.v1.RemoveEntityOverrideResponse.
 * Use `create(RemoveEntityOverrideResponseSchema)` to create a new message.
 */
export declare const RemoveEntityOverrideResponseSchema: GenMessage<RemoveEntityOverrideResponse>;

/**
 * @generated from message anduril.entitymanager.v1.StreamEntityComponentsRequest
 */
export declare type StreamEntityComponentsRequest = Message<"anduril.entitymanager.v1.StreamEntityComponentsRequest"> & {
  /**
   * lower_snake_cased component names to include in response events, e.g. location. Only included components will
   * populate.
   *
   * @generated from field: repeated string components_to_include = 1;
   */
  componentsToInclude: string[];

  /**
   * subscribe to all components. This should only be used in cases where you want all components.
   * Setting both components_to_include and include_all_components is invalid and will be rejected.
   *
   * @generated from field: bool include_all_components = 2;
   */
  includeAllComponents: boolean;

  /**
   * The root node of a statement filter "tree".
   * If provided, only entities matching the filter criteria will be streamed. The filter is applied dynamically so if a
   * new entity matches, it will be included, and if an entity updates to no longer match, it will be excluded.
   *
   * @generated from field: anduril.entitymanager.v1.Statement filter = 3;
   */
  filter?: Statement;

  /**
   * optional rate-limiting / down-sampling parameters, see RateLimit message for details.
   *
   * @generated from field: anduril.entitymanager.v1.RateLimit rate_limit = 4;
   */
  rateLimit?: RateLimit;

  /**
   * The period (in milliseconds) at which a Heartbeat message will be sent on the
   * message stream. If this field is set to 0 then no Heartbeat messages are sent.
   *
   * @generated from field: uint32 heartbeat_period_millis = 5;
   */
  heartbeatPeriodMillis: number;

  /**
   * subscribe to a finite stream of preexisting events which closes when there are no additional pre-existing events to
   * process. Respects the filter specified on the StreamEntityComponentsRequest.
   *
   * @generated from field: bool preexisting_only = 6;
   */
  preexistingOnly: boolean;
};

/**
 * Describes the message anduril.entitymanager.v1.StreamEntityComponentsRequest.
 * Use `create(StreamEntityComponentsRequestSchema)` to create a new message.
 */
export declare const StreamEntityComponentsRequestSchema: GenMessage<StreamEntityComponentsRequest>;

/**
 * response stream will be fed all matching pre-existing live entities as CREATED, plus any new events ongoing.
 *
 * @generated from message anduril.entitymanager.v1.StreamEntityComponentsResponse
 */
export declare type StreamEntityComponentsResponse = Message<"anduril.entitymanager.v1.StreamEntityComponentsResponse"> & {
  /**
   * @generated from field: anduril.entitymanager.v1.EntityEvent entity_event = 1;
   */
  entityEvent?: EntityEvent;

  /**
   * @generated from field: anduril.entitymanager.v1.Heartbeat heartbeat = 2;
   */
  heartbeat?: Heartbeat;
};

/**
 * Describes the message anduril.entitymanager.v1.StreamEntityComponentsResponse.
 * Use `create(StreamEntityComponentsResponseSchema)` to create a new message.
 */
export declare const StreamEntityComponentsResponseSchema: GenMessage<StreamEntityComponentsResponse>;

/**
 * Event representing some type of entity change.
 *
 * @generated from message anduril.entitymanager.v1.EntityEvent
 */
export declare type EntityEvent = Message<"anduril.entitymanager.v1.EntityEvent"> & {
  /**
   * @generated from field: anduril.entitymanager.v1.EventType event_type = 1;
   */
  eventType: EventType;

  /**
   * @generated from field: google.protobuf.Timestamp time = 2;
   */
  time?: Timestamp;

  /**
   * @generated from field: anduril.entitymanager.v1.Entity entity = 3;
   */
  entity?: Entity;
};

/**
 * Describes the message anduril.entitymanager.v1.EntityEvent.
 * Use `create(EntityEventSchema)` to create a new message.
 */
export declare const EntityEventSchema: GenMessage<EntityEvent>;

/**
 * A message that is periodically sent on the stream for keep-alive behaviour.
 *
 * @generated from message anduril.entitymanager.v1.Heartbeat
 */
export declare type Heartbeat = Message<"anduril.entitymanager.v1.Heartbeat"> & {
  /**
   * The timestamp at which the heartbeat message was sent.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;
};

/**
 * Describes the message anduril.entitymanager.v1.Heartbeat.
 * Use `create(HeartbeatSchema)` to create a new message.
 */
export declare const HeartbeatSchema: GenMessage<Heartbeat>;

/**
 * The type of entity event.
 *
 * @generated from enum anduril.entitymanager.v1.EventType
 */
export enum EventType {
  /**
   * @generated from enum value: EVENT_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * entity was created.
   *
   * @generated from enum value: EVENT_TYPE_CREATED = 1;
   */
  CREATED = 1,

  /**
   * entity was updated.
   *
   * @generated from enum value: EVENT_TYPE_UPDATE = 2;
   */
  UPDATE = 2,

  /**
   * entity was deleted.
   *
   * @generated from enum value: EVENT_TYPE_DELETED = 3;
   */
  DELETED = 3,

  /**
   * entity already existed, but sent on a new stream connection.
   *
   * @generated from enum value: EVENT_TYPE_PREEXISTING = 4;
   */
  PREEXISTING = 4,

  /**
   * entity override was set after the entity expiration.
   *
   * @generated from enum value: EVENT_TYPE_POST_EXPIRY_OVERRIDE = 5;
   */
  POST_EXPIRY_OVERRIDE = 5,
}

/**
 * Describes the enum anduril.entitymanager.v1.EventType.
 */
export declare const EventTypeSchema: GenEnum<EventType>;

/**
 * Entity Manager manages the lifecycle of the entities that comprise the common operational picture.
 *
 * Every object in a battle space is represented as an "Entity". Each Entity is essentially an ID, with a lifecycle
 * and a collection of data components. Each data component is a separate protobuf message definition.
 *
 * Entity Manager provides a way to query the currently live set of entities within a set of filter constraints,
 * as well as a limited set of management APIs to change the grouping or relationships between entities.
 *
 * @generated from service anduril.entitymanager.v1.EntityManagerAPI
 */
export declare const EntityManagerAPI: GenService<{
  /**
   * Publishes an entity for ingestion by Entity Manager. You "own" the entity you create using PublishEntity;
   * other sources, such as the UI, may not edit or delete these entities.
   * When called, PublishEntity validates the entity and returns an error if the entity is invalid. We recommend using PublishEntity to publish high- or
   * low-update rate entities.
   *
   * @generated from rpc anduril.entitymanager.v1.EntityManagerAPI.PublishEntity
   */
  publishEntity: {
    methodKind: "unary";
    input: typeof PublishEntityRequestSchema;
    output: typeof PublishEntityResponseSchema;
  },
  /**
   * Creates or updates one or more entities. You "own" the entity you create using PublishEntities; other sources may not edit or delete these entities.
   * Note that PublishEntities doesn't return error messages for invalid entities or provide any other feedback from the server. We recommend using PublishEntity instead.
   * We only recommend switching to PublishEntities if you publish at an extremely high rate and find that waiting for a response from the server causes your publishing task to fall behind.
   *
   * @generated from rpc anduril.entitymanager.v1.EntityManagerAPI.PublishEntities
   */
  publishEntities: {
    methodKind: "client_streaming";
    input: typeof PublishEntitiesRequestSchema;
    output: typeof PublishEntitiesResponseSchema;
  },
  /**
   * Get a entity based on an entityId.
   *
   * @generated from rpc anduril.entitymanager.v1.EntityManagerAPI.GetEntity
   */
  getEntity: {
    methodKind: "unary";
    input: typeof GetEntityRequestSchema;
    output: typeof GetEntityResponseSchema;
  },
  /**
   * Override an Entity Component. An override is a definitive change to entity data. Any authorized user of service
   * can override overridable components on any entity. Only fields marked with overridable can be overridden.
   * When setting an override, the user or service setting the override is asserting that they are certain of the change
   * and the truth behind it.
   *
   * @generated from rpc anduril.entitymanager.v1.EntityManagerAPI.OverrideEntity
   */
  overrideEntity: {
    methodKind: "unary";
    input: typeof OverrideEntityRequestSchema;
    output: typeof OverrideEntityResponseSchema;
  },
  /**
   * Remove an override for an Entity component.
   *
   * @generated from rpc anduril.entitymanager.v1.EntityManagerAPI.RemoveEntityOverride
   */
  removeEntityOverride: {
    methodKind: "unary";
    input: typeof RemoveEntityOverrideRequestSchema;
    output: typeof RemoveEntityOverrideResponseSchema;
  },
  /**
   * Returns a stream of entity with specified components populated.
   *
   * @generated from rpc anduril.entitymanager.v1.EntityManagerAPI.StreamEntityComponents
   */
  streamEntityComponents: {
    methodKind: "server_streaming";
    input: typeof StreamEntityComponentsRequestSchema;
    output: typeof StreamEntityComponentsResponseSchema;
  },
}>;

