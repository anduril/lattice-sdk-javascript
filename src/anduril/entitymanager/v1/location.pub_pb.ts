// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/entitymanager/v1/location.pub.proto (package anduril.entitymanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { DoubleValue, Message, proto3 } from "@bufbuild/protobuf";
import { ENU, Quaternion } from "../../type/coords.pub_pb.js";

/**
 * Available for Entities that have a single or primary Location.
 *
 * @generated from message anduril.entitymanager.v1.Location
 */
export class Location extends Message<Location> {
  /**
   * see Position definition for details. We opt not to use anduril type for altitude clarity.
   *
   * @generated from field: anduril.entitymanager.v1.Position position = 1;
   */
  position?: Position;

  /**
   * Velocity in an ENU reference frame centered on the corresponding position. All units are meters per second.
   *
   * @generated from field: anduril.type.ENU velocity_enu = 2;
   */
  velocityEnu?: ENU;

  /**
   * Speed is the magnitude of velocity_enu vector [sqrt(e^2 + n^2 + u^2)] when present, measured in m/s.
   *
   * @generated from field: google.protobuf.DoubleValue speed_mps = 5;
   */
  speedMps?: number;

  /**
   * The entity's acceleration in meters/s^2.
   *
   * @generated from field: anduril.type.ENU acceleration = 4;
   */
  acceleration?: ENU;

  /**
   * quaternion to translate from entity body frame to it's ENU frame
   *
   * @generated from field: anduril.type.Quaternion attitude_enu = 3;
   */
  attitudeEnu?: Quaternion;

  constructor(data?: PartialMessage<Location>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Location";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "position", kind: "message", T: Position },
    { no: 2, name: "velocity_enu", kind: "message", T: ENU },
    { no: 5, name: "speed_mps", kind: "message", T: DoubleValue },
    { no: 4, name: "acceleration", kind: "message", T: ENU },
    { no: 3, name: "attitude_enu", kind: "message", T: Quaternion },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Location {
    return new Location().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Location {
    return new Location().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Location {
    return new Location().fromJsonString(jsonString, options);
  }

  static equals(a: Location | PlainMessage<Location> | undefined, b: Location | PlainMessage<Location> | undefined): boolean {
    return proto3.util.equals(Location, a, b);
  }
}

/**
 * WGS84 position.
 *
 * @generated from message anduril.entitymanager.v1.Position
 */
export class Position extends Message<Position> {
  /**
   * WGS84 geodetic latitude in decimal degrees.
   *
   * @generated from field: double latitude_degrees = 1;
   */
  latitudeDegrees = 0;

  /**
   * WGS84 longitude in decimal degrees.
   *
   * @generated from field: double longitude_degrees = 2;
   */
  longitudeDegrees = 0;

  /**
   * altitude as height above ellipsoid (WGS84) in meters. DoubleValue wrapper is used to distinguish optional from
   * default 0.
   *
   * @generated from field: google.protobuf.DoubleValue altitude_hae_meters = 3;
   */
  altitudeHaeMeters?: number;

  /**
   * Altitude as AGL (Above Ground Level) if the upstream data source has this value set. If the value is not set from the upstream, this value is
   * not set.
   *
   * @generated from field: google.protobuf.DoubleValue altitude_agl_meters = 4;
   */
  altitudeAglMeters?: number;

  /**
   * Altitude as ASF (Above Sea Floor) if the upstream data source has this value set. If the value is not set from the upstream, this value is
   * not set.
   *
   * @generated from field: google.protobuf.DoubleValue altitude_asf_meters = 5;
   */
  altitudeAsfMeters?: number;

  /**
   * Depth in meters measures the depth of the entity from the surface of the water through sensor measurements based on differential pressure
   * between the interior and exterior of the vessel. If the value is not set from the upstream, this value is not set.
   *
   * @generated from field: google.protobuf.DoubleValue pressure_depth_meters = 6;
   */
  pressureDepthMeters?: number;

  constructor(data?: PartialMessage<Position>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Position";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "latitude_degrees", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "longitude_degrees", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "altitude_hae_meters", kind: "message", T: DoubleValue },
    { no: 4, name: "altitude_agl_meters", kind: "message", T: DoubleValue },
    { no: 5, name: "altitude_asf_meters", kind: "message", T: DoubleValue },
    { no: 6, name: "pressure_depth_meters", kind: "message", T: DoubleValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Position {
    return new Position().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJsonString(jsonString, options);
  }

  static equals(a: Position | PlainMessage<Position> | undefined, b: Position | PlainMessage<Position> | undefined): boolean {
    return proto3.util.equals(Position, a, b);
  }
}

/**
 * Uncertainty of entity position and velocity, if available.
 *
 * @generated from message anduril.entitymanager.v1.LocationUncertainty
 */
export class LocationUncertainty extends Message<LocationUncertainty> {
  /**
   * Positional covariance represented by the upper triangle of the covariance matrix.
   *
   * @generated from field: anduril.entitymanager.v1.TMat3 position_enu_cov = 1;
   */
  positionEnuCov?: TMat3;

  /**
   * Velocity covariance represented by the upper triangle of the covariance matrix.
   *
   * @generated from field: anduril.entitymanager.v1.TMat3 velocity_enu_cov = 2;
   */
  velocityEnuCov?: TMat3;

  /**
   * An ellipse that describes the certainty probability and error boundary for a given geolocation.
   *
   * @generated from field: anduril.entitymanager.v1.ErrorEllipse position_error_ellipse = 3;
   */
  positionErrorEllipse?: ErrorEllipse;

  constructor(data?: PartialMessage<LocationUncertainty>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.LocationUncertainty";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "position_enu_cov", kind: "message", T: TMat3 },
    { no: 2, name: "velocity_enu_cov", kind: "message", T: TMat3 },
    { no: 3, name: "position_error_ellipse", kind: "message", T: ErrorEllipse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocationUncertainty {
    return new LocationUncertainty().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocationUncertainty {
    return new LocationUncertainty().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocationUncertainty {
    return new LocationUncertainty().fromJsonString(jsonString, options);
  }

  static equals(a: LocationUncertainty | PlainMessage<LocationUncertainty> | undefined, b: LocationUncertainty | PlainMessage<LocationUncertainty> | undefined): boolean {
    return proto3.util.equals(LocationUncertainty, a, b);
  }
}

/**
 * Indicates ellipse characteristics and probability that an entity lies within the defined ellipse.
 *
 * @generated from message anduril.entitymanager.v1.ErrorEllipse
 */
export class ErrorEllipse extends Message<ErrorEllipse> {
  /**
   * Defines the probability in percentage that an entity lies within the given ellipse: 0-1.
   *
   * @generated from field: google.protobuf.DoubleValue probability = 1;
   */
  probability?: number;

  /**
   * Defines the distance from the center point of the ellipse to the furthest distance on the perimeter in meters.
   *
   * @generated from field: google.protobuf.DoubleValue semi_major_axis_m = 2;
   */
  semiMajorAxisM?: number;

  /**
   * Defines the distance from the center point of the ellipse to the shortest distance on the perimeter in meters.
   *
   * @generated from field: google.protobuf.DoubleValue semi_minor_axis_m = 3;
   */
  semiMinorAxisM?: number;

  /**
   * The orientation of the semi-major relative to true north in degrees from clockwise: 0-180 due to symmetry across the semi-minor axis.
   *
   * @generated from field: google.protobuf.DoubleValue orientation_d = 4;
   */
  orientationD?: number;

  constructor(data?: PartialMessage<ErrorEllipse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.ErrorEllipse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "probability", kind: "message", T: DoubleValue },
    { no: 2, name: "semi_major_axis_m", kind: "message", T: DoubleValue },
    { no: 3, name: "semi_minor_axis_m", kind: "message", T: DoubleValue },
    { no: 4, name: "orientation_d", kind: "message", T: DoubleValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorEllipse {
    return new ErrorEllipse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorEllipse {
    return new ErrorEllipse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorEllipse {
    return new ErrorEllipse().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorEllipse | PlainMessage<ErrorEllipse> | undefined, b: ErrorEllipse | PlainMessage<ErrorEllipse> | undefined): boolean {
    return proto3.util.equals(ErrorEllipse, a, b);
  }
}

/**
 * Overrides anduril.type.Pose.
 *
 * @generated from message anduril.entitymanager.v1.Pose
 */
export class Pose extends Message<Pose> {
  /**
   * Geospatial location defined by this Pose.
   *
   * @generated from field: anduril.entitymanager.v1.Position pos = 1;
   */
  pos?: Position;

  /**
   * The quaternion to transform a point in the Pose frame to the ENU frame. The Pose frame could be Body, Turret,
   * etc and is determined by the context in which this Pose is used.
   * The normal convention for defining orientation is to list the frames of transformation, for example
   * att_gimbal_to_enu is the quaternion which transforms a point in the gimbal frame to the body frame, but
   * in this case we truncate to att_enu because the Pose frame isn't defined. A potentially better name for this
   * field would have been att_pose_to_enu.
   *
   * Implementations of this quaternion should left multiply this quaternion to transform a point from the Pose frame
   * to the enu frame.
   *
   * @generated from field: anduril.type.Quaternion orientation = 2;
   */
  orientation?: Quaternion;

  constructor(data?: PartialMessage<Pose>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Pose";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pos", kind: "message", T: Position },
    { no: 2, name: "orientation", kind: "message", T: Quaternion },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pose {
    return new Pose().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pose {
    return new Pose().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pose {
    return new Pose().fromJsonString(jsonString, options);
  }

  static equals(a: Pose | PlainMessage<Pose> | undefined, b: Pose | PlainMessage<Pose> | undefined): boolean {
    return proto3.util.equals(Pose, a, b);
  }
}

/**
 * Symmetric 3d matrix only representing the upper right triangle.
 *
 * @generated from message anduril.entitymanager.v1.TMat3
 */
export class TMat3 extends Message<TMat3> {
  /**
   * @generated from field: float mxx = 1;
   */
  mxx = 0;

  /**
   * @generated from field: float mxy = 2;
   */
  mxy = 0;

  /**
   * @generated from field: float mxz = 3;
   */
  mxz = 0;

  /**
   * @generated from field: float myy = 4;
   */
  myy = 0;

  /**
   * @generated from field: float myz = 5;
   */
  myz = 0;

  /**
   * @generated from field: float mzz = 6;
   */
  mzz = 0;

  constructor(data?: PartialMessage<TMat3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.TMat3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mxx", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "mxy", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "mxz", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "myy", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "myz", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 6, name: "mzz", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TMat3 {
    return new TMat3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TMat3 {
    return new TMat3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TMat3 {
    return new TMat3().fromJsonString(jsonString, options);
  }

  static equals(a: TMat3 | PlainMessage<TMat3> | undefined, b: TMat3 | PlainMessage<TMat3> | undefined): boolean {
    return proto3.util.equals(TMat3, a, b);
  }
}

