// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/entitymanager/v1/filter.pub.proto (package anduril.entitymanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Position } from "./location.pub_pb.js";
import { GeoPolygon } from "./geoentity.pub_pb.js";

/**
 * The Comparator specifies the set of supported comparison operations. It also provides the
 * mapping information about which comparators are supported for which values. Services that wish
 * to implement entity filters must provide validation functionality to strictly enforce these
 * mappings.
 *
 * @generated from enum anduril.entitymanager.v1.Comparator
 */
export enum Comparator {
  /**
   * @generated from enum value: COMPARATOR_INVALID = 0;
   */
  INVALID = 0,

  /**
   * Comparators for: boolean, numeric, string, enum, position, timestamp, positions, and bounded shapes.
   *
   * @generated from enum value: COMPARATOR_MATCH_ALL = 11;
   */
  MATCH_ALL = 11,

  /**
   * Comparators for: boolean, numeric, string, enum, position, and timestamp.
   *
   * @generated from enum value: COMPARATOR_EQUALITY = 1;
   */
  EQUALITY = 1,

  /**
   * @generated from enum value: COMPARATOR_IN = 9;
   */
  IN = 9,

  /**
   * Comparators for: numeric, string, and timestamp.
   *
   * @generated from enum value: COMPARATOR_LESS_THAN = 2;
   */
  LESS_THAN = 2,

  /**
   * @generated from enum value: COMPARATOR_GREATER_THAN = 3;
   */
  GREATER_THAN = 3,

  /**
   * @generated from enum value: COMPARATOR_LESS_THAN_EQUAL_TO = 4;
   */
  LESS_THAN_EQUAL_TO = 4,

  /**
   * @generated from enum value: COMPARATOR_GREATER_THAN_EQUAL_TO = 5;
   */
  GREATER_THAN_EQUAL_TO = 5,

  /**
   * Comparators for: positions and bounded shapes.
   *
   * @generated from enum value: COMPARATOR_WITHIN = 6;
   */
  WITHIN = 6,

  /**
   * Comparators for: existential checks.
   * TRUE if path to field exists (parent message is present), and either:
   *   1. the field is a primitive: all values including default pass check.
   *   2. the field is a message and set/present.
   *   3. the field is repeated or map with size > 0.
   * FALSE unless path exists and one of the above 3 conditions is met
   *
   * @generated from enum value: COMPARATOR_EXISTS = 7;
   */
  EXISTS = 7,

  /**
   * Comparator for string type only.
   *
   * @generated from enum value: COMPARATOR_CASE_INSENSITIVE_EQUALITY = 8;
   */
  CASE_INSENSITIVE_EQUALITY = 8,

  /**
   * @generated from enum value: COMPARATOR_CASE_INSENSITIVE_EQUALITY_IN = 10;
   */
  CASE_INSENSITIVE_EQUALITY_IN = 10,

  /**
   * Comparators for range types only.
   * Closed (inclusive endpoints) [a, b]
   *
   * @generated from enum value: COMPARATOR_RANGE_CLOSED = 12;
   */
  RANGE_CLOSED = 12,
}
// Retrieve enum metadata with: proto3.getEnumType(Comparator)
proto3.util.setEnumType(Comparator, "anduril.entitymanager.v1.Comparator", [
  { no: 0, name: "COMPARATOR_INVALID" },
  { no: 11, name: "COMPARATOR_MATCH_ALL" },
  { no: 1, name: "COMPARATOR_EQUALITY" },
  { no: 9, name: "COMPARATOR_IN" },
  { no: 2, name: "COMPARATOR_LESS_THAN" },
  { no: 3, name: "COMPARATOR_GREATER_THAN" },
  { no: 4, name: "COMPARATOR_LESS_THAN_EQUAL_TO" },
  { no: 5, name: "COMPARATOR_GREATER_THAN_EQUAL_TO" },
  { no: 6, name: "COMPARATOR_WITHIN" },
  { no: 7, name: "COMPARATOR_EXISTS" },
  { no: 8, name: "COMPARATOR_CASE_INSENSITIVE_EQUALITY" },
  { no: 10, name: "COMPARATOR_CASE_INSENSITIVE_EQUALITY_IN" },
  { no: 12, name: "COMPARATOR_RANGE_CLOSED" },
]);

/**
 * The ListComparator determines how to compose statement evaluations for members of a list. For
 * example, if ANY_OF is specified, the ListOperation in which the ListComparator is embedded
 * will return TRUE if any of the values in the list returns true for the ListOperation's child
 * statement.
 *
 * @generated from enum anduril.entitymanager.v1.ListComparator
 */
export enum ListComparator {
  /**
   * @generated from enum value: LIST_COMPARATOR_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: LIST_COMPARATOR_ANY_OF = 1;
   */
  ANY_OF = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ListComparator)
proto3.util.setEnumType(ListComparator, "anduril.entitymanager.v1.ListComparator", [
  { no: 0, name: "LIST_COMPARATOR_INVALID" },
  { no: 1, name: "LIST_COMPARATOR_ANY_OF" },
]);

/**
 * A Statement is the building block of the entity filter. The outermost statement is conceptually
 * the root node of an "expression tree" which allows for the construction of complete boolean
 * logic statements. Statements are formed by grouping sets of children statement(s) or predicate(s)
 * according to the boolean operation which is to be applied.
 *
 * For example, the criteria "take an action if an entity is hostile and an air vehicle" can be
 * represented as: Statement1: { AndOperation: { Predicate1, Predicate2 } }. Where Statement1
 * is the root of the expression tree, with an AND operation that is applied to children
 * predicates. The predicates themselves encode "entity is hostile" and "entity is air vehicle."
 *
 * @generated from message anduril.entitymanager.v1.Statement
 */
export class Statement extends Message<Statement> {
  /**
   * @generated from oneof anduril.entitymanager.v1.Statement.operation
   */
  operation: {
    /**
     * @generated from field: anduril.entitymanager.v1.AndOperation and = 1;
     */
    value: AndOperation;
    case: "and";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.OrOperation or = 2;
     */
    value: OrOperation;
    case: "or";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.NotOperation not = 3;
     */
    value: NotOperation;
    case: "not";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.ListOperation list = 4;
     */
    value: ListOperation;
    case: "list";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.Predicate predicate = 5;
     */
    value: Predicate;
    case: "predicate";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Statement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Statement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "and", kind: "message", T: AndOperation, oneof: "operation" },
    { no: 2, name: "or", kind: "message", T: OrOperation, oneof: "operation" },
    { no: 3, name: "not", kind: "message", T: NotOperation, oneof: "operation" },
    { no: 4, name: "list", kind: "message", T: ListOperation, oneof: "operation" },
    { no: 5, name: "predicate", kind: "message", T: Predicate, oneof: "operation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Statement {
    return new Statement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Statement {
    return new Statement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Statement {
    return new Statement().fromJsonString(jsonString, options);
  }

  static equals(a: Statement | PlainMessage<Statement> | undefined, b: Statement | PlainMessage<Statement> | undefined): boolean {
    return proto3.util.equals(Statement, a, b);
  }
}

/**
 * The AndOperation represents the boolean AND operation, which is to be applied to the list of
 * children statement(s) or predicate(s).
 *
 * @generated from message anduril.entitymanager.v1.AndOperation
 */
export class AndOperation extends Message<AndOperation> {
  /**
   * @generated from oneof anduril.entitymanager.v1.AndOperation.children
   */
  children: {
    /**
     * @generated from field: anduril.entitymanager.v1.PredicateSet predicate_set = 1;
     */
    value: PredicateSet;
    case: "predicateSet";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.StatementSet statement_set = 2;
     */
    value: StatementSet;
    case: "statementSet";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AndOperation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.AndOperation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicate_set", kind: "message", T: PredicateSet, oneof: "children" },
    { no: 2, name: "statement_set", kind: "message", T: StatementSet, oneof: "children" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AndOperation {
    return new AndOperation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AndOperation {
    return new AndOperation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AndOperation {
    return new AndOperation().fromJsonString(jsonString, options);
  }

  static equals(a: AndOperation | PlainMessage<AndOperation> | undefined, b: AndOperation | PlainMessage<AndOperation> | undefined): boolean {
    return proto3.util.equals(AndOperation, a, b);
  }
}

/**
 * The OrOperation represents the boolean OR operation, which is to be applied to the list of
 * children statement(s) or predicate(s).
 *
 * @generated from message anduril.entitymanager.v1.OrOperation
 */
export class OrOperation extends Message<OrOperation> {
  /**
   * @generated from oneof anduril.entitymanager.v1.OrOperation.children
   */
  children: {
    /**
     * @generated from field: anduril.entitymanager.v1.PredicateSet predicate_set = 1;
     */
    value: PredicateSet;
    case: "predicateSet";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.StatementSet statement_set = 2;
     */
    value: StatementSet;
    case: "statementSet";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<OrOperation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.OrOperation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicate_set", kind: "message", T: PredicateSet, oneof: "children" },
    { no: 2, name: "statement_set", kind: "message", T: StatementSet, oneof: "children" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrOperation {
    return new OrOperation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrOperation {
    return new OrOperation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrOperation {
    return new OrOperation().fromJsonString(jsonString, options);
  }

  static equals(a: OrOperation | PlainMessage<OrOperation> | undefined, b: OrOperation | PlainMessage<OrOperation> | undefined): boolean {
    return proto3.util.equals(OrOperation, a, b);
  }
}

/**
 * The NotOperation represents the boolean NOT operation, which can only be applied to a single
 * child predicate or statement.
 *
 * @generated from message anduril.entitymanager.v1.NotOperation
 */
export class NotOperation extends Message<NotOperation> {
  /**
   * @generated from oneof anduril.entitymanager.v1.NotOperation.child
   */
  child: {
    /**
     * @generated from field: anduril.entitymanager.v1.Predicate predicate = 1;
     */
    value: Predicate;
    case: "predicate";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.Statement statement = 2;
     */
    value: Statement;
    case: "statement";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<NotOperation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.NotOperation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicate", kind: "message", T: Predicate, oneof: "child" },
    { no: 2, name: "statement", kind: "message", T: Statement, oneof: "child" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotOperation {
    return new NotOperation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotOperation {
    return new NotOperation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotOperation {
    return new NotOperation().fromJsonString(jsonString, options);
  }

  static equals(a: NotOperation | PlainMessage<NotOperation> | undefined, b: NotOperation | PlainMessage<NotOperation> | undefined): boolean {
    return proto3.util.equals(NotOperation, a, b);
  }
}

/**
 * The ListOperation represents an operation against a proto list. If the list is of primitive proto
 * type (e.g. int32), paths in all child predicates should be left empty. If the list is of message
 * proto type (e.g. Sensor), paths in all child predicates should be relative to the list path.
 *
 * For example, the criteria "take an action if an entity has any sensor with sensor_id='sensor' and
 * OperationalState=STATE_OFF" would be modeled as:
 * Predicate1: { path: "sensor_id", comparator: EQUAL_TO, value: "sensor" }
 * Predicate2: { path: "operational_state", comparator: EQUAL_TO, value: STATE_OFF }
 *
 * Statement2: { AndOperation: PredicateSet: { <Predicate1>, <Predicate2> } }
 * ListOperation: { list_path: "sensors.sensors", list_comparator: ANY, statement: <Statement2> }
 * Statement1: { ListOperation: <ListOperation> }
 *
 * Note that in the above, the child predicates of the list operation have paths relative to the
 * list_path because the list is comprised of message not primitive types.
 *
 * @generated from message anduril.entitymanager.v1.ListOperation
 */
export class ListOperation extends Message<ListOperation> {
  /**
   * The list_path specifies the repeated field on an entity to which this operation applies.
   *
   * @generated from field: string list_path = 1;
   */
  listPath = "";

  /**
   * The list_comparator specifies how to compose the boolean results from the child statement
   * for each member of the specified list.
   *
   * @generated from field: anduril.entitymanager.v1.ListComparator list_comparator = 2;
   */
  listComparator = ListComparator.INVALID;

  /**
   * The statement is a new expression tree conceptually rooted at type of the list. It determines
   * how each member of the list is evaluated.
   *
   * @generated from field: anduril.entitymanager.v1.Statement statement = 3;
   */
  statement?: Statement;

  constructor(data?: PartialMessage<ListOperation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.ListOperation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "list_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "list_comparator", kind: "enum", T: proto3.getEnumType(ListComparator) },
    { no: 3, name: "statement", kind: "message", T: Statement },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListOperation {
    return new ListOperation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListOperation {
    return new ListOperation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListOperation {
    return new ListOperation().fromJsonString(jsonString, options);
  }

  static equals(a: ListOperation | PlainMessage<ListOperation> | undefined, b: ListOperation | PlainMessage<ListOperation> | undefined): boolean {
    return proto3.util.equals(ListOperation, a, b);
  }
}

/**
 * The PredicateSet represents a list of predicates or "leaf nodes" in the expression tree, which
 * can be directly evaluated to a boolean TRUE/FALSE result.
 *
 * @generated from message anduril.entitymanager.v1.PredicateSet
 */
export class PredicateSet extends Message<PredicateSet> {
  /**
   * @generated from field: repeated anduril.entitymanager.v1.Predicate predicates = 1;
   */
  predicates: Predicate[] = [];

  constructor(data?: PartialMessage<PredicateSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.PredicateSet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicates", kind: "message", T: Predicate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PredicateSet {
    return new PredicateSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PredicateSet {
    return new PredicateSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PredicateSet {
    return new PredicateSet().fromJsonString(jsonString, options);
  }

  static equals(a: PredicateSet | PlainMessage<PredicateSet> | undefined, b: PredicateSet | PlainMessage<PredicateSet> | undefined): boolean {
    return proto3.util.equals(PredicateSet, a, b);
  }
}

/**
 * The StatementSet represents a list of statements or "tree nodes," each of which follow the same
 * behavior as the Statement proto message.
 *
 * @generated from message anduril.entitymanager.v1.StatementSet
 */
export class StatementSet extends Message<StatementSet> {
  /**
   * @generated from field: repeated anduril.entitymanager.v1.Statement statements = 1;
   */
  statements: Statement[] = [];

  constructor(data?: PartialMessage<StatementSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.StatementSet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "statements", kind: "message", T: Statement, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatementSet {
    return new StatementSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatementSet {
    return new StatementSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatementSet {
    return new StatementSet().fromJsonString(jsonString, options);
  }

  static equals(a: StatementSet | PlainMessage<StatementSet> | undefined, b: StatementSet | PlainMessage<StatementSet> | undefined): boolean {
    return proto3.util.equals(StatementSet, a, b);
  }
}

/**
 * The Predicate fully encodes the information required to make an evaluation of an entity field
 * against a given static value, resulting in a boolean TRUE/FALSE result. The structure of a
 * predicate will always follow: "{entity-value} {comparator} {fixed-value}" where the entity value
 * is determined by the field path.
 *
 * For example, a predicate would read as: "{entity.location.velocity_enu} {LESS_THAN} {500kph}"
 *
 * @generated from message anduril.entitymanager.v1.Predicate
 */
export class Predicate extends Message<Predicate> {
  /**
   * The field_path determines which field on an entity is being referenced in this predicate. For
   * example: correlated.primary_entity_id would be primary_entity_id in correlated component.
   *
   * @generated from field: string field_path = 1;
   */
  fieldPath = "";

  /**
   * The value determines the fixed value against which the entity field is to be compared.
   * In the case of COMPARATOR_MATCH_ALL, the value contents do not matter as long as the Value is a supported
   * type.
   *
   * @generated from field: anduril.entitymanager.v1.Value value = 2;
   */
  value?: Value;

  /**
   * The comparator determines the manner in which the entity field and static value are compared.
   * Comparators may only be applied to certain values. For example, the WITHIN comparator cannot
   * be used for a boolean value comparison.
   *
   * @generated from field: anduril.entitymanager.v1.Comparator comparator = 3;
   */
  comparator = Comparator.INVALID;

  constructor(data?: PartialMessage<Predicate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Predicate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "message", T: Value },
    { no: 3, name: "comparator", kind: "enum", T: proto3.getEnumType(Comparator) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Predicate {
    return new Predicate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Predicate {
    return new Predicate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Predicate {
    return new Predicate().fromJsonString(jsonString, options);
  }

  static equals(a: Predicate | PlainMessage<Predicate> | undefined, b: Predicate | PlainMessage<Predicate> | undefined): boolean {
    return proto3.util.equals(Predicate, a, b);
  }
}

/**
 * The Value represents the information against which an entity field is evaluated. It is one of
 * a fixed set of types, each of which correspond to specific comparators. See "ComparatorType"
 * for the full list of Value <-> Comparator mappings.
 *
 * @generated from message anduril.entitymanager.v1.Value
 */
export class Value extends Message<Value> {
  /**
   * @generated from oneof anduril.entitymanager.v1.Value.type
   */
  type: {
    /**
     * @generated from field: anduril.entitymanager.v1.BooleanType boolean_type = 1;
     */
    value: BooleanType;
    case: "booleanType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.NumericType numeric_type = 2;
     */
    value: NumericType;
    case: "numericType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.StringType string_type = 3;
     */
    value: StringType;
    case: "stringType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.EnumType enum_type = 4;
     */
    value: EnumType;
    case: "enumType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.TimestampType timestamp_type = 5;
     */
    value: TimestampType;
    case: "timestampType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.BoundedShapeType bounded_shape_type = 6;
     */
    value: BoundedShapeType;
    case: "boundedShapeType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.PositionType position_type = 7;
     */
    value: PositionType;
    case: "positionType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.HeadingType heading_type = 8;
     */
    value: HeadingType;
    case: "headingType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.ListType list_type = 9;
     */
    value: ListType;
    case: "listType";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.RangeType range_type = 10;
     */
    value: RangeType;
    case: "rangeType";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Value>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Value";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "boolean_type", kind: "message", T: BooleanType, oneof: "type" },
    { no: 2, name: "numeric_type", kind: "message", T: NumericType, oneof: "type" },
    { no: 3, name: "string_type", kind: "message", T: StringType, oneof: "type" },
    { no: 4, name: "enum_type", kind: "message", T: EnumType, oneof: "type" },
    { no: 5, name: "timestamp_type", kind: "message", T: TimestampType, oneof: "type" },
    { no: 6, name: "bounded_shape_type", kind: "message", T: BoundedShapeType, oneof: "type" },
    { no: 7, name: "position_type", kind: "message", T: PositionType, oneof: "type" },
    { no: 8, name: "heading_type", kind: "message", T: HeadingType, oneof: "type" },
    { no: 9, name: "list_type", kind: "message", T: ListType, oneof: "type" },
    { no: 10, name: "range_type", kind: "message", T: RangeType, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Value {
    return new Value().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Value {
    return new Value().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Value {
    return new Value().fromJsonString(jsonString, options);
  }

  static equals(a: Value | PlainMessage<Value> | undefined, b: Value | PlainMessage<Value> | undefined): boolean {
    return proto3.util.equals(Value, a, b);
  }
}

/**
 * The BooleanType represents a static boolean value.
 *
 * @generated from message anduril.entitymanager.v1.BooleanType
 */
export class BooleanType extends Message<BooleanType> {
  /**
   * @generated from field: bool value = 1;
   */
  value = false;

  constructor(data?: PartialMessage<BooleanType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.BooleanType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BooleanType {
    return new BooleanType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BooleanType {
    return new BooleanType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BooleanType {
    return new BooleanType().fromJsonString(jsonString, options);
  }

  static equals(a: BooleanType | PlainMessage<BooleanType> | undefined, b: BooleanType | PlainMessage<BooleanType> | undefined): boolean {
    return proto3.util.equals(BooleanType, a, b);
  }
}

/**
 * The NumericType represents static numeric values. It supports all numeric primitives supported
 * by the proto3 language specification.
 *
 * @generated from message anduril.entitymanager.v1.NumericType
 */
export class NumericType extends Message<NumericType> {
  /**
   * @generated from oneof anduril.entitymanager.v1.NumericType.value
   */
  value: {
    /**
     * @generated from field: double double_value = 1;
     */
    value: number;
    case: "doubleValue";
  } | {
    /**
     * @generated from field: float float_value = 2;
     */
    value: number;
    case: "floatValue";
  } | {
    /**
     * @generated from field: int32 int32_value = 3;
     */
    value: number;
    case: "int32Value";
  } | {
    /**
     * @generated from field: int64 int64_value = 4;
     */
    value: bigint;
    case: "int64Value";
  } | {
    /**
     * @generated from field: uint32 uint32_value = 5;
     */
    value: number;
    case: "uint32Value";
  } | {
    /**
     * @generated from field: uint64 uint64_value = 6;
     */
    value: bigint;
    case: "uint64Value";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<NumericType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.NumericType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "double_value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "value" },
    { no: 2, name: "float_value", kind: "scalar", T: 2 /* ScalarType.FLOAT */, oneof: "value" },
    { no: 3, name: "int32_value", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "value" },
    { no: 4, name: "int64_value", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "value" },
    { no: 5, name: "uint32_value", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "value" },
    { no: 6, name: "uint64_value", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NumericType {
    return new NumericType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NumericType {
    return new NumericType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NumericType {
    return new NumericType().fromJsonString(jsonString, options);
  }

  static equals(a: NumericType | PlainMessage<NumericType> | undefined, b: NumericType | PlainMessage<NumericType> | undefined): boolean {
    return proto3.util.equals(NumericType, a, b);
  }
}

/**
 * The StringType represents static string values.
 *
 * @generated from message anduril.entitymanager.v1.StringType
 */
export class StringType extends Message<StringType> {
  /**
   * @generated from field: string value = 1;
   */
  value = "";

  constructor(data?: PartialMessage<StringType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.StringType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringType {
    return new StringType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringType {
    return new StringType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringType {
    return new StringType().fromJsonString(jsonString, options);
  }

  static equals(a: StringType | PlainMessage<StringType> | undefined, b: StringType | PlainMessage<StringType> | undefined): boolean {
    return proto3.util.equals(StringType, a, b);
  }
}

/**
 * The EnumType represents members of well-known anduril ontologies, such as "disposition." When
 * such a value is specified, the evaluation library expects the integer representation of the enum
 * value. For example, a disposition derived from ontology.v1 such as "DISPOSITION_HOSTILE" should be
 * represented with the integer value 2.
 *
 * @generated from message anduril.entitymanager.v1.EnumType
 */
export class EnumType extends Message<EnumType> {
  /**
   * @generated from field: int32 value = 1;
   */
  value = 0;

  constructor(data?: PartialMessage<EnumType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.EnumType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnumType {
    return new EnumType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnumType {
    return new EnumType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnumType {
    return new EnumType().fromJsonString(jsonString, options);
  }

  static equals(a: EnumType | PlainMessage<EnumType> | undefined, b: EnumType | PlainMessage<EnumType> | undefined): boolean {
    return proto3.util.equals(EnumType, a, b);
  }
}

/**
 * A List of Values for use with the IN comparator.
 *
 * @generated from message anduril.entitymanager.v1.ListType
 */
export class ListType extends Message<ListType> {
  /**
   * @generated from field: repeated anduril.entitymanager.v1.Value values = 1;
   */
  values: Value[] = [];

  constructor(data?: PartialMessage<ListType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.ListType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "message", T: Value, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListType {
    return new ListType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListType {
    return new ListType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListType {
    return new ListType().fromJsonString(jsonString, options);
  }

  static equals(a: ListType | PlainMessage<ListType> | undefined, b: ListType | PlainMessage<ListType> | undefined): boolean {
    return proto3.util.equals(ListType, a, b);
  }
}

/**
 * The TimestampType represents a static timestamp value.
 *
 * @generated from message anduril.entitymanager.v1.TimestampType
 */
export class TimestampType extends Message<TimestampType> {
  /**
   * @generated from field: google.protobuf.Timestamp value = 1;
   */
  value?: Timestamp;

  constructor(data?: PartialMessage<TimestampType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.TimestampType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimestampType {
    return new TimestampType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimestampType {
    return new TimestampType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimestampType {
    return new TimestampType().fromJsonString(jsonString, options);
  }

  static equals(a: TimestampType | PlainMessage<TimestampType> | undefined, b: TimestampType | PlainMessage<TimestampType> | undefined): boolean {
    return proto3.util.equals(TimestampType, a, b);
  }
}

/**
 * The PositionType represents any fixed LLA point in space.
 *
 * @generated from message anduril.entitymanager.v1.PositionType
 */
export class PositionType extends Message<PositionType> {
  /**
   * @generated from field: anduril.entitymanager.v1.Position value = 1;
   */
  value?: Position;

  constructor(data?: PartialMessage<PositionType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.PositionType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "message", T: Position },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PositionType {
    return new PositionType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PositionType {
    return new PositionType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PositionType {
    return new PositionType().fromJsonString(jsonString, options);
  }

  static equals(a: PositionType | PlainMessage<PositionType> | undefined, b: PositionType | PlainMessage<PositionType> | undefined): boolean {
    return proto3.util.equals(PositionType, a, b);
  }
}

/**
 * The BoundedShapeType represents any static fully-enclosed shape.
 *
 * @generated from message anduril.entitymanager.v1.BoundedShapeType
 */
export class BoundedShapeType extends Message<BoundedShapeType> {
  /**
   * @generated from oneof anduril.entitymanager.v1.BoundedShapeType.value
   */
  value: {
    /**
     * @generated from field: anduril.entitymanager.v1.GeoPolygon polygon_value = 1;
     */
    value: GeoPolygon;
    case: "polygonValue";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<BoundedShapeType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.BoundedShapeType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "polygon_value", kind: "message", T: GeoPolygon, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BoundedShapeType {
    return new BoundedShapeType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BoundedShapeType {
    return new BoundedShapeType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BoundedShapeType {
    return new BoundedShapeType().fromJsonString(jsonString, options);
  }

  static equals(a: BoundedShapeType | PlainMessage<BoundedShapeType> | undefined, b: BoundedShapeType | PlainMessage<BoundedShapeType> | undefined): boolean {
    return proto3.util.equals(BoundedShapeType, a, b);
  }
}

/**
 * The HeadingType represents the heading in degrees for an entity's
 * attitudeEnu quaternion to be compared against. Defaults between a range of 0 to 360
 *
 * @generated from message anduril.entitymanager.v1.HeadingType
 */
export class HeadingType extends Message<HeadingType> {
  /**
   * @generated from field: int32 value = 1;
   */
  value = 0;

  constructor(data?: PartialMessage<HeadingType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.HeadingType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeadingType {
    return new HeadingType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeadingType {
    return new HeadingType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeadingType {
    return new HeadingType().fromJsonString(jsonString, options);
  }

  static equals(a: HeadingType | PlainMessage<HeadingType> | undefined, b: HeadingType | PlainMessage<HeadingType> | undefined): boolean {
    return proto3.util.equals(HeadingType, a, b);
  }
}

/**
 * The RangeType represents a numeric range.
 * Whether endpoints are included are based on the comparator used.
 * Both endpoints must be of the same numeric type.
 *
 * @generated from message anduril.entitymanager.v1.RangeType
 */
export class RangeType extends Message<RangeType> {
  /**
   * @generated from field: anduril.entitymanager.v1.NumericType start = 1;
   */
  start?: NumericType;

  /**
   * @generated from field: anduril.entitymanager.v1.NumericType end = 2;
   */
  end?: NumericType;

  constructor(data?: PartialMessage<RangeType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.RangeType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "message", T: NumericType },
    { no: 2, name: "end", kind: "message", T: NumericType },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RangeType {
    return new RangeType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RangeType {
    return new RangeType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RangeType {
    return new RangeType().fromJsonString(jsonString, options);
  }

  static equals(a: RangeType | PlainMessage<RangeType> | undefined, b: RangeType | PlainMessage<RangeType> | undefined): boolean {
    return proto3.util.equals(RangeType, a, b);
  }
}

