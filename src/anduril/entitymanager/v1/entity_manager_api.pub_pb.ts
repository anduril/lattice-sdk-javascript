// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/entitymanager/v1/entity_manager_api.pub.proto (package anduril.entitymanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Entity, Provenance } from "./entity.pub_pb.js";
import { Statement } from "./filter.pub_pb.js";
import { RateLimit } from "./rate_limit.pub_pb.js";
import { OverrideStatus } from "./types.pub_pb.js";

/**
 * The type of entity event.
 *
 * @generated from enum anduril.entitymanager.v1.EventType
 */
export enum EventType {
  /**
   * @generated from enum value: EVENT_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * entity was created.
   *
   * @generated from enum value: EVENT_TYPE_CREATED = 1;
   */
  CREATED = 1,

  /**
   * entity was updated.
   *
   * @generated from enum value: EVENT_TYPE_UPDATE = 2;
   */
  UPDATE = 2,

  /**
   * entity was deleted.
   *
   * @generated from enum value: EVENT_TYPE_DELETED = 3;
   */
  DELETED = 3,

  /**
   * entity already existed, but sent on a new stream connection.
   *
   * @generated from enum value: EVENT_TYPE_PREEXISTING = 4;
   */
  PREEXISTING = 4,

  /**
   * entity override was set after the entity expiration.
   *
   * @generated from enum value: EVENT_TYPE_POST_EXPIRY_OVERRIDE = 5;
   */
  POST_EXPIRY_OVERRIDE = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(EventType)
proto3.util.setEnumType(EventType, "anduril.entitymanager.v1.EventType", [
  { no: 0, name: "EVENT_TYPE_INVALID" },
  { no: 1, name: "EVENT_TYPE_CREATED" },
  { no: 2, name: "EVENT_TYPE_UPDATE" },
  { no: 3, name: "EVENT_TYPE_DELETED" },
  { no: 4, name: "EVENT_TYPE_PREEXISTING" },
  { no: 5, name: "EVENT_TYPE_POST_EXPIRY_OVERRIDE" },
]);

/**
 * @generated from message anduril.entitymanager.v1.GetEntityRequest
 */
export class GetEntityRequest extends Message<GetEntityRequest> {
  /**
   * the GUID of this entity to query
   *
   * @generated from field: string entity_id = 1;
   */
  entityId = "";

  constructor(data?: PartialMessage<GetEntityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.GetEntityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetEntityRequest {
    return new GetEntityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetEntityRequest {
    return new GetEntityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetEntityRequest {
    return new GetEntityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetEntityRequest | PlainMessage<GetEntityRequest> | undefined, b: GetEntityRequest | PlainMessage<GetEntityRequest> | undefined): boolean {
    return proto3.util.equals(GetEntityRequest, a, b);
  }
}

/**
 * @generated from message anduril.entitymanager.v1.GetEntityResponse
 */
export class GetEntityResponse extends Message<GetEntityResponse> {
  /**
   * an Entity object that corresponds with the requested entityId
   *
   * @generated from field: anduril.entitymanager.v1.Entity entity = 1;
   */
  entity?: Entity;

  constructor(data?: PartialMessage<GetEntityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.GetEntityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity", kind: "message", T: Entity },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetEntityResponse {
    return new GetEntityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetEntityResponse {
    return new GetEntityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetEntityResponse {
    return new GetEntityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetEntityResponse | PlainMessage<GetEntityResponse> | undefined, b: GetEntityResponse | PlainMessage<GetEntityResponse> | undefined): boolean {
    return proto3.util.equals(GetEntityResponse, a, b);
  }
}

/**
 * @generated from message anduril.entitymanager.v1.StreamEntityComponentsRequest
 */
export class StreamEntityComponentsRequest extends Message<StreamEntityComponentsRequest> {
  /**
   * lower_snake_cased component names to include in response events, e.g. location. Only included components will
   * populate.
   *
   * @generated from field: repeated string components_to_include = 1;
   */
  componentsToInclude: string[] = [];

  /**
   * subscribe to all components. This should only be used in cases where you want all components (e.g. latticectl) and
   * if you're using it for other services please reach out first. Setting both components_to_include and
   * include_all_components is invalid and will be rejected.
   *
   * @generated from field: bool include_all_components = 2;
   */
  includeAllComponents = false;

  /**
   * The root node of a statement filter "tree".
   * If provided, only entities matching the filter criteria will be streamed. The filter is applied dynamically so if a
   * new entity matches, it will be included, and if an entity updates to no longer match, it will be excluded.
   *
   * @generated from field: anduril.entitymanager.v1.Statement filter = 3;
   */
  filter?: Statement;

  /**
   * optional rate-limiting / down-sampling parameters, see RateLimit message for details.
   *
   * @generated from field: anduril.entitymanager.v1.RateLimit rate_limit = 4;
   */
  rateLimit?: RateLimit;

  /**
   * The period (in milliseconds) at which a Heartbeat message will be sent on the
   * message stream. If this field is set to 0 then no Heartbeat messages are sent.
   *
   * @generated from field: uint32 heartbeat_period_millis = 5;
   */
  heartbeatPeriodMillis = 0;

  /**
   * subscribe to a finite stream of preexisting events which closes when there are no additional pre-existing events to
   * process. Respects the filter specified on the StreamEntityComponentsRequest.
   *
   * @generated from field: bool preexisting_only = 6;
   */
  preexistingOnly = false;

  constructor(data?: PartialMessage<StreamEntityComponentsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.StreamEntityComponentsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "components_to_include", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "include_all_components", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "filter", kind: "message", T: Statement },
    { no: 4, name: "rate_limit", kind: "message", T: RateLimit },
    { no: 5, name: "heartbeat_period_millis", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "preexisting_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamEntityComponentsRequest {
    return new StreamEntityComponentsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamEntityComponentsRequest {
    return new StreamEntityComponentsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamEntityComponentsRequest {
    return new StreamEntityComponentsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamEntityComponentsRequest | PlainMessage<StreamEntityComponentsRequest> | undefined, b: StreamEntityComponentsRequest | PlainMessage<StreamEntityComponentsRequest> | undefined): boolean {
    return proto3.util.equals(StreamEntityComponentsRequest, a, b);
  }
}

/**
 * response stream will be fed all matching pre-existing live entities as CREATED, plus any new events ongoing.
 *
 * @generated from message anduril.entitymanager.v1.StreamEntityComponentsResponse
 */
export class StreamEntityComponentsResponse extends Message<StreamEntityComponentsResponse> {
  /**
   * @generated from field: anduril.entitymanager.v1.EntityEvent entity_event = 1;
   */
  entityEvent?: EntityEvent;

  /**
   * @generated from field: anduril.entitymanager.v1.Heartbeat heartbeat = 2;
   */
  heartbeat?: Heartbeat;

  constructor(data?: PartialMessage<StreamEntityComponentsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.StreamEntityComponentsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_event", kind: "message", T: EntityEvent },
    { no: 2, name: "heartbeat", kind: "message", T: Heartbeat },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamEntityComponentsResponse {
    return new StreamEntityComponentsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamEntityComponentsResponse {
    return new StreamEntityComponentsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamEntityComponentsResponse {
    return new StreamEntityComponentsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamEntityComponentsResponse | PlainMessage<StreamEntityComponentsResponse> | undefined, b: StreamEntityComponentsResponse | PlainMessage<StreamEntityComponentsResponse> | undefined): boolean {
    return proto3.util.equals(StreamEntityComponentsResponse, a, b);
  }
}

/**
 * @generated from message anduril.entitymanager.v1.PutEntityRequest
 */
export class PutEntityRequest extends Message<PutEntityRequest> {
  /**
   * The entity to put.
   * Required fields:
   *   * expiry_time - must be in the future, but less than 30 days from now
   *   * provenance.data_type
   *   * provenance.source_update_time (can be earlier than rpc call if data entered is older)
   *   * aliases.name
   *   * ontology.template
   * any additional required fields will be determined by template, see com.anduril.entitymanager.v1.Template
   * if an entity_id is provided, will treat as update, otherwise create
   *
   * @generated from field: anduril.entitymanager.v1.Entity entity = 1;
   */
  entity?: Entity;

  /**
   * An optional unique identifier for this entity supplied by integration.
   * If provided, EntityId will be determined via consistent hash with provenance.data_type + unique_id
   *
   * @generated from field: string unique_id = 2;
   */
  uniqueId = "";

  constructor(data?: PartialMessage<PutEntityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.PutEntityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity", kind: "message", T: Entity },
    { no: 2, name: "unique_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PutEntityRequest {
    return new PutEntityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PutEntityRequest {
    return new PutEntityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PutEntityRequest {
    return new PutEntityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PutEntityRequest | PlainMessage<PutEntityRequest> | undefined, b: PutEntityRequest | PlainMessage<PutEntityRequest> | undefined): boolean {
    return proto3.util.equals(PutEntityRequest, a, b);
  }
}

/**
 * @generated from message anduril.entitymanager.v1.PutEntityResponse
 */
export class PutEntityResponse extends Message<PutEntityResponse> {
  /**
   * The updated entity.
   * Automatically updated fields:
   *   * is_live - always reset to true
   *   * entity_id - new GUID on create
   *   * created_time - set on create
   *
   * @generated from field: anduril.entitymanager.v1.Entity entity = 1;
   */
  entity?: Entity;

  constructor(data?: PartialMessage<PutEntityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.PutEntityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity", kind: "message", T: Entity },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PutEntityResponse {
    return new PutEntityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PutEntityResponse {
    return new PutEntityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PutEntityResponse {
    return new PutEntityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PutEntityResponse | PlainMessage<PutEntityResponse> | undefined, b: PutEntityResponse | PlainMessage<PutEntityResponse> | undefined): boolean {
    return proto3.util.equals(PutEntityResponse, a, b);
  }
}

/**
 * @generated from message anduril.entitymanager.v1.PublishEntitiesRequest
 */
export class PublishEntitiesRequest extends Message<PublishEntitiesRequest> {
  /**
   * Stream of fully formed entities to publish
   * Required fields per entity:
   *   * expiry_time - must be in the future, but less than 30 days from now
   *   * provenance.data_type
   *   * provenance.source_update_time (can be earlier than rpc call if data entered is older)
   *   * aliases.name
   *   * ontology.template
   * any additional required fields will be determined by template, see com.anduril.entitymanager.v1.Template
   * if an entity_id is provided, will treat as update, otherwise create
   *
   * @generated from field: anduril.entitymanager.v1.Entity entity = 1;
   */
  entity?: Entity;

  constructor(data?: PartialMessage<PublishEntitiesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.PublishEntitiesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity", kind: "message", T: Entity },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishEntitiesRequest {
    return new PublishEntitiesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishEntitiesRequest {
    return new PublishEntitiesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishEntitiesRequest {
    return new PublishEntitiesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PublishEntitiesRequest | PlainMessage<PublishEntitiesRequest> | undefined, b: PublishEntitiesRequest | PlainMessage<PublishEntitiesRequest> | undefined): boolean {
    return proto3.util.equals(PublishEntitiesRequest, a, b);
  }
}

/**
 * After the stream is closed the server will return an empty message indicating success. If any streamed message
 * caused an error then the stream is immediately terminated and an error code is returned.
 *
 * @generated from message anduril.entitymanager.v1.PublishEntitiesResponse
 */
export class PublishEntitiesResponse extends Message<PublishEntitiesResponse> {
  constructor(data?: PartialMessage<PublishEntitiesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.PublishEntitiesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishEntitiesResponse {
    return new PublishEntitiesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishEntitiesResponse {
    return new PublishEntitiesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishEntitiesResponse {
    return new PublishEntitiesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PublishEntitiesResponse | PlainMessage<PublishEntitiesResponse> | undefined, b: PublishEntitiesResponse | PlainMessage<PublishEntitiesResponse> | undefined): boolean {
    return proto3.util.equals(PublishEntitiesResponse, a, b);
  }
}

/**
 * @generated from message anduril.entitymanager.v1.OverrideEntityRequest
 */
export class OverrideEntityRequest extends Message<OverrideEntityRequest> {
  /**
   * The entity containing the overwritten fields. The service will extract the overridable fields from the entity
   * object and ignore any other fields.
   *
   * @generated from field: anduril.entitymanager.v1.Entity entity = 1;
   */
  entity?: Entity;

  /**
   * The field paths that will be extracted from the Entity and saved as an override. Only fields marked overridable can
   * be overriden.
   *
   * @generated from field: repeated string field_path = 2;
   */
  fieldPath: string[] = [];

  /**
   * Additional information about the source of the override
   *
   * @generated from field: anduril.entitymanager.v1.Provenance provenance = 3;
   */
  provenance?: Provenance;

  constructor(data?: PartialMessage<OverrideEntityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.OverrideEntityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity", kind: "message", T: Entity },
    { no: 2, name: "field_path", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "provenance", kind: "message", T: Provenance },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OverrideEntityRequest {
    return new OverrideEntityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OverrideEntityRequest {
    return new OverrideEntityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OverrideEntityRequest {
    return new OverrideEntityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: OverrideEntityRequest | PlainMessage<OverrideEntityRequest> | undefined, b: OverrideEntityRequest | PlainMessage<OverrideEntityRequest> | undefined): boolean {
    return proto3.util.equals(OverrideEntityRequest, a, b);
  }
}

/**
 * @generated from message anduril.entitymanager.v1.OverrideEntityResponse
 */
export class OverrideEntityResponse extends Message<OverrideEntityResponse> {
  /**
   * The status of the override request.
   *
   * @generated from field: anduril.entitymanager.v1.OverrideStatus status = 1;
   */
  status = OverrideStatus.INVALID;

  constructor(data?: PartialMessage<OverrideEntityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.OverrideEntityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(OverrideStatus) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OverrideEntityResponse {
    return new OverrideEntityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OverrideEntityResponse {
    return new OverrideEntityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OverrideEntityResponse {
    return new OverrideEntityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: OverrideEntityResponse | PlainMessage<OverrideEntityResponse> | undefined, b: OverrideEntityResponse | PlainMessage<OverrideEntityResponse> | undefined): boolean {
    return proto3.util.equals(OverrideEntityResponse, a, b);
  }
}

/**
 * @generated from message anduril.entitymanager.v1.RemoveEntityOverrideRequest
 */
export class RemoveEntityOverrideRequest extends Message<RemoveEntityOverrideRequest> {
  /**
   * The entity ID that the override will be removed from
   *
   * @generated from field: string entity_id = 1;
   */
  entityId = "";

  /**
   * The field paths to remove from the override store for the provided entityId.
   *
   * @generated from field: repeated string field_path = 2;
   */
  fieldPath: string[] = [];

  constructor(data?: PartialMessage<RemoveEntityOverrideRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.RemoveEntityOverrideRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_path", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveEntityOverrideRequest {
    return new RemoveEntityOverrideRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveEntityOverrideRequest {
    return new RemoveEntityOverrideRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveEntityOverrideRequest {
    return new RemoveEntityOverrideRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveEntityOverrideRequest | PlainMessage<RemoveEntityOverrideRequest> | undefined, b: RemoveEntityOverrideRequest | PlainMessage<RemoveEntityOverrideRequest> | undefined): boolean {
    return proto3.util.equals(RemoveEntityOverrideRequest, a, b);
  }
}

/**
 * void response but with placeholder for future optional fields.
 *
 * @generated from message anduril.entitymanager.v1.RemoveEntityOverrideResponse
 */
export class RemoveEntityOverrideResponse extends Message<RemoveEntityOverrideResponse> {
  constructor(data?: PartialMessage<RemoveEntityOverrideResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.RemoveEntityOverrideResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveEntityOverrideResponse {
    return new RemoveEntityOverrideResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveEntityOverrideResponse {
    return new RemoveEntityOverrideResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveEntityOverrideResponse {
    return new RemoveEntityOverrideResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveEntityOverrideResponse | PlainMessage<RemoveEntityOverrideResponse> | undefined, b: RemoveEntityOverrideResponse | PlainMessage<RemoveEntityOverrideResponse> | undefined): boolean {
    return proto3.util.equals(RemoveEntityOverrideResponse, a, b);
  }
}

/**
 * @generated from message anduril.entitymanager.v1.DeleteEntityRequest
 */
export class DeleteEntityRequest extends Message<DeleteEntityRequest> {
  /**
   * @generated from field: string entity_id = 1;
   */
  entityId = "";

  constructor(data?: PartialMessage<DeleteEntityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.DeleteEntityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteEntityRequest {
    return new DeleteEntityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteEntityRequest {
    return new DeleteEntityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteEntityRequest {
    return new DeleteEntityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteEntityRequest | PlainMessage<DeleteEntityRequest> | undefined, b: DeleteEntityRequest | PlainMessage<DeleteEntityRequest> | undefined): boolean {
    return proto3.util.equals(DeleteEntityRequest, a, b);
  }
}

/**
 * void response but with placeholder for future optional fields.
 *
 * @generated from message anduril.entitymanager.v1.DeleteEntityResponse
 */
export class DeleteEntityResponse extends Message<DeleteEntityResponse> {
  constructor(data?: PartialMessage<DeleteEntityResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.DeleteEntityResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteEntityResponse {
    return new DeleteEntityResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteEntityResponse {
    return new DeleteEntityResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteEntityResponse {
    return new DeleteEntityResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteEntityResponse | PlainMessage<DeleteEntityResponse> | undefined, b: DeleteEntityResponse | PlainMessage<DeleteEntityResponse> | undefined): boolean {
    return proto3.util.equals(DeleteEntityResponse, a, b);
  }
}

/**
 * Event representing some type of entity change.
 *
 * @generated from message anduril.entitymanager.v1.EntityEvent
 */
export class EntityEvent extends Message<EntityEvent> {
  /**
   * @generated from field: anduril.entitymanager.v1.EventType event_type = 1;
   */
  eventType = EventType.INVALID;

  /**
   * @generated from field: google.protobuf.Timestamp time = 2;
   */
  time?: Timestamp;

  /**
   * @generated from field: anduril.entitymanager.v1.Entity entity = 3;
   */
  entity?: Entity;

  constructor(data?: PartialMessage<EntityEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.EntityEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event_type", kind: "enum", T: proto3.getEnumType(EventType) },
    { no: 2, name: "time", kind: "message", T: Timestamp },
    { no: 3, name: "entity", kind: "message", T: Entity },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EntityEvent {
    return new EntityEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EntityEvent {
    return new EntityEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EntityEvent {
    return new EntityEvent().fromJsonString(jsonString, options);
  }

  static equals(a: EntityEvent | PlainMessage<EntityEvent> | undefined, b: EntityEvent | PlainMessage<EntityEvent> | undefined): boolean {
    return proto3.util.equals(EntityEvent, a, b);
  }
}

/**
 * A message that is periodically sent on the stream for keep-alive behaviour.
 *
 * @generated from message anduril.entitymanager.v1.Heartbeat
 */
export class Heartbeat extends Message<Heartbeat> {
  /**
   * The timestamp at which the heartbeat message was sent.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<Heartbeat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Heartbeat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Heartbeat {
    return new Heartbeat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Heartbeat {
    return new Heartbeat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Heartbeat {
    return new Heartbeat().fromJsonString(jsonString, options);
  }

  static equals(a: Heartbeat | PlainMessage<Heartbeat> | undefined, b: Heartbeat | PlainMessage<Heartbeat> | undefined): boolean {
    return proto3.util.equals(Heartbeat, a, b);
  }
}

