// @generated by protoc-gen-es v2.0.0
// @generated from file anduril/entitymanager/v1/entity_manager_api.pub.proto (package anduril.entitymanager.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";
import type { Entity, Provenance } from "./entity.pub_pb";
import type { Statement } from "./filter.pub_pb";
import type { RateLimit } from "./rate_limit.pub_pb";
import type { OverrideStatus } from "./types.pub_pb";
import type { Timestamp } from "@bufbuild/protobuf/wkt";

/**
 * Describes the file anduril/entitymanager/v1/entity_manager_api.pub.proto.
 */
export declare const file_anduril_entitymanager_v1_entity_manager_api_pub: GenFile;

/**
 * @generated from message anduril.entitymanager.v1.GetEntityRequest
 */
export declare type GetEntityRequest = Message<"anduril.entitymanager.v1.GetEntityRequest"> & {
  /**
   * the GUID of this entity to query
   *
   * @generated from field: string entity_id = 1;
   */
  entityId: string;
};

/**
 * Describes the message anduril.entitymanager.v1.GetEntityRequest.
 * Use `create(GetEntityRequestSchema)` to create a new message.
 */
export declare const GetEntityRequestSchema: GenMessage<GetEntityRequest>;

/**
 * @generated from message anduril.entitymanager.v1.GetEntityResponse
 */
export declare type GetEntityResponse = Message<"anduril.entitymanager.v1.GetEntityResponse"> & {
  /**
   * an Entity object that corresponds with the requested entityId
   *
   * @generated from field: anduril.entitymanager.v1.Entity entity = 1;
   */
  entity?: Entity;
};

/**
 * Describes the message anduril.entitymanager.v1.GetEntityResponse.
 * Use `create(GetEntityResponseSchema)` to create a new message.
 */
export declare const GetEntityResponseSchema: GenMessage<GetEntityResponse>;

/**
 * @generated from message anduril.entitymanager.v1.StreamEntityComponentsRequest
 */
export declare type StreamEntityComponentsRequest = Message<"anduril.entitymanager.v1.StreamEntityComponentsRequest"> & {
  /**
   * lower_snake_cased component names to include in response events, e.g. location. Only included components will
   * populate.
   *
   * @generated from field: repeated string components_to_include = 1;
   */
  componentsToInclude: string[];

  /**
   * subscribe to all components. This should only be used in cases where you want all components (e.g. latticectl) and
   * if you're using it for other services please reach out first. Setting both components_to_include and
   * include_all_components is invalid and will be rejected.
   *
   * @generated from field: bool include_all_components = 2;
   */
  includeAllComponents: boolean;

  /**
   * The root node of a statement filter "tree".
   * If provided, only entities matching the filter criteria will be streamed. The filter is applied dynamically so if a
   * new entity matches, it will be included, and if an entity updates to no longer match, it will be excluded.
   *
   * @generated from field: anduril.entitymanager.v1.Statement filter = 3;
   */
  filter?: Statement;

  /**
   * optional rate-limiting / down-sampling parameters, see RateLimit message for details.
   *
   * @generated from field: anduril.entitymanager.v1.RateLimit rate_limit = 4;
   */
  rateLimit?: RateLimit;

  /**
   * The period (in milliseconds) at which a Heartbeat message will be sent on the
   * message stream. If this field is set to 0 then no Heartbeat messages are sent.
   *
   * @generated from field: uint32 heartbeat_period_millis = 5;
   */
  heartbeatPeriodMillis: number;

  /**
   * subscribe to a finite stream of preexisting events which closes when there are no additional pre-existing events to
   * process. Respects the filter specified on the StreamEntityComponentsRequest.
   *
   * @generated from field: bool preexisting_only = 6;
   */
  preexistingOnly: boolean;
};

/**
 * Describes the message anduril.entitymanager.v1.StreamEntityComponentsRequest.
 * Use `create(StreamEntityComponentsRequestSchema)` to create a new message.
 */
export declare const StreamEntityComponentsRequestSchema: GenMessage<StreamEntityComponentsRequest>;

/**
 * response stream will be fed all matching pre-existing live entities as CREATED, plus any new events ongoing.
 *
 * @generated from message anduril.entitymanager.v1.StreamEntityComponentsResponse
 */
export declare type StreamEntityComponentsResponse = Message<"anduril.entitymanager.v1.StreamEntityComponentsResponse"> & {
  /**
   * @generated from field: anduril.entitymanager.v1.EntityEvent entity_event = 1;
   */
  entityEvent?: EntityEvent;

  /**
   * @generated from field: anduril.entitymanager.v1.Heartbeat heartbeat = 2;
   */
  heartbeat?: Heartbeat;
};

/**
 * Describes the message anduril.entitymanager.v1.StreamEntityComponentsResponse.
 * Use `create(StreamEntityComponentsResponseSchema)` to create a new message.
 */
export declare const StreamEntityComponentsResponseSchema: GenMessage<StreamEntityComponentsResponse>;

/**
 * @generated from message anduril.entitymanager.v1.PutEntityRequest
 */
export declare type PutEntityRequest = Message<"anduril.entitymanager.v1.PutEntityRequest"> & {
  /**
   * The entity to put.
   * Required fields:
   *   * expiry_time - must be in the future, but less than 30 days from now
   *   * provenance.data_type
   *   * provenance.source_update_time (can be earlier than rpc call if data entered is older)
   *   * aliases.name
   *   * ontology.template
   * any additional required fields will be determined by template, see com.anduril.entitymanager.v1.Template
   * if an entity_id is provided, will treat as update, otherwise create
   *
   * @generated from field: anduril.entitymanager.v1.Entity entity = 1;
   */
  entity?: Entity;

  /**
   * An optional unique identifier for this entity supplied by integration.
   * If provided, EntityId will be determined via consistent hash with provenance.data_type + unique_id
   *
   * @generated from field: string unique_id = 2;
   */
  uniqueId: string;
};

/**
 * Describes the message anduril.entitymanager.v1.PutEntityRequest.
 * Use `create(PutEntityRequestSchema)` to create a new message.
 */
export declare const PutEntityRequestSchema: GenMessage<PutEntityRequest>;

/**
 * @generated from message anduril.entitymanager.v1.PutEntityResponse
 */
export declare type PutEntityResponse = Message<"anduril.entitymanager.v1.PutEntityResponse"> & {
  /**
   * The updated entity.
   * Automatically updated fields:
   *   * is_live - always reset to true
   *   * entity_id - new GUID on create
   *   * created_time - set on create
   *
   * @generated from field: anduril.entitymanager.v1.Entity entity = 1;
   */
  entity?: Entity;
};

/**
 * Describes the message anduril.entitymanager.v1.PutEntityResponse.
 * Use `create(PutEntityResponseSchema)` to create a new message.
 */
export declare const PutEntityResponseSchema: GenMessage<PutEntityResponse>;

/**
 * @generated from message anduril.entitymanager.v1.PublishEntitiesRequest
 */
export declare type PublishEntitiesRequest = Message<"anduril.entitymanager.v1.PublishEntitiesRequest"> & {
  /**
   * Stream of fully formed entities to publish
   * Required fields per entity:
   *   * expiry_time - must be in the future, but less than 30 days from now
   *   * provenance.data_type
   *   * provenance.source_update_time (can be earlier than rpc call if data entered is older)
   *   * aliases.name
   *   * ontology.template
   * any additional required fields will be determined by template, see com.anduril.entitymanager.v1.Template
   * if an entity_id is provided, will treat as update, otherwise create
   *
   * @generated from field: anduril.entitymanager.v1.Entity entity = 1;
   */
  entity?: Entity;
};

/**
 * Describes the message anduril.entitymanager.v1.PublishEntitiesRequest.
 * Use `create(PublishEntitiesRequestSchema)` to create a new message.
 */
export declare const PublishEntitiesRequestSchema: GenMessage<PublishEntitiesRequest>;

/**
 * After the stream is closed the server will return an empty message indicating success. If any streamed message
 * caused an error then the stream is immediately terminated and an error code is returned.
 *
 * @generated from message anduril.entitymanager.v1.PublishEntitiesResponse
 */
export declare type PublishEntitiesResponse = Message<"anduril.entitymanager.v1.PublishEntitiesResponse"> & {
};

/**
 * Describes the message anduril.entitymanager.v1.PublishEntitiesResponse.
 * Use `create(PublishEntitiesResponseSchema)` to create a new message.
 */
export declare const PublishEntitiesResponseSchema: GenMessage<PublishEntitiesResponse>;

/**
 * @generated from message anduril.entitymanager.v1.OverrideEntityRequest
 */
export declare type OverrideEntityRequest = Message<"anduril.entitymanager.v1.OverrideEntityRequest"> & {
  /**
   * The entity containing the overwritten fields. The service will extract the overridable fields from the entity
   * object and ignore any other fields.
   *
   * @generated from field: anduril.entitymanager.v1.Entity entity = 1;
   */
  entity?: Entity;

  /**
   * The field paths that will be extracted from the Entity and saved as an override. Only fields marked overridable can
   * be overriden.
   *
   * @generated from field: repeated string field_path = 2;
   */
  fieldPath: string[];

  /**
   * Additional information about the source of the override
   *
   * @generated from field: anduril.entitymanager.v1.Provenance provenance = 3;
   */
  provenance?: Provenance;
};

/**
 * Describes the message anduril.entitymanager.v1.OverrideEntityRequest.
 * Use `create(OverrideEntityRequestSchema)` to create a new message.
 */
export declare const OverrideEntityRequestSchema: GenMessage<OverrideEntityRequest>;

/**
 * @generated from message anduril.entitymanager.v1.OverrideEntityResponse
 */
export declare type OverrideEntityResponse = Message<"anduril.entitymanager.v1.OverrideEntityResponse"> & {
  /**
   * The status of the override request.
   *
   * @generated from field: anduril.entitymanager.v1.OverrideStatus status = 1;
   */
  status: OverrideStatus;
};

/**
 * Describes the message anduril.entitymanager.v1.OverrideEntityResponse.
 * Use `create(OverrideEntityResponseSchema)` to create a new message.
 */
export declare const OverrideEntityResponseSchema: GenMessage<OverrideEntityResponse>;

/**
 * @generated from message anduril.entitymanager.v1.RemoveEntityOverrideRequest
 */
export declare type RemoveEntityOverrideRequest = Message<"anduril.entitymanager.v1.RemoveEntityOverrideRequest"> & {
  /**
   * The entity ID that the override will be removed from
   *
   * @generated from field: string entity_id = 1;
   */
  entityId: string;

  /**
   * The field paths to remove from the override store for the provided entityId.
   *
   * @generated from field: repeated string field_path = 2;
   */
  fieldPath: string[];
};

/**
 * Describes the message anduril.entitymanager.v1.RemoveEntityOverrideRequest.
 * Use `create(RemoveEntityOverrideRequestSchema)` to create a new message.
 */
export declare const RemoveEntityOverrideRequestSchema: GenMessage<RemoveEntityOverrideRequest>;

/**
 * void response but with placeholder for future optional fields.
 *
 * @generated from message anduril.entitymanager.v1.RemoveEntityOverrideResponse
 */
export declare type RemoveEntityOverrideResponse = Message<"anduril.entitymanager.v1.RemoveEntityOverrideResponse"> & {
};

/**
 * Describes the message anduril.entitymanager.v1.RemoveEntityOverrideResponse.
 * Use `create(RemoveEntityOverrideResponseSchema)` to create a new message.
 */
export declare const RemoveEntityOverrideResponseSchema: GenMessage<RemoveEntityOverrideResponse>;

/**
 * @generated from message anduril.entitymanager.v1.DeleteEntityRequest
 */
export declare type DeleteEntityRequest = Message<"anduril.entitymanager.v1.DeleteEntityRequest"> & {
  /**
   * @generated from field: string entity_id = 1;
   */
  entityId: string;
};

/**
 * Describes the message anduril.entitymanager.v1.DeleteEntityRequest.
 * Use `create(DeleteEntityRequestSchema)` to create a new message.
 */
export declare const DeleteEntityRequestSchema: GenMessage<DeleteEntityRequest>;

/**
 * void response but with placeholder for future optional fields.
 *
 * @generated from message anduril.entitymanager.v1.DeleteEntityResponse
 */
export declare type DeleteEntityResponse = Message<"anduril.entitymanager.v1.DeleteEntityResponse"> & {
};

/**
 * Describes the message anduril.entitymanager.v1.DeleteEntityResponse.
 * Use `create(DeleteEntityResponseSchema)` to create a new message.
 */
export declare const DeleteEntityResponseSchema: GenMessage<DeleteEntityResponse>;

/**
 * Event representing some type of entity change.
 *
 * @generated from message anduril.entitymanager.v1.EntityEvent
 */
export declare type EntityEvent = Message<"anduril.entitymanager.v1.EntityEvent"> & {
  /**
   * @generated from field: anduril.entitymanager.v1.EventType event_type = 1;
   */
  eventType: EventType;

  /**
   * @generated from field: google.protobuf.Timestamp time = 2;
   */
  time?: Timestamp;

  /**
   * @generated from field: anduril.entitymanager.v1.Entity entity = 3;
   */
  entity?: Entity;
};

/**
 * Describes the message anduril.entitymanager.v1.EntityEvent.
 * Use `create(EntityEventSchema)` to create a new message.
 */
export declare const EntityEventSchema: GenMessage<EntityEvent>;

/**
 * A message that is periodically sent on the stream for keep-alive behaviour.
 *
 * @generated from message anduril.entitymanager.v1.Heartbeat
 */
export declare type Heartbeat = Message<"anduril.entitymanager.v1.Heartbeat"> & {
  /**
   * The timestamp at which the heartbeat message was sent.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;
};

/**
 * Describes the message anduril.entitymanager.v1.Heartbeat.
 * Use `create(HeartbeatSchema)` to create a new message.
 */
export declare const HeartbeatSchema: GenMessage<Heartbeat>;

/**
 * The type of entity event.
 *
 * @generated from enum anduril.entitymanager.v1.EventType
 */
export enum EventType {
  /**
   * @generated from enum value: EVENT_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * entity was created.
   *
   * @generated from enum value: EVENT_TYPE_CREATED = 1;
   */
  CREATED = 1,

  /**
   * entity was updated.
   *
   * @generated from enum value: EVENT_TYPE_UPDATE = 2;
   */
  UPDATE = 2,

  /**
   * entity was deleted.
   *
   * @generated from enum value: EVENT_TYPE_DELETED = 3;
   */
  DELETED = 3,

  /**
   * entity already existed, but sent on a new stream connection.
   *
   * @generated from enum value: EVENT_TYPE_PREEXISTING = 4;
   */
  PREEXISTING = 4,

  /**
   * entity override was set after the entity expiration.
   *
   * @generated from enum value: EVENT_TYPE_POST_EXPIRY_OVERRIDE = 5;
   */
  POST_EXPIRY_OVERRIDE = 5,
}

/**
 * Describes the enum anduril.entitymanager.v1.EventType.
 */
export declare const EventTypeSchema: GenEnum<EventType>;

/**
 * The EntityManager provides a UI centric data model for understanding the entities in a battle space.
 *
 * Every object in a battle space is represented as an "Entity". Each Entity is essentially an ID, with a life cycle,
 * and a collection of data components. Each data component is a separate protobuf message definition.
 *
 * EntityManager provides a way to query the currently live set of entities within a set of filter constraints,
 * as well as a limited set of management APIs to change the grouping or relationships between entities.
 *
 * @generated from service anduril.entitymanager.v1.EntityManagerAPI
 */
export declare const EntityManagerAPI: GenService<{
  /**
   * Get a entity based on an entityId.
   *
   * @generated from rpc anduril.entitymanager.v1.EntityManagerAPI.GetEntity
   */
  getEntity: {
    methodKind: "unary";
    input: typeof GetEntityRequestSchema;
    output: typeof GetEntityResponseSchema;
  },
  /**
   * Returns a stream of entity with specified components populated.
   *
   * @generated from rpc anduril.entitymanager.v1.EntityManagerAPI.StreamEntityComponents
   */
  streamEntityComponents: {
    methodKind: "server_streaming";
    input: typeof StreamEntityComponentsRequestSchema;
    output: typeof StreamEntityComponentsResponseSchema;
  },
  /**
   * Create or Update an Entity. This should be used by low update rate situations where Entity Manager is
   * the source of truth, rather than an aggregator. The canonical example is a manually created entity.
   * Entities created in this fashion are stored as a Base entity, overrides on top are still possible.
   *
   * @generated from rpc anduril.entitymanager.v1.EntityManagerAPI.PutEntity
   */
  putEntity: {
    methodKind: "unary";
    input: typeof PutEntityRequestSchema;
    output: typeof PutEntityResponseSchema;
  },
  /**
   * Create or Update one or more Entities. This should be used during high update rate situations where the originator
   * is both the aggregator and source of truth for the published entities, and the originator does not have
   * the ability to directly publish to Flux.
   *
   * @generated from rpc anduril.entitymanager.v1.EntityManagerAPI.PublishEntities
   */
  publishEntities: {
    methodKind: "client_streaming";
    input: typeof PublishEntitiesRequestSchema;
    output: typeof PublishEntitiesResponseSchema;
  },
  /**
   * Override an Entity Component. Only fields marked with overridable can be overwritten.
   *
   * @generated from rpc anduril.entitymanager.v1.EntityManagerAPI.OverrideEntity
   */
  overrideEntity: {
    methodKind: "unary";
    input: typeof OverrideEntityRequestSchema;
    output: typeof OverrideEntityResponseSchema;
  },
  /**
   * Remove an override for an Entity component.
   *
   * @generated from rpc anduril.entitymanager.v1.EntityManagerAPI.RemoveEntityOverride
   */
  removeEntityOverride: {
    methodKind: "unary";
    input: typeof RemoveEntityOverrideRequestSchema;
    output: typeof RemoveEntityOverrideResponseSchema;
  },
  /**
   * Delete an Entity - only works on entities created by PutEntity.
   *
   * @generated from rpc anduril.entitymanager.v1.EntityManagerAPI.DeleteEntity
   */
  deleteEntity: {
    methodKind: "unary";
    input: typeof DeleteEntityRequestSchema;
    output: typeof DeleteEntityResponseSchema;
  },
}>;

