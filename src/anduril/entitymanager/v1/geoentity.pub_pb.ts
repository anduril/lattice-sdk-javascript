// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/entitymanager/v1/geoentity.pub.proto (package anduril.entitymanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { DoubleValue, FloatValue, Message, proto3 } from "@bufbuild/protobuf";
import { Position } from "./location.pub_pb.js";
import { Color } from "../../type/color.pub_pb.js";

/**
 * The type of geo entity.
 *
 * @generated from enum anduril.entitymanager.v1.GeoType
 */
export enum GeoType {
  /**
   * @generated from enum value: GEO_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: GEO_TYPE_GENERAL = 1;
   */
  GENERAL = 1,

  /**
   * @generated from enum value: GEO_TYPE_HAZARD = 2;
   */
  HAZARD = 2,

  /**
   * @generated from enum value: GEO_TYPE_EMERGENCY = 3;
   */
  EMERGENCY = 3,

  /**
   * Fire support coordination measure
   *
   * @generated from enum value: GEO_TYPE_FSCM = 4;
   */
  FSCM = 4,

  /**
   * Engagement zones allow for engaging an entity if it comes within the zone of another entity.
   *
   * @generated from enum value: GEO_TYPE_ENGAGEMENT_ZONE = 5;
   */
  ENGAGEMENT_ZONE = 5,

  /**
   * @generated from enum value: GEO_TYPE_CONTROL_AREA = 6;
   */
  CONTROL_AREA = 6,

  /**
   * @generated from enum value: GEO_TYPE_BULLSEYE = 7;
   */
  BULLSEYE = 7,

  /**
   * Airspace Coordinating Measure
   *
   * @generated from enum value: GEO_TYPE_ACM = 8;
   */
  ACM = 8,

  /**
   * Maneuver Control Measure
   *
   * @generated from enum value: GEO_TYPE_MCM = 9;
   */
  MCM = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(GeoType)
proto3.util.setEnumType(GeoType, "anduril.entitymanager.v1.GeoType", [
  { no: 0, name: "GEO_TYPE_INVALID" },
  { no: 1, name: "GEO_TYPE_GENERAL" },
  { no: 2, name: "GEO_TYPE_HAZARD" },
  { no: 3, name: "GEO_TYPE_EMERGENCY" },
  { no: 4, name: "GEO_TYPE_FSCM" },
  { no: 5, name: "GEO_TYPE_ENGAGEMENT_ZONE" },
  { no: 6, name: "GEO_TYPE_CONTROL_AREA" },
  { no: 7, name: "GEO_TYPE_BULLSEYE" },
  { no: 8, name: "GEO_TYPE_ACM" },
  { no: 9, name: "GEO_TYPE_MCM" },
]);

/**
 * Type of an emergency.
 *
 * @generated from enum anduril.entitymanager.v1.EmergencyType
 */
export enum EmergencyType {
  /**
   * @generated from enum value: EMERGENCY_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: EMERGENCY_TYPE_DOWN_AIRCRAFT = 1;
   */
  DOWN_AIRCRAFT = 1,

  /**
   * @generated from enum value: EMERGENCY_TYPE_MAN_IN_WATER = 2;
   */
  MAN_IN_WATER = 2,

  /**
   * @generated from enum value: EMERGENCY_TYPE_DITCHING = 3;
   */
  DITCHING = 3,

  /**
   * @generated from enum value: EMERGENCY_TYPE_BAILOUT = 4;
   */
  BAILOUT = 4,

  /**
   * @generated from enum value: EMERGENCY_TYPE_DISTRESSED_VEHICLE = 5;
   */
  DISTRESSED_VEHICLE = 5,

  /**
   * @generated from enum value: EMERGENCY_TYPE_GROUND_INCIDENT = 6;
   */
  GROUND_INCIDENT = 6,

  /**
   * @generated from enum value: EMERGENCY_TYPE_MEDICAL = 7;
   */
  MEDICAL = 7,

  /**
   * @generated from enum value: EMERGENCY_TYPE_ISOLATED_PERSON = 8;
   */
  ISOLATED_PERSON = 8,
}
// Retrieve enum metadata with: proto3.getEnumType(EmergencyType)
proto3.util.setEnumType(EmergencyType, "anduril.entitymanager.v1.EmergencyType", [
  { no: 0, name: "EMERGENCY_TYPE_INVALID" },
  { no: 1, name: "EMERGENCY_TYPE_DOWN_AIRCRAFT" },
  { no: 2, name: "EMERGENCY_TYPE_MAN_IN_WATER" },
  { no: 3, name: "EMERGENCY_TYPE_DITCHING" },
  { no: 4, name: "EMERGENCY_TYPE_BAILOUT" },
  { no: 5, name: "EMERGENCY_TYPE_DISTRESSED_VEHICLE" },
  { no: 6, name: "EMERGENCY_TYPE_GROUND_INCIDENT" },
  { no: 7, name: "EMERGENCY_TYPE_MEDICAL" },
  { no: 8, name: "EMERGENCY_TYPE_ISOLATED_PERSON" },
]);

/**
 * @generated from enum anduril.entitymanager.v1.ControlAreaType
 */
export enum ControlAreaType {
  /**
   * @generated from enum value: CONTROL_AREA_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: CONTROL_AREA_TYPE_KEEP_IN_ZONE = 1;
   */
  KEEP_IN_ZONE = 1,

  /**
   * @generated from enum value: CONTROL_AREA_TYPE_KEEP_OUT_ZONE = 2;
   */
  KEEP_OUT_ZONE = 2,

  /**
   * Zone for an autonomous asset to nose-dive into
   * when its assignment has been concluded
   *
   * @generated from enum value: CONTROL_AREA_TYPE_DITCH_ZONE = 3;
   */
  DITCH_ZONE = 3,

  /**
   * Areas where we do not process radar detections
   *
   * @generated from enum value: CONTROL_AREA_TYPE_OBSERVATION_EXCLUSION = 4;
   */
  OBSERVATION_EXCLUSION = 4,

  /**
   * Areas where we process radar detections exclusively
   *
   * @generated from enum value: CONTROL_AREA_TYPE_OBSERVATION_INCLUSION = 5;
   */
  OBSERVATION_INCLUSION = 5,

  /**
   * Areas where we elevate interrogation priority
   *
   * @generated from enum value: CONTROL_AREA_TYPE_OBSERVATION_PRIORITY = 6;
   */
  OBSERVATION_PRIORITY = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(ControlAreaType)
proto3.util.setEnumType(ControlAreaType, "anduril.entitymanager.v1.ControlAreaType", [
  { no: 0, name: "CONTROL_AREA_TYPE_INVALID" },
  { no: 1, name: "CONTROL_AREA_TYPE_KEEP_IN_ZONE" },
  { no: 2, name: "CONTROL_AREA_TYPE_KEEP_OUT_ZONE" },
  { no: 3, name: "CONTROL_AREA_TYPE_DITCH_ZONE" },
  { no: 4, name: "CONTROL_AREA_TYPE_OBSERVATION_EXCLUSION" },
  { no: 5, name: "CONTROL_AREA_TYPE_OBSERVATION_INCLUSION" },
  { no: 6, name: "CONTROL_AREA_TYPE_OBSERVATION_PRIORITY" },
]);

/**
 * @generated from enum anduril.entitymanager.v1.FSCMDetailType
 */
export enum FSCMDetailType {
  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_INVALID = 0;
   */
  FSCM_DETAIL_TYPE_INVALID = 0,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_DEAD_SPACE_AREA = 1;
   */
  FSCM_DETAIL_TYPE_DEAD_SPACE_AREA = 1,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_NO_FIRE_AREA = 2;
   */
  FSCM_DETAIL_TYPE_NO_FIRE_AREA = 2,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_FREE_FIRE_AREA = 3;
   */
  FSCM_DETAIL_TYPE_FREE_FIRE_AREA = 3,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_RESTRICTIVE_FIRE_AREA = 4;
   */
  FSCM_DETAIL_TYPE_RESTRICTIVE_FIRE_AREA = 4,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_SAFE_FIRE_AREA = 5;
   */
  FSCM_DETAIL_TYPE_SAFE_FIRE_AREA = 5,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_AIRSPACE_COORDINATION_AREA = 6;
   */
  FSCM_DETAIL_TYPE_AIRSPACE_COORDINATION_AREA = 6,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_FORWARD_EDGE_OF_THE_BATTLE_AREA = 7;
   */
  FSCM_DETAIL_TYPE_FORWARD_EDGE_OF_THE_BATTLE_AREA = 7,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_FIRE_SUPPORT_AREA = 8;
   */
  FSCM_DETAIL_TYPE_FIRE_SUPPORT_AREA = 8,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_PATROL_RECONNAISSANCE = 9;
   */
  FSCM_DETAIL_TYPE_PATROL_RECONNAISSANCE = 9,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_ZONE_OF_RESPONSIBILITY = 10;
   */
  FSCM_DETAIL_TYPE_ZONE_OF_RESPONSIBILITY = 10,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_PRIORITY_CALL_FOR_FIRE_ZONE = 11;
   */
  FSCM_DETAIL_TYPE_PRIORITY_CALL_FOR_FIRE_ZONE = 11,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_CENSORED_ZONE = 12;
   */
  FSCM_DETAIL_TYPE_CENSORED_ZONE = 12,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_ZONE_OF_ACTION = 13;
   */
  FSCM_DETAIL_TYPE_ZONE_OF_ACTION = 13,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_CRITICAL_FRIENDLY_ZONE = 14;
   */
  FSCM_DETAIL_TYPE_CRITICAL_FRIENDLY_ZONE = 14,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_PLATOON_AREA_HAZARD = 15;
   */
  FSCM_DETAIL_TYPE_PLATOON_AREA_HAZARD = 15,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_TARGET_AREA_HAZARD = 16;
   */
  FSCM_DETAIL_TYPE_TARGET_AREA_HAZARD = 16,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_RESTRICTED_OPERATIONS_ZONE = 17;
   */
  FSCM_DETAIL_TYPE_RESTRICTED_OPERATIONS_ZONE = 17,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_AIR_CORRIDOR = 18;
   */
  FSCM_DETAIL_TYPE_AIR_CORRIDOR = 18,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_RESTRICTIVE_FIRE_LINE = 19;
   */
  FSCM_DETAIL_TYPE_RESTRICTIVE_FIRE_LINE = 19,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_COORDINATED_FIRE_LINE_NO_FIRE_LINE = 20;
   */
  FSCM_DETAIL_TYPE_COORDINATED_FIRE_LINE_NO_FIRE_LINE = 20,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_BOUNDARY_LINE = 21;
   */
  FSCM_DETAIL_TYPE_BOUNDARY_LINE = 21,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_FORWARD_LINE = 22;
   */
  FSCM_DETAIL_TYPE_FORWARD_LINE = 22,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_FIRE_SUPPORT_LINE = 23;
   */
  FSCM_DETAIL_TYPE_FIRE_SUPPORT_LINE = 23,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_LINE_OF_DEPARTURE = 24;
   */
  FSCM_DETAIL_TYPE_LINE_OF_DEPARTURE = 24,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_LINE_OF_CONTACT = 25;
   */
  FSCM_DETAIL_TYPE_LINE_OF_CONTACT = 25,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_LINE_OF_DEPARTURE_LINE_OF_CONTACT = 26;
   */
  FSCM_DETAIL_TYPE_LINE_OF_DEPARTURE_LINE_OF_CONTACT = 26,

  /**
   * @generated from enum value: FSCM_DETAIL_TYPE_ZONE_OF_FIRE = 27;
   */
  FSCM_DETAIL_TYPE_ZONE_OF_FIRE = 27,
}
// Retrieve enum metadata with: proto3.getEnumType(FSCMDetailType)
proto3.util.setEnumType(FSCMDetailType, "anduril.entitymanager.v1.FSCMDetailType", [
  { no: 0, name: "FSCM_DETAIL_TYPE_INVALID" },
  { no: 1, name: "FSCM_DETAIL_TYPE_DEAD_SPACE_AREA" },
  { no: 2, name: "FSCM_DETAIL_TYPE_NO_FIRE_AREA" },
  { no: 3, name: "FSCM_DETAIL_TYPE_FREE_FIRE_AREA" },
  { no: 4, name: "FSCM_DETAIL_TYPE_RESTRICTIVE_FIRE_AREA" },
  { no: 5, name: "FSCM_DETAIL_TYPE_SAFE_FIRE_AREA" },
  { no: 6, name: "FSCM_DETAIL_TYPE_AIRSPACE_COORDINATION_AREA" },
  { no: 7, name: "FSCM_DETAIL_TYPE_FORWARD_EDGE_OF_THE_BATTLE_AREA" },
  { no: 8, name: "FSCM_DETAIL_TYPE_FIRE_SUPPORT_AREA" },
  { no: 9, name: "FSCM_DETAIL_TYPE_PATROL_RECONNAISSANCE" },
  { no: 10, name: "FSCM_DETAIL_TYPE_ZONE_OF_RESPONSIBILITY" },
  { no: 11, name: "FSCM_DETAIL_TYPE_PRIORITY_CALL_FOR_FIRE_ZONE" },
  { no: 12, name: "FSCM_DETAIL_TYPE_CENSORED_ZONE" },
  { no: 13, name: "FSCM_DETAIL_TYPE_ZONE_OF_ACTION" },
  { no: 14, name: "FSCM_DETAIL_TYPE_CRITICAL_FRIENDLY_ZONE" },
  { no: 15, name: "FSCM_DETAIL_TYPE_PLATOON_AREA_HAZARD" },
  { no: 16, name: "FSCM_DETAIL_TYPE_TARGET_AREA_HAZARD" },
  { no: 17, name: "FSCM_DETAIL_TYPE_RESTRICTED_OPERATIONS_ZONE" },
  { no: 18, name: "FSCM_DETAIL_TYPE_AIR_CORRIDOR" },
  { no: 19, name: "FSCM_DETAIL_TYPE_RESTRICTIVE_FIRE_LINE" },
  { no: 20, name: "FSCM_DETAIL_TYPE_COORDINATED_FIRE_LINE_NO_FIRE_LINE" },
  { no: 21, name: "FSCM_DETAIL_TYPE_BOUNDARY_LINE" },
  { no: 22, name: "FSCM_DETAIL_TYPE_FORWARD_LINE" },
  { no: 23, name: "FSCM_DETAIL_TYPE_FIRE_SUPPORT_LINE" },
  { no: 24, name: "FSCM_DETAIL_TYPE_LINE_OF_DEPARTURE" },
  { no: 25, name: "FSCM_DETAIL_TYPE_LINE_OF_CONTACT" },
  { no: 26, name: "FSCM_DETAIL_TYPE_LINE_OF_DEPARTURE_LINE_OF_CONTACT" },
  { no: 27, name: "FSCM_DETAIL_TYPE_ZONE_OF_FIRE" },
]);

/**
 * @generated from enum anduril.entitymanager.v1.ACMDetailType
 */
export enum ACMDetailType {
  /**
   * @generated from enum value: ACM_DETAIL_TYPE_INVALID = 0;
   */
  ACM_DETAIL_TYPE_INVALID = 0,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_AIR_CORRIDOR = 1;
   */
  ACM_DETAIL_TYPE_AIR_CORRIDOR = 1,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_MINIMUM_RISK_ROUTE = 2;
   */
  ACM_DETAIL_TYPE_MINIMUM_RISK_ROUTE = 2,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_TEMPORARY_MINIMUM_RISK_ROUTE = 3;
   */
  ACM_DETAIL_TYPE_TEMPORARY_MINIMUM_RISK_ROUTE = 3,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_TRANSIT_ROUTE = 4;
   */
  ACM_DETAIL_TYPE_TRANSIT_ROUTE = 4,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_LOW_LEVEL_TRANSIT_ROUTE = 5;
   */
  ACM_DETAIL_TYPE_LOW_LEVEL_TRANSIT_ROUTE = 5,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_SPECIAL_CORRIDOR = 6;
   */
  ACM_DETAIL_TYPE_SPECIAL_CORRIDOR = 6,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_STANDARD_USE_ARMY_AIRCRAFT_FLIGHT_ROUTE = 7;
   */
  ACM_DETAIL_TYPE_STANDARD_USE_ARMY_AIRCRAFT_FLIGHT_ROUTE = 7,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_RESTRICTED_OPERATIONS_ZONE = 8;
   */
  ACM_DETAIL_TYPE_RESTRICTED_OPERATIONS_ZONE = 8,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_AIR_TO_AIR_REFUELING_AREA = 9;
   */
  ACM_DETAIL_TYPE_AIR_TO_AIR_REFUELING_AREA = 9,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_AIRBORNE_COMMAND_AND_CONTROL_AREA = 10;
   */
  ACM_DETAIL_TYPE_AIRBORNE_COMMAND_AND_CONTROL_AREA = 10,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_AIRBORNE_EARLY_WARNING_AREA = 11;
   */
  ACM_DETAIL_TYPE_AIRBORNE_EARLY_WARNING_AREA = 11,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_CLOSE_AIR_SUPPORT_AREA = 12;
   */
  ACM_DETAIL_TYPE_CLOSE_AIR_SUPPORT_AREA = 12,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_COMBAT_AIR_PATROL = 13;
   */
  ACM_DETAIL_TYPE_COMBAT_AIR_PATROL = 13,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_DROP_ZONE = 14;
   */
  ACM_DETAIL_TYPE_DROP_ZONE = 14,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_ELECTRONIC_COMBAT = 15;
   */
  ACM_DETAIL_TYPE_ELECTRONIC_COMBAT = 15,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_LANDING_ZONE = 16;
   */
  ACM_DETAIL_TYPE_LANDING_ZONE = 16,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_PICKUP_ZONE = 17;
   */
  ACM_DETAIL_TYPE_PICKUP_ZONE = 17,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_RECONNAISSANCE_AREA = 18;
   */
  ACM_DETAIL_TYPE_RECONNAISSANCE_AREA = 18,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_SPECIAL_OPERATIONS_FORCE_AREA = 19;
   */
  ACM_DETAIL_TYPE_SPECIAL_OPERATIONS_FORCE_AREA = 19,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_SURFACE_TO_SURFACE_MISSILE_SYSTEM = 20;
   */
  ACM_DETAIL_TYPE_SURFACE_TO_SURFACE_MISSILE_SYSTEM = 20,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_SURFACE_TO_SURFACE_MUNITIONS = 21;
   */
  ACM_DETAIL_TYPE_SURFACE_TO_SURFACE_MUNITIONS = 21,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_UNMANNED_AIRCRAFT_AREA = 22;
   */
  ACM_DETAIL_TYPE_UNMANNED_AIRCRAFT_AREA = 22,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_COORDINATING_ALTITUDE = 23;
   */
  ACM_DETAIL_TYPE_COORDINATING_ALTITUDE = 23,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_COORDINATION_LEVEL = 24;
   */
  ACM_DETAIL_TYPE_COORDINATION_LEVEL = 24,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_HIGH_DENSITY_AIRSPACE_CONTROL_ZONE = 25;
   */
  ACM_DETAIL_TYPE_HIGH_DENSITY_AIRSPACE_CONTROL_ZONE = 25,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_NO_FLY_AREA = 26;
   */
  ACM_DETAIL_TYPE_NO_FLY_AREA = 26,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_TRANSIT_CORRIDOR = 27;
   */
  ACM_DETAIL_TYPE_TRANSIT_CORRIDOR = 27,

  /**
   * @generated from enum value: ACM_DETAIL_TYPE_RETURN_TO_FORCE = 28;
   */
  ACM_DETAIL_TYPE_RETURN_TO_FORCE = 28,
}
// Retrieve enum metadata with: proto3.getEnumType(ACMDetailType)
proto3.util.setEnumType(ACMDetailType, "anduril.entitymanager.v1.ACMDetailType", [
  { no: 0, name: "ACM_DETAIL_TYPE_INVALID" },
  { no: 1, name: "ACM_DETAIL_TYPE_AIR_CORRIDOR" },
  { no: 2, name: "ACM_DETAIL_TYPE_MINIMUM_RISK_ROUTE" },
  { no: 3, name: "ACM_DETAIL_TYPE_TEMPORARY_MINIMUM_RISK_ROUTE" },
  { no: 4, name: "ACM_DETAIL_TYPE_TRANSIT_ROUTE" },
  { no: 5, name: "ACM_DETAIL_TYPE_LOW_LEVEL_TRANSIT_ROUTE" },
  { no: 6, name: "ACM_DETAIL_TYPE_SPECIAL_CORRIDOR" },
  { no: 7, name: "ACM_DETAIL_TYPE_STANDARD_USE_ARMY_AIRCRAFT_FLIGHT_ROUTE" },
  { no: 8, name: "ACM_DETAIL_TYPE_RESTRICTED_OPERATIONS_ZONE" },
  { no: 9, name: "ACM_DETAIL_TYPE_AIR_TO_AIR_REFUELING_AREA" },
  { no: 10, name: "ACM_DETAIL_TYPE_AIRBORNE_COMMAND_AND_CONTROL_AREA" },
  { no: 11, name: "ACM_DETAIL_TYPE_AIRBORNE_EARLY_WARNING_AREA" },
  { no: 12, name: "ACM_DETAIL_TYPE_CLOSE_AIR_SUPPORT_AREA" },
  { no: 13, name: "ACM_DETAIL_TYPE_COMBAT_AIR_PATROL" },
  { no: 14, name: "ACM_DETAIL_TYPE_DROP_ZONE" },
  { no: 15, name: "ACM_DETAIL_TYPE_ELECTRONIC_COMBAT" },
  { no: 16, name: "ACM_DETAIL_TYPE_LANDING_ZONE" },
  { no: 17, name: "ACM_DETAIL_TYPE_PICKUP_ZONE" },
  { no: 18, name: "ACM_DETAIL_TYPE_RECONNAISSANCE_AREA" },
  { no: 19, name: "ACM_DETAIL_TYPE_SPECIAL_OPERATIONS_FORCE_AREA" },
  { no: 20, name: "ACM_DETAIL_TYPE_SURFACE_TO_SURFACE_MISSILE_SYSTEM" },
  { no: 21, name: "ACM_DETAIL_TYPE_SURFACE_TO_SURFACE_MUNITIONS" },
  { no: 22, name: "ACM_DETAIL_TYPE_UNMANNED_AIRCRAFT_AREA" },
  { no: 23, name: "ACM_DETAIL_TYPE_COORDINATING_ALTITUDE" },
  { no: 24, name: "ACM_DETAIL_TYPE_COORDINATION_LEVEL" },
  { no: 25, name: "ACM_DETAIL_TYPE_HIGH_DENSITY_AIRSPACE_CONTROL_ZONE" },
  { no: 26, name: "ACM_DETAIL_TYPE_NO_FLY_AREA" },
  { no: 27, name: "ACM_DETAIL_TYPE_TRANSIT_CORRIDOR" },
  { no: 28, name: "ACM_DETAIL_TYPE_RETURN_TO_FORCE" },
]);

/**
 * @generated from enum anduril.entitymanager.v1.AmmoRestrictionType
 */
export enum AmmoRestrictionType {
  /**
   * @generated from enum value: AMMO_RESTRICTION_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: AMMO_RESTRICTION_TYPE_HIGH_EXPLOSIVE_MUNITIONS = 1;
   */
  HIGH_EXPLOSIVE_MUNITIONS = 1,

  /**
   * @generated from enum value: AMMO_RESTRICTION_TYPE_IMPROVED_CONVENTIONAL_MUNITIONS = 2;
   */
  IMPROVED_CONVENTIONAL_MUNITIONS = 2,

  /**
   * @generated from enum value: AMMO_RESTRICTION_TYPE_CHEMICAL_MUNITIONS = 3;
   */
  CHEMICAL_MUNITIONS = 3,

  /**
   * @generated from enum value: AMMO_RESTRICTION_TYPE_NUCLEAR_MUNITIONS = 4;
   */
  NUCLEAR_MUNITIONS = 4,

  /**
   * @generated from enum value: AMMO_RESTRICTION_TYPE_WHITE_PHOSPHORUS_MUNITIONS = 5;
   */
  WHITE_PHOSPHORUS_MUNITIONS = 5,

  /**
   * @generated from enum value: AMMO_RESTRICTION_TYPE_ILLUMINATION_MUNITIONS = 6;
   */
  ILLUMINATION_MUNITIONS = 6,

  /**
   * @generated from enum value: AMMO_RESTRICTION_TYPE_TERMINAL_HOMING_MUNITIONS = 7;
   */
  TERMINAL_HOMING_MUNITIONS = 7,

  /**
   * @generated from enum value: AMMO_RESTRICTION_TYPE_FASCAM_MUNITIONS = 8;
   */
  FASCAM_MUNITIONS = 8,

  /**
   * @generated from enum value: AMMO_RESTRICTION_TYPE_SMOKE_MUNITIONS = 9;
   */
  SMOKE_MUNITIONS = 9,

  /**
   * @generated from enum value: AMMO_RESTRICTION_TYPE_ALL_MUNITIONS = 10;
   */
  ALL_MUNITIONS = 10,
}
// Retrieve enum metadata with: proto3.getEnumType(AmmoRestrictionType)
proto3.util.setEnumType(AmmoRestrictionType, "anduril.entitymanager.v1.AmmoRestrictionType", [
  { no: 0, name: "AMMO_RESTRICTION_TYPE_INVALID" },
  { no: 1, name: "AMMO_RESTRICTION_TYPE_HIGH_EXPLOSIVE_MUNITIONS" },
  { no: 2, name: "AMMO_RESTRICTION_TYPE_IMPROVED_CONVENTIONAL_MUNITIONS" },
  { no: 3, name: "AMMO_RESTRICTION_TYPE_CHEMICAL_MUNITIONS" },
  { no: 4, name: "AMMO_RESTRICTION_TYPE_NUCLEAR_MUNITIONS" },
  { no: 5, name: "AMMO_RESTRICTION_TYPE_WHITE_PHOSPHORUS_MUNITIONS" },
  { no: 6, name: "AMMO_RESTRICTION_TYPE_ILLUMINATION_MUNITIONS" },
  { no: 7, name: "AMMO_RESTRICTION_TYPE_TERMINAL_HOMING_MUNITIONS" },
  { no: 8, name: "AMMO_RESTRICTION_TYPE_FASCAM_MUNITIONS" },
  { no: 9, name: "AMMO_RESTRICTION_TYPE_SMOKE_MUNITIONS" },
  { no: 10, name: "AMMO_RESTRICTION_TYPE_ALL_MUNITIONS" },
]);

/**
 * @generated from enum anduril.entitymanager.v1.RestrictiveMeasureType
 */
export enum RestrictiveMeasureType {
  /**
   * @generated from enum value: RESTRICTIVE_MEASURE_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: RESTRICTIVE_MEASURE_TYPE_STAY_INSIDE_AREA = 1;
   */
  STAY_INSIDE_AREA = 1,

  /**
   * @generated from enum value: RESTRICTIVE_MEASURE_TYPE_STAY_OUTSIDE_AREA = 2;
   */
  STAY_OUTSIDE_AREA = 2,

  /**
   * @generated from enum value: RESTRICTIVE_MEASURE_TYPE_STAY_ABOVE_AREA = 3;
   */
  STAY_ABOVE_AREA = 3,

  /**
   * @generated from enum value: RESTRICTIVE_MEASURE_TYPE_STAY_BELOW_AREA = 4;
   */
  STAY_BELOW_AREA = 4,

  /**
   * @generated from enum value: RESTRICTIVE_MEASURE_TYPE_STAY_NORTH_OF_LINE = 5;
   */
  STAY_NORTH_OF_LINE = 5,

  /**
   * @generated from enum value: RESTRICTIVE_MEASURE_TYPE_STAY_EAST_OF_LINE = 6;
   */
  STAY_EAST_OF_LINE = 6,

  /**
   * @generated from enum value: RESTRICTIVE_MEASURE_TYPE_STAY_SOUTH_OF_LINE = 7;
   */
  STAY_SOUTH_OF_LINE = 7,

  /**
   * @generated from enum value: RESTRICTIVE_MEASURE_TYPE_STAY_WEST_OF_LINE = 8;
   */
  STAY_WEST_OF_LINE = 8,
}
// Retrieve enum metadata with: proto3.getEnumType(RestrictiveMeasureType)
proto3.util.setEnumType(RestrictiveMeasureType, "anduril.entitymanager.v1.RestrictiveMeasureType", [
  { no: 0, name: "RESTRICTIVE_MEASURE_TYPE_INVALID" },
  { no: 1, name: "RESTRICTIVE_MEASURE_TYPE_STAY_INSIDE_AREA" },
  { no: 2, name: "RESTRICTIVE_MEASURE_TYPE_STAY_OUTSIDE_AREA" },
  { no: 3, name: "RESTRICTIVE_MEASURE_TYPE_STAY_ABOVE_AREA" },
  { no: 4, name: "RESTRICTIVE_MEASURE_TYPE_STAY_BELOW_AREA" },
  { no: 5, name: "RESTRICTIVE_MEASURE_TYPE_STAY_NORTH_OF_LINE" },
  { no: 6, name: "RESTRICTIVE_MEASURE_TYPE_STAY_EAST_OF_LINE" },
  { no: 7, name: "RESTRICTIVE_MEASURE_TYPE_STAY_SOUTH_OF_LINE" },
  { no: 8, name: "RESTRICTIVE_MEASURE_TYPE_STAY_WEST_OF_LINE" },
]);

/**
 * @generated from enum anduril.entitymanager.v1.MCMDetailType
 */
export enum MCMDetailType {
  /**
   * @generated from enum value: MCM_DETAIL_TYPE_INVALID = 0;
   */
  MCM_DETAIL_TYPE_INVALID = 0,

  /**
   * @generated from enum value: MCM_DETAIL_TYPE_NAMED_AREA_OF_INTEREST = 1;
   */
  MCM_DETAIL_TYPE_NAMED_AREA_OF_INTEREST = 1,

  /**
   * @generated from enum value: MCM_DETAIL_TYPE_TARGET_AREA_OF_INTEREST = 2;
   */
  MCM_DETAIL_TYPE_TARGET_AREA_OF_INTEREST = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(MCMDetailType)
proto3.util.setEnumType(MCMDetailType, "anduril.entitymanager.v1.MCMDetailType", [
  { no: 0, name: "MCM_DETAIL_TYPE_INVALID" },
  { no: 1, name: "MCM_DETAIL_TYPE_NAMED_AREA_OF_INTEREST" },
  { no: 2, name: "MCM_DETAIL_TYPE_TARGET_AREA_OF_INTEREST" },
]);

/**
 * A component that describes a geo-entity.
 *
 * @generated from message anduril.entitymanager.v1.GeoDetails
 */
export class GeoDetails extends Message<GeoDetails> {
  /**
   * @generated from field: anduril.entitymanager.v1.GeoType type = 1;
   */
  type = GeoType.INVALID;

  /**
   * any additional type specific details
   *
   * @generated from oneof anduril.entitymanager.v1.GeoDetails.type_details
   */
  typeDetails: {
    /**
     * @generated from field: anduril.entitymanager.v1.EmergencyDetails emergency = 2;
     */
    value: EmergencyDetails;
    case: "emergency";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.FSCMDetails fscm = 4;
     */
    value: FSCMDetails;
    case: "fscm";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.ControlAreaDetails control_area = 5;
     */
    value: ControlAreaDetails;
    case: "controlArea";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.ACMDetails acm = 6;
     */
    value: ACMDetails;
    case: "acm";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.MCMDetails mcm = 7;
     */
    value: MCMDetails;
    case: "mcm";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: anduril.entitymanager.v1.GeoVisualDetails visual_details = 3;
   */
  visualDetails?: GeoVisualDetails;

  constructor(data?: PartialMessage<GeoDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.GeoDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(GeoType) },
    { no: 2, name: "emergency", kind: "message", T: EmergencyDetails, oneof: "type_details" },
    { no: 4, name: "fscm", kind: "message", T: FSCMDetails, oneof: "type_details" },
    { no: 5, name: "control_area", kind: "message", T: ControlAreaDetails, oneof: "type_details" },
    { no: 6, name: "acm", kind: "message", T: ACMDetails, oneof: "type_details" },
    { no: 7, name: "mcm", kind: "message", T: MCMDetails, oneof: "type_details" },
    { no: 3, name: "visual_details", kind: "message", T: GeoVisualDetails },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoDetails {
    return new GeoDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoDetails {
    return new GeoDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoDetails {
    return new GeoDetails().fromJsonString(jsonString, options);
  }

  static equals(a: GeoDetails | PlainMessage<GeoDetails> | undefined, b: GeoDetails | PlainMessage<GeoDetails> | undefined): boolean {
    return proto3.util.equals(GeoDetails, a, b);
  }
}

/**
 * Details specific to a geo-entity of emergency type.
 *
 * @generated from message anduril.entitymanager.v1.EmergencyDetails
 */
export class EmergencyDetails extends Message<EmergencyDetails> {
  /**
   * @generated from field: anduril.entitymanager.v1.EmergencyType emergency_type = 1;
   */
  emergencyType = EmergencyType.INVALID;

  /**
   * @generated from field: uint32 personnel_involved = 2;
   */
  personnelInvolved = 0;

  constructor(data?: PartialMessage<EmergencyDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.EmergencyDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "emergency_type", kind: "enum", T: proto3.getEnumType(EmergencyType) },
    { no: 2, name: "personnel_involved", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EmergencyDetails {
    return new EmergencyDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EmergencyDetails {
    return new EmergencyDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EmergencyDetails {
    return new EmergencyDetails().fromJsonString(jsonString, options);
  }

  static equals(a: EmergencyDetails | PlainMessage<EmergencyDetails> | undefined, b: EmergencyDetails | PlainMessage<EmergencyDetails> | undefined): boolean {
    return proto3.util.equals(EmergencyDetails, a, b);
  }
}

/**
 * A component that describes the shape of a geo-entity.
 *
 * @generated from message anduril.entitymanager.v1.GeoShape
 */
export class GeoShape extends Message<GeoShape> {
  /**
   * point, line_string, and polygon are convertible as a subset of GeoJSON
   *
   * @generated from oneof anduril.entitymanager.v1.GeoShape.shape
   */
  shape: {
    /**
     * @generated from field: anduril.entitymanager.v1.GeoPoint point = 1;
     */
    value: GeoPoint;
    case: "point";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.GeoLine line = 2;
     */
    value: GeoLine;
    case: "line";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.GeoPolygon polygon = 3;
     */
    value: GeoPolygon;
    case: "polygon";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.GeoEllipse ellipse = 4;
     */
    value: GeoEllipse;
    case: "ellipse";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.GeoEllipsoid ellipsoid = 5;
     */
    value: GeoEllipsoid;
    case: "ellipsoid";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GeoShape>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.GeoShape";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "point", kind: "message", T: GeoPoint, oneof: "shape" },
    { no: 2, name: "line", kind: "message", T: GeoLine, oneof: "shape" },
    { no: 3, name: "polygon", kind: "message", T: GeoPolygon, oneof: "shape" },
    { no: 4, name: "ellipse", kind: "message", T: GeoEllipse, oneof: "shape" },
    { no: 5, name: "ellipsoid", kind: "message", T: GeoEllipsoid, oneof: "shape" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoShape {
    return new GeoShape().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoShape {
    return new GeoShape().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoShape {
    return new GeoShape().fromJsonString(jsonString, options);
  }

  static equals(a: GeoShape | PlainMessage<GeoShape> | undefined, b: GeoShape | PlainMessage<GeoShape> | undefined): boolean {
    return proto3.util.equals(GeoShape, a, b);
  }
}

/**
 * A point shaped geo-entity.
 * See https://datatracker.ietf.org/doc/html/rfc7946#section-3.1.2
 *
 * @generated from message anduril.entitymanager.v1.GeoPoint
 */
export class GeoPoint extends Message<GeoPoint> {
  /**
   * @generated from field: anduril.entitymanager.v1.Position position = 1;
   */
  position?: Position;

  constructor(data?: PartialMessage<GeoPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.GeoPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "position", kind: "message", T: Position },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoPoint {
    return new GeoPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoPoint {
    return new GeoPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoPoint {
    return new GeoPoint().fromJsonString(jsonString, options);
  }

  static equals(a: GeoPoint | PlainMessage<GeoPoint> | undefined, b: GeoPoint | PlainMessage<GeoPoint> | undefined): boolean {
    return proto3.util.equals(GeoPoint, a, b);
  }
}

/**
 * A line shaped geo-entity.
 * See https://datatracker.ietf.org/doc/html/rfc7946#section-3.1.4
 *
 * @generated from message anduril.entitymanager.v1.GeoLine
 */
export class GeoLine extends Message<GeoLine> {
  /**
   * @generated from field: repeated anduril.entitymanager.v1.Position positions = 1;
   */
  positions: Position[] = [];

  constructor(data?: PartialMessage<GeoLine>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.GeoLine";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "positions", kind: "message", T: Position, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoLine {
    return new GeoLine().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoLine {
    return new GeoLine().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoLine {
    return new GeoLine().fromJsonString(jsonString, options);
  }

  static equals(a: GeoLine | PlainMessage<GeoLine> | undefined, b: GeoLine | PlainMessage<GeoLine> | undefined): boolean {
    return proto3.util.equals(GeoLine, a, b);
  }
}

/**
 * A polygon shaped geo-entity.
 * See https://datatracker.ietf.org/doc/html/rfc7946#section-3.1.6, only canonical representations accepted
 *
 * @generated from message anduril.entitymanager.v1.GeoPolygon
 */
export class GeoPolygon extends Message<GeoPolygon> {
  /**
   * An array of LinearRings where the first item is the exterior ring and subsequent items are interior rings.
   * For a good introduction read (https://macwright.com/2015/03/23/geojson-second-bite.html#polygons)
   *
   * @generated from field: repeated anduril.entitymanager.v1.LinearRing rings = 1;
   */
  rings: LinearRing[] = [];

  /**
   * An extension hint that this polygon is a rectangle. When true this implies several things:
   * * exactly 1 linear ring with 5 points (starting corner, 3 other corners and start again)
   * * each point has the same altitude corresponding with the plane of the rectangle
   * * each point has the same height (either all present and equal, or all not present)
   *
   * @generated from field: bool is_rectangle = 2;
   */
  isRectangle = false;

  constructor(data?: PartialMessage<GeoPolygon>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.GeoPolygon";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rings", kind: "message", T: LinearRing, repeated: true },
    { no: 2, name: "is_rectangle", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoPolygon {
    return new GeoPolygon().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoPolygon {
    return new GeoPolygon().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoPolygon {
    return new GeoPolygon().fromJsonString(jsonString, options);
  }

  static equals(a: GeoPolygon | PlainMessage<GeoPolygon> | undefined, b: GeoPolygon | PlainMessage<GeoPolygon> | undefined): boolean {
    return proto3.util.equals(GeoPolygon, a, b);
  }
}

/**
 * An ellipse shaped geo-entity.
 * For a circle, the major and minor axis would be the same values.
 * This shape is NOT Geo-JSON compatible.
 *
 * @generated from message anduril.entitymanager.v1.GeoEllipse
 */
export class GeoEllipse extends Message<GeoEllipse> {
  /**
   * Defines the distance from the center point of the ellipse to the furthest distance on the perimeter in meters.
   *
   * @generated from field: google.protobuf.DoubleValue semi_major_axis_m = 2;
   */
  semiMajorAxisM?: number;

  /**
   * Defines the distance from the center point of the ellipse to the shortest distance on the perimeter in meters.
   *
   * @generated from field: google.protobuf.DoubleValue semi_minor_axis_m = 3;
   */
  semiMinorAxisM?: number;

  /**
   * The orientation of the semi-major relative to true north in degrees from clockwise: 0-180 due to symmetry across the semi-minor axis.
   *
   * @generated from field: google.protobuf.DoubleValue orientation_d = 4;
   */
  orientationD?: number;

  /**
   * Optional height above entity position to extrude in meters. A non-zero value creates an elliptic cylinder
   *
   * @generated from field: google.protobuf.DoubleValue height_m = 5;
   */
  heightM?: number;

  constructor(data?: PartialMessage<GeoEllipse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.GeoEllipse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "semi_major_axis_m", kind: "message", T: DoubleValue },
    { no: 3, name: "semi_minor_axis_m", kind: "message", T: DoubleValue },
    { no: 4, name: "orientation_d", kind: "message", T: DoubleValue },
    { no: 5, name: "height_m", kind: "message", T: DoubleValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoEllipse {
    return new GeoEllipse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoEllipse {
    return new GeoEllipse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoEllipse {
    return new GeoEllipse().fromJsonString(jsonString, options);
  }

  static equals(a: GeoEllipse | PlainMessage<GeoEllipse> | undefined, b: GeoEllipse | PlainMessage<GeoEllipse> | undefined): boolean {
    return proto3.util.equals(GeoEllipse, a, b);
  }
}

/**
 * An ellipsoid shaped geo-entity.
 * Principal axis lengths are defined in entity body space
 * This shape is NOT Geo-JSON compatible.
 *
 * @generated from message anduril.entitymanager.v1.GeoEllipsoid
 */
export class GeoEllipsoid extends Message<GeoEllipsoid> {
  /**
   * Defines the distance from the center point to the surface along the forward axis
   *
   * @generated from field: google.protobuf.DoubleValue forward_axis_m = 1;
   */
  forwardAxisM?: number;

  /**
   * Defines the distance from the center point to the surface along the side axis
   *
   * @generated from field: google.protobuf.DoubleValue side_axis_m = 2;
   */
  sideAxisM?: number;

  /**
   * Defines the distance from the center point to the surface along the up axis
   *
   * @generated from field: google.protobuf.DoubleValue up_axis_m = 3;
   */
  upAxisM?: number;

  constructor(data?: PartialMessage<GeoEllipsoid>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.GeoEllipsoid";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "forward_axis_m", kind: "message", T: DoubleValue },
    { no: 2, name: "side_axis_m", kind: "message", T: DoubleValue },
    { no: 3, name: "up_axis_m", kind: "message", T: DoubleValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoEllipsoid {
    return new GeoEllipsoid().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoEllipsoid {
    return new GeoEllipsoid().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoEllipsoid {
    return new GeoEllipsoid().fromJsonString(jsonString, options);
  }

  static equals(a: GeoEllipsoid | PlainMessage<GeoEllipsoid> | undefined, b: GeoEllipsoid | PlainMessage<GeoEllipsoid> | undefined): boolean {
    return proto3.util.equals(GeoEllipsoid, a, b);
  }
}

/**
 * A closed ring of points. The first and last point must be the same.
 *
 * @generated from message anduril.entitymanager.v1.LinearRing
 */
export class LinearRing extends Message<LinearRing> {
  /**
   * Deprecated: do not use, use positions instead
   *
   * @generated from field: repeated anduril.entitymanager.v1.Position points = 1 [deprecated = true];
   * @deprecated
   */
  points: Position[] = [];

  /**
   * @generated from field: repeated anduril.entitymanager.v1.GeoPolygonPosition positions = 2;
   */
  positions: GeoPolygonPosition[] = [];

  constructor(data?: PartialMessage<LinearRing>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.LinearRing";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "points", kind: "message", T: Position, repeated: true },
    { no: 2, name: "positions", kind: "message", T: GeoPolygonPosition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinearRing {
    return new LinearRing().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinearRing {
    return new LinearRing().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinearRing {
    return new LinearRing().fromJsonString(jsonString, options);
  }

  static equals(a: LinearRing | PlainMessage<LinearRing> | undefined, b: LinearRing | PlainMessage<LinearRing> | undefined): boolean {
    return proto3.util.equals(LinearRing, a, b);
  }
}

/**
 * A position in a GeoPolygon with an optional extruded height.
 *
 * @generated from message anduril.entitymanager.v1.GeoPolygonPosition
 */
export class GeoPolygonPosition extends Message<GeoPolygonPosition> {
  /**
   * base position. if no altitude set, its on the ground.
   *
   * @generated from field: anduril.entitymanager.v1.Position position = 1;
   */
  position?: Position;

  /**
   * optional height above base position to extrude in meters.
   * for a given polygon, all points should have a height or none of them.
   * strictly GeoJSON compatible polygons will not have this set.
   *
   * @generated from field: google.protobuf.FloatValue height_m = 2;
   */
  heightM?: number;

  constructor(data?: PartialMessage<GeoPolygonPosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.GeoPolygonPosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "position", kind: "message", T: Position },
    { no: 2, name: "height_m", kind: "message", T: FloatValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoPolygonPosition {
    return new GeoPolygonPosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoPolygonPosition {
    return new GeoPolygonPosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoPolygonPosition {
    return new GeoPolygonPosition().fromJsonString(jsonString, options);
  }

  static equals(a: GeoPolygonPosition | PlainMessage<GeoPolygonPosition> | undefined, b: GeoPolygonPosition | PlainMessage<GeoPolygonPosition> | undefined): boolean {
    return proto3.util.equals(GeoPolygonPosition, a, b);
  }
}

/**
 * Details specific to displaying a geo-entity
 *
 * @generated from message anduril.entitymanager.v1.GeoVisualDetails
 */
export class GeoVisualDetails extends Message<GeoVisualDetails> {
  /**
   * A string describing the fill color of a geo-entity.
   *
   * @generated from field: anduril.type.Color fill_color = 1;
   */
  fillColor?: Color;

  /**
   * A string describing the line color of a geo-entity.
   *
   * @generated from field: anduril.type.Color line_color = 2;
   */
  lineColor?: Color;

  constructor(data?: PartialMessage<GeoVisualDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.GeoVisualDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fill_color", kind: "message", T: Color },
    { no: 2, name: "line_color", kind: "message", T: Color },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoVisualDetails {
    return new GeoVisualDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoVisualDetails {
    return new GeoVisualDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoVisualDetails {
    return new GeoVisualDetails().fromJsonString(jsonString, options);
  }

  static equals(a: GeoVisualDetails | PlainMessage<GeoVisualDetails> | undefined, b: GeoVisualDetails | PlainMessage<GeoVisualDetails> | undefined): boolean {
    return proto3.util.equals(GeoVisualDetails, a, b);
  }
}

/**
 * Details specific to a geo-entity of Fire Support Coordination Measure (FSCM) type
 *
 * @generated from message anduril.entitymanager.v1.FSCMDetails
 */
export class FSCMDetails extends Message<FSCMDetails> {
  /**
   * @generated from field: anduril.entitymanager.v1.FSCMDetailType fscm_type = 1;
   */
  fscmType = FSCMDetailType.FSCM_DETAIL_TYPE_INVALID;

  /**
   * Used for loosely typed associations, such as assignment to a specific fires unit
   * Limit to 150 characters
   *
   * @generated from field: string fscm_description = 2;
   */
  fscmDescription = "";

  /**
   * @generated from field: anduril.entitymanager.v1.FiringAuthority firing_authority = 3;
   */
  firingAuthority?: FiringAuthority;

  /**
   * @generated from field: anduril.entitymanager.v1.AmmoRestrictionType ammo_restriction_type = 4 [deprecated = true];
   * @deprecated
   */
  ammoRestrictionType = AmmoRestrictionType.INVALID;

  /**
   * @generated from field: anduril.entitymanager.v1.RestrictiveMeasureType restrictive_measure_type = 5;
   */
  restrictiveMeasureType = RestrictiveMeasureType.INVALID;

  /**
   * @generated from field: repeated anduril.entitymanager.v1.AmmoRestrictionType ammo_restrict_types = 6;
   */
  ammoRestrictTypes: AmmoRestrictionType[] = [];

  /**
   * Used to indicate distinction between an FSCM applying to either air or ground, never both
   *
   * @generated from field: bool is_ground = 7;
   */
  isGround = false;

  constructor(data?: PartialMessage<FSCMDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.FSCMDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fscm_type", kind: "enum", T: proto3.getEnumType(FSCMDetailType) },
    { no: 2, name: "fscm_description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "firing_authority", kind: "message", T: FiringAuthority },
    { no: 4, name: "ammo_restriction_type", kind: "enum", T: proto3.getEnumType(AmmoRestrictionType) },
    { no: 5, name: "restrictive_measure_type", kind: "enum", T: proto3.getEnumType(RestrictiveMeasureType) },
    { no: 6, name: "ammo_restrict_types", kind: "enum", T: proto3.getEnumType(AmmoRestrictionType), repeated: true },
    { no: 7, name: "is_ground", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FSCMDetails {
    return new FSCMDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FSCMDetails {
    return new FSCMDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FSCMDetails {
    return new FSCMDetails().fromJsonString(jsonString, options);
  }

  static equals(a: FSCMDetails | PlainMessage<FSCMDetails> | undefined, b: FSCMDetails | PlainMessage<FSCMDetails> | undefined): boolean {
    return proto3.util.equals(FSCMDetails, a, b);
  }
}

/**
 * @generated from message anduril.entitymanager.v1.ACMDetails
 */
export class ACMDetails extends Message<ACMDetails> {
  /**
   * @generated from field: anduril.entitymanager.v1.ACMDetailType acm_type = 1;
   */
  acmType = ACMDetailType.ACM_DETAIL_TYPE_INVALID;

  /**
   * Used for loosely typed associations, such as assignment to a specific fires unit
   * Limit to 150 characters
   *
   * @generated from field: string acm_description = 2;
   */
  acmDescription = "";

  constructor(data?: PartialMessage<ACMDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.ACMDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "acm_type", kind: "enum", T: proto3.getEnumType(ACMDetailType) },
    { no: 2, name: "acm_description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ACMDetails {
    return new ACMDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ACMDetails {
    return new ACMDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ACMDetails {
    return new ACMDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ACMDetails | PlainMessage<ACMDetails> | undefined, b: ACMDetails | PlainMessage<ACMDetails> | undefined): boolean {
    return proto3.util.equals(ACMDetails, a, b);
  }
}

/**
 * @generated from message anduril.entitymanager.v1.MCMDetails
 */
export class MCMDetails extends Message<MCMDetails> {
  /**
   * @generated from field: anduril.entitymanager.v1.MCMDetailType mcm_type = 1;
   */
  mcmType = MCMDetailType.MCM_DETAIL_TYPE_INVALID;

  /**
   * Used for loosely typed associations, such as assignment to a specific fires unit
   * Limit to 150 characters
   *
   * @generated from field: string mcm_description = 2;
   */
  mcmDescription = "";

  constructor(data?: PartialMessage<MCMDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.MCMDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mcm_type", kind: "enum", T: proto3.getEnumType(MCMDetailType) },
    { no: 2, name: "mcm_description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MCMDetails {
    return new MCMDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MCMDetails {
    return new MCMDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MCMDetails {
    return new MCMDetails().fromJsonString(jsonString, options);
  }

  static equals(a: MCMDetails | PlainMessage<MCMDetails> | undefined, b: MCMDetails | PlainMessage<MCMDetails> | undefined): boolean {
    return proto3.util.equals(MCMDetails, a, b);
  }
}

/**
 * Lists the entities that have authority to execute fires into, or through, this FSCM
 *
 * @generated from message anduril.entitymanager.v1.FiringAuthority
 */
export class FiringAuthority extends Message<FiringAuthority> {
  /**
   * @generated from field: repeated string entity_ids = 1;
   */
  entityIds: string[] = [];

  constructor(data?: PartialMessage<FiringAuthority>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.FiringAuthority";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FiringAuthority {
    return new FiringAuthority().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FiringAuthority {
    return new FiringAuthority().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FiringAuthority {
    return new FiringAuthority().fromJsonString(jsonString, options);
  }

  static equals(a: FiringAuthority | PlainMessage<FiringAuthority> | undefined, b: FiringAuthority | PlainMessage<FiringAuthority> | undefined): boolean {
    return proto3.util.equals(FiringAuthority, a, b);
  }
}

/**
 * Details specific to a geo-entity of the GEO_TYPE_CONTROL_AREA type,
 * representing an autonomous asset Control Area.
 *
 * @generated from message anduril.entitymanager.v1.ControlAreaDetails
 */
export class ControlAreaDetails extends Message<ControlAreaDetails> {
  /**
   * @generated from field: anduril.entitymanager.v1.ControlAreaType type = 1;
   */
  type = ControlAreaType.INVALID;

  constructor(data?: PartialMessage<ControlAreaDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.ControlAreaDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(ControlAreaType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ControlAreaDetails {
    return new ControlAreaDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ControlAreaDetails {
    return new ControlAreaDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ControlAreaDetails {
    return new ControlAreaDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ControlAreaDetails | PlainMessage<ControlAreaDetails> | undefined, b: ControlAreaDetails | PlainMessage<ControlAreaDetails> | undefined): boolean {
    return proto3.util.equals(ControlAreaDetails, a, b);
  }
}

