// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/entitymanager/v1/entity.pub.proto (package anduril.entitymanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { BoolValue, DoubleValue, Int32Value, Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Location, LocationUncertainty } from "./location.pub_pb.js";
import { GeoDetails, GeoPolygon, GeoShape } from "./geoentity.pub_pb.js";
import { Correlated } from "./correlations.pub_pb.js";
import { MilView, Ontology } from "./ontology.pub_pb.js";
import { Sensors } from "./sensors.pub_pb.js";
import { Payloads } from "./payloads.pub_pb.js";
import { PowerState } from "./power.pub_pb.js";
import { TargetPriority } from "./target_priority.pub_pb.js";
import { LineOfBearing, Signal } from "./signal.pub_pb.js";
import { TransponderCodes } from "./transponder_codes.pub_pb.js";
import { ContactDetails } from "./contact_details.pub_pb.js";
import { Classification } from "./classification.pub_pb.js";
import { TaskCatalog } from "../../tasks/v2/catalog.pub_pb.js";
import { Media } from "./media.pub_pb.js";
import { Relationships } from "./relationship.pub_pb.js";
import { PrototypeExtensions } from "./prototype.pub_pb.js";
import { Dimensions } from "./dimensions.pub_pb.js";
import { RouteDetails } from "./route_details.pub_pb.js";
import { Schedules } from "./schedule.pub_pb.js";
import { Health } from "./health_status.pub_pb.js";
import { GroupDetails } from "./group.pub_pb.js";
import { Supplies } from "./supplies.pub_pb.js";
import { AltIdType, OverrideStatus, OverrideType, Source, UInt32Range } from "./types.pub_pb.js";

/**
 * Indicates whether an entity can be deleted with the DeleteEntity API call
 *
 * @generated from enum anduril.entitymanager.v1.Deletable
 */
export enum Deletable {
  /**
   * @generated from enum value: DELETABLE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * Entity can immediately be deleted.
   *
   * @generated from enum value: DELETABLE_TRUE = 1;
   */
  TRUE = 1,

  /**
   * Entity is from another source that is known to not allow entities to be deleted
   *
   * @generated from enum value: DELETABLE_FALSE = 2;
   */
  FALSE = 2,

  /**
   * Entity is from another source that requires the source to accept the request. The DeleteEntity API call
   * will work asynchronously in this case.
   *
   * @generated from enum value: DELETABLE_REQUEST = 3;
   */
  REQUEST = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Deletable)
proto3.util.setEnumType(Deletable, "anduril.entitymanager.v1.Deletable", [
  { no: 0, name: "DELETABLE_INVALID" },
  { no: 1, name: "DELETABLE_TRUE" },
  { no: 2, name: "DELETABLE_FALSE" },
  { no: 3, name: "DELETABLE_REQUEST" },
]);

/**
 * @generated from enum anduril.entitymanager.v1.InteractivityMode
 */
export enum InteractivityMode {
  /**
   * @generated from enum value: INTERACTIVITY_MODE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: INTERACTIVITY_MODE_DEFAULT = 1;
   */
  DEFAULT = 1,

  /**
   * @generated from enum value: INTERACTIVITY_MODE_DISABLED_ON_MAP = 2;
   */
  DISABLED_ON_MAP = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(InteractivityMode)
proto3.util.setEnumType(InteractivityMode, "anduril.entitymanager.v1.InteractivityMode", [
  { no: 0, name: "INTERACTIVITY_MODE_INVALID" },
  { no: 1, name: "INTERACTIVITY_MODE_DEFAULT" },
  { no: 2, name: "INTERACTIVITY_MODE_DISABLED_ON_MAP" },
]);

/**
 * An entity object represents a single entity within the Lattice operational environment, and it contains
 * all data associated with that entity, such as its name, ID, and any other relevant components.
 *
 * @generated from message anduril.entitymanager.v1.Entity
 */
export class Entity extends Message<Entity> {
  /**
   * A Globally Unique Identifier (GUID) for your entity. If blank, the Entity API creates
   * an entity and automatically generates a new ID for the entity.
   *
   * @generated from field: string entity_id = 1;
   */
  entityId = "";

  /**
   * Helpful, human-readable entity description mainly used for debugging purposes and human
   * traceability. If blank, the Entity API generates one for you.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Indicates an active asset receiving updates. This is a required field for publishing an entity.
   * It needs to be set to true when publishing an entity.
   *
   * @generated from field: bool is_live = 3;
   */
  isLive = false;

  /**
   * Time when the asset enters the system. If blank, the Entity API uses a current timestamp.
   * For example, when a drone is first powered on, it might report it's boot time as the created time.
   *
   * @generated from field: google.protobuf.Timestamp created_time = 4;
   */
  createdTime?: Timestamp;

  /**
   * A future time that expires an entity and updates the isLive flag.
   * For entities that are constantly updating, the expiry time also updates.
   * Note in some cases this may differ from isLive.
   * Example: Entities with tasks exported to an external system must remain
   * active, even after they expire.
   * This is a required field for publishing an entity via Flux or PublishEntities rpc. When publishing
   * an entity, this timestamp must be in the future, but less than 30 days from the current time.
   *
   * @generated from field: google.protobuf.Timestamp expiry_time = 5;
   */
  expiryTime?: Timestamp;

  /**
   * To indicate that this entity should not expire. Only to be set to `true` on entities published
   * via PutEntity call. Entities published via Flux or PublishEntities rpc with `no_expiry == true` will be rejected.
   *
   * @generated from field: bool no_expiry = 43;
   */
  noExpiry = false;

  /**
   * Human-readable descriptions of what the entity is currently doing.
   *
   * @generated from field: anduril.entitymanager.v1.Status status = 19;
   */
  status?: Status;

  /**
   * Geospatial data related to the entity, including it's position, kinematics and orientation.
   *
   * @generated from field: anduril.entitymanager.v1.Location location = 6;
   */
  location?: Location;

  /**
   * Uncertainty of the entity's position and kinematics.
   *
   * @generated from field: anduril.entitymanager.v1.LocationUncertainty location_uncertainty = 15;
   */
  locationUncertainty?: LocationUncertainty;

  /**
   * Deprecated: do not use, use geo_shape instead
   *
   * @generated from field: anduril.entitymanager.v1.GeoPolygon geopolygon = 17 [deprecated = true];
   * @deprecated
   */
  geopolygon?: GeoPolygon;

  /**
   * Geospatial representation of the entity, including entities that cover an area rather than a fixed point.
   *
   * @generated from field: anduril.entitymanager.v1.GeoShape geo_shape = 23;
   */
  geoShape?: GeoShape;

  /**
   * Additional details on what the geospatial area or point represents, along with visual display details.
   *
   * @generated from field: anduril.entitymanager.v1.GeoDetails geo_details = 24;
   */
  geoDetails?: GeoDetails;

  /**
   * Naming of the entity as well as identifiers that other systems use to reference the same entity.
   *
   * @generated from field: anduril.entitymanager.v1.Aliases aliases = 7;
   */
  aliases?: Aliases;

  /**
   * If this entity is tracked by another, this component contains data related to how it's being tracked.
   *
   * @generated from field: anduril.entitymanager.v1.Tracked tracked = 8;
   */
  tracked?: Tracked;

  /**
   * If this entity has been correlated to another one, this component contains the status of the correlation, the primary entity
   * and the correlation scores.
   *
   * @generated from field: anduril.entitymanager.v1.Correlated correlated = 9;
   */
  correlated?: Correlated;

  /**
   * Military view of the entity
   *
   * @generated from field: anduril.entitymanager.v1.MilView mil_view = 10;
   */
  milView?: MilView;

  /**
   * A standardized representation of the entity
   *
   * @generated from field: anduril.entitymanager.v1.Ontology ontology = 11;
   */
  ontology?: Ontology;

  /**
   * Details of Sensors that are available on an entity
   *
   * @generated from field: anduril.entitymanager.v1.Sensors sensors = 20;
   */
  sensors?: Sensors;

  /**
   * Details of payloads that are available on an entity
   *
   * @generated from field: anduril.entitymanager.v1.Payloads payloads = 21;
   */
  payloads?: Payloads;

  /**
   * Details of the power source on an entity
   *
   * @generated from field: anduril.entitymanager.v1.PowerState power_state = 30;
   */
  powerState?: PowerState;

  /**
   * The primary data source provenance for this entity
   *
   * @generated from field: anduril.entitymanager.v1.Provenance provenance = 12;
   */
  provenance?: Provenance;

  /**
   * Provenance of override data
   *
   * @generated from field: anduril.entitymanager.v1.Overrides overrides = 13;
   */
  overrides?: Overrides;

  /**
   * Indicators of an entity's state that describes properties of the entity as well as what operations can be performed on the entity (eg.
   * can it be deleted)
   *
   * @generated from field: anduril.entitymanager.v1.Indicators indicators = 14;
   */
  indicators?: Indicators;

  /**
   * A component that references the primary original data source. For example, this would allow the original NITF file
   * data that was ingested to be retrieved.
   *
   * @generated from field: anduril.entitymanager.v1.OriginalData original_data = 18;
   */
  originalData?: OriginalData;

  /**
   * The prioritization associated with an entity such as if it's a threat or a high value target.
   *
   * @generated from field: anduril.entitymanager.v1.TargetPriority target_priority = 22;
   */
  targetPriority?: TargetPriority;

  /**
   * A component that describes an entity's signal characteristics. Primarily used if the entity is a signal of interest
   *
   * @generated from field: anduril.entitymanager.v1.Signal signal = 25;
   */
  signal?: Signal;

  /**
   * A message describing any transponder codes associated with Mode 1, 2, 3, 4, 5, S interrogations. These are related to ADS-B modes
   *
   * @generated from field: anduril.entitymanager.v1.TransponderCodes transponder_codes = 26;
   */
  transponderCodes?: TransponderCodes;

  /**
   * Contains details on how to make out-of-band contact with an entity, such as via a phone or email
   *
   * @generated from field: anduril.entitymanager.v1.ContactDetails contact = 27;
   */
  contact?: ContactDetails;

  /**
   * A component that describes an entity's security classification levels both at an overall classification level for the entity as well as on a per
   * field level.
   *
   * @generated from field: anduril.entitymanager.v1.Classification data_classification = 29;
   */
  dataClassification?: Classification;

  /**
   * A catalog of tasks that can be performed by an entity.
   *
   * @generated from field: anduril.tasks.v2.TaskCatalog task_catalog = 31;
   */
  taskCatalog?: TaskCatalog;

  /**
   * Media associated with an entity such as videos, images or thumbnails.
   *
   * @generated from field: anduril.entitymanager.v1.Media media = 32;
   */
  media?: Media;

  /**
   * The relationships between this entity and other entities in the battlespace.
   *
   * @generated from field: anduril.entitymanager.v1.Relationships relationships = 33;
   */
  relationships?: Relationships;

  /**
   * Visual details associated with the display of an entity in the client.
   *
   * @generated from field: anduril.entitymanager.v1.VisualDetails visual_details = 34;
   */
  visualDetails?: VisualDetails;

  /**
   * A generic component that should only be used by Anduril employees as a way of ferrying data without modelling it as a full component. USE WITH CAUTION!!
   * The following should be considered before use:
   * If you have the time available, liaise with the battlespace team (#battlespace-team) to determine if this should be modelled on an existing/new component
   * You're responsible for handling key conflicts
   * Any data on here is not supported by the battlespace awareness team
   * The intention is for this to be used by short-lived prototypes where you may not have conviction in it's longevity
   * üôè
   *
   * @generated from field: anduril.entitymanager.v1.PrototypeExtensions prototype_extensions = 35;
   */
  prototypeExtensions?: PrototypeExtensions;

  /**
   * Physical dimensions of the entity
   *
   * @generated from field: anduril.entitymanager.v1.Dimensions dimensions = 36;
   */
  dimensions?: Dimensions;

  /**
   * Additional information about an entity's route.
   *
   * @generated from field: anduril.entitymanager.v1.RouteDetails route_details = 37;
   */
  routeDetails?: RouteDetails;

  /**
   * Schedules associated with this entity
   *
   * @generated from field: anduril.entitymanager.v1.Schedules schedules = 38;
   */
  schedules?: Schedules;

  /**
   * Health metrics or status reported by the entity
   *
   * @generated from field: anduril.entitymanager.v1.Health health = 39;
   */
  health?: Health;

  /**
   * Details for the group associated with this entity
   *
   * @generated from field: anduril.entitymanager.v1.GroupDetails group_details = 40;
   */
  groupDetails?: GroupDetails;

  /**
   * Describes an entity's collaborative autonomous teaming status, if any.
   *
   * @generated from field: anduril.entitymanager.v1.TeamStatus team_status = 41;
   */
  teamStatus?: TeamStatus;

  /**
   * Contains relevant supply information for the entity (e.g., munitions and fuel)
   *
   * @generated from field: anduril.entitymanager.v1.Supplies supplies = 42;
   */
  supplies?: Supplies;

  constructor(data?: PartialMessage<Entity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Entity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "is_live", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "created_time", kind: "message", T: Timestamp },
    { no: 5, name: "expiry_time", kind: "message", T: Timestamp },
    { no: 43, name: "no_expiry", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 19, name: "status", kind: "message", T: Status },
    { no: 6, name: "location", kind: "message", T: Location },
    { no: 15, name: "location_uncertainty", kind: "message", T: LocationUncertainty },
    { no: 17, name: "geopolygon", kind: "message", T: GeoPolygon },
    { no: 23, name: "geo_shape", kind: "message", T: GeoShape },
    { no: 24, name: "geo_details", kind: "message", T: GeoDetails },
    { no: 7, name: "aliases", kind: "message", T: Aliases },
    { no: 8, name: "tracked", kind: "message", T: Tracked },
    { no: 9, name: "correlated", kind: "message", T: Correlated },
    { no: 10, name: "mil_view", kind: "message", T: MilView },
    { no: 11, name: "ontology", kind: "message", T: Ontology },
    { no: 20, name: "sensors", kind: "message", T: Sensors },
    { no: 21, name: "payloads", kind: "message", T: Payloads },
    { no: 30, name: "power_state", kind: "message", T: PowerState },
    { no: 12, name: "provenance", kind: "message", T: Provenance },
    { no: 13, name: "overrides", kind: "message", T: Overrides },
    { no: 14, name: "indicators", kind: "message", T: Indicators },
    { no: 18, name: "original_data", kind: "message", T: OriginalData },
    { no: 22, name: "target_priority", kind: "message", T: TargetPriority },
    { no: 25, name: "signal", kind: "message", T: Signal },
    { no: 26, name: "transponder_codes", kind: "message", T: TransponderCodes },
    { no: 27, name: "contact", kind: "message", T: ContactDetails },
    { no: 29, name: "data_classification", kind: "message", T: Classification },
    { no: 31, name: "task_catalog", kind: "message", T: TaskCatalog },
    { no: 32, name: "media", kind: "message", T: Media },
    { no: 33, name: "relationships", kind: "message", T: Relationships },
    { no: 34, name: "visual_details", kind: "message", T: VisualDetails },
    { no: 35, name: "prototype_extensions", kind: "message", T: PrototypeExtensions },
    { no: 36, name: "dimensions", kind: "message", T: Dimensions },
    { no: 37, name: "route_details", kind: "message", T: RouteDetails },
    { no: 38, name: "schedules", kind: "message", T: Schedules },
    { no: 39, name: "health", kind: "message", T: Health },
    { no: 40, name: "group_details", kind: "message", T: GroupDetails },
    { no: 41, name: "team_status", kind: "message", T: TeamStatus },
    { no: 42, name: "supplies", kind: "message", T: Supplies },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Entity {
    return new Entity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Entity {
    return new Entity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Entity {
    return new Entity().fromJsonString(jsonString, options);
  }

  static equals(a: Entity | PlainMessage<Entity> | undefined, b: Entity | PlainMessage<Entity> | undefined): boolean {
    return proto3.util.equals(Entity, a, b);
  }
}

/**
 * We need a proto containing a list of Entities for marshalling/unmarshalling
 *
 * @generated from message anduril.entitymanager.v1.Entities
 */
export class Entities extends Message<Entities> {
  /**
   * @generated from field: repeated anduril.entitymanager.v1.Entity entities = 1;
   */
  entities: Entity[] = [];

  constructor(data?: PartialMessage<Entities>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Entities";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entities", kind: "message", T: Entity, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Entities {
    return new Entities().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Entities {
    return new Entities().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Entities {
    return new Entities().fromJsonString(jsonString, options);
  }

  static equals(a: Entities | PlainMessage<Entities> | undefined, b: Entities | PlainMessage<Entities> | undefined): boolean {
    return proto3.util.equals(Entities, a, b);
  }
}

/**
 * Contains status of entities.
 *
 * @generated from message anduril.entitymanager.v1.Status
 */
export class Status extends Message<Status> {
  /**
   * A string that describes the activity that the entity is performing. These values
   * include, but are not limited to the AIR/SURFACE/SUBSURFACE/LAND/SPACE ACTIVITY values found in MIL-STD 6016F.
   * Examples include "RECONNAISSANCE", "INTERDICTION", "ELECTRONIC WARFARE (EW)", "RETURN TO BASE (RTB)", "PREPARING
   * FOR LAUNCH".
   *
   * @generated from field: string platform_activity = 1;
   */
  platformActivity = "";

  /**
   * A string that describes the role the entity is currently performing. E.g. "Team Member", "Commander" or
   *
   * @generated from field: string role = 2;
   */
  role = "";

  constructor(data?: PartialMessage<Status>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Status";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "platform_activity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Status {
    return new Status().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Status {
    return new Status().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Status {
    return new Status().fromJsonString(jsonString, options);
  }

  static equals(a: Status | PlainMessage<Status> | undefined, b: Status | PlainMessage<Status> | undefined): boolean {
    return proto3.util.equals(Status, a, b);
  }
}

/**
 * Available for any Entities with alternate ids in other systems.
 *
 * @generated from message anduril.entitymanager.v1.Aliases
 */
export class Aliases extends Message<Aliases> {
  /**
   * @generated from field: repeated anduril.entitymanager.v1.AlternateId alternate_ids = 1;
   */
  alternateIds: AlternateId[] = [];

  /**
   * The best available version of the entity's display name.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  constructor(data?: PartialMessage<Aliases>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Aliases";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "alternate_ids", kind: "message", T: AlternateId, repeated: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Aliases {
    return new Aliases().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Aliases {
    return new Aliases().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Aliases {
    return new Aliases().fromJsonString(jsonString, options);
  }

  static equals(a: Aliases | PlainMessage<Aliases> | undefined, b: Aliases | PlainMessage<Aliases> | undefined): boolean {
    return proto3.util.equals(Aliases, a, b);
  }
}

/**
 * Available for Entities that are tracked.
 *
 * @generated from message anduril.entitymanager.v1.Tracked
 */
export class Tracked extends Message<Tracked> {
  /**
   * deprecated in favor of track_quality_wrapper to better indicate when TQ is actually missing vs 0 which is valid
   *
   * @generated from field: uint32 track_quality = 1 [deprecated = true];
   * @deprecated
   */
  trackQuality = 0;

  /**
   * Quality score, 0-15, nil if none
   *
   * @generated from field: google.protobuf.Int32Value track_quality_wrapper = 2;
   */
  trackQualityWrapper?: number;

  /**
   * Sensor hits aggregation on the tracked entity.
   *
   * @generated from field: google.protobuf.Int32Value sensor_hits = 3;
   */
  sensorHits?: number;

  /**
   * Estimated number of objects or units that are represented by this entity. Known as Strength in certain contexts (Link16)
   * if UpperBound == LowerBound; (strength = LowerBound)
   * If both UpperBound and LowerBound are defined; strength is between LowerBound and UpperBound (represented as string "Strength: 4-5")
   * If UpperBound is defined only (LowerBound unset), Strength ‚â§ UpperBound
   * If LowerBound is defined only (UpperBound unset), LowerBound ‚â§ Strength
   * 0 indicates unset.
   *
   * @generated from field: anduril.entitymanager.v1.UInt32Range number_of_objects = 4;
   */
  numberOfObjects?: UInt32Range;

  /**
   * deprecated. data from sensors actively tracking the entity are placed in the TrackedBy relationship.
   *
   * @generated from field: anduril.entitymanager.v1.Sensors sensor_details = 5 [deprecated = true];
   * @deprecated
   */
  sensorDetails?: Sensors;

  /**
   * The radar cross section (RCS) is a measure of how detectable an object is by radar. A large RCS indicates an object is more easily
   * detected. The unit is ‚Äúdecibels per square meter,‚Äù or dBsm
   *
   * @generated from field: google.protobuf.DoubleValue radar_cross_section = 6;
   */
  radarCrossSection?: number;

  /**
   * Timestamp of the latest tracking measurement for this entity.
   *
   * @generated from field: google.protobuf.Timestamp last_measurement_time = 7;
   */
  lastMeasurementTime?: Timestamp;

  /**
   * The relative position of a track with respect to the entity that is tracking it. Used for tracks that do not yet have a 3D position.
   * For this entity (A), being tracked by some entity (B), this LineOfBearing would express a ray from B to A.
   *
   * @generated from field: anduril.entitymanager.v1.LineOfBearing line_of_bearing = 9;
   */
  lineOfBearing?: LineOfBearing;

  constructor(data?: PartialMessage<Tracked>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Tracked";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "track_quality", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "track_quality_wrapper", kind: "message", T: Int32Value },
    { no: 3, name: "sensor_hits", kind: "message", T: Int32Value },
    { no: 4, name: "number_of_objects", kind: "message", T: UInt32Range },
    { no: 5, name: "sensor_details", kind: "message", T: Sensors },
    { no: 6, name: "radar_cross_section", kind: "message", T: DoubleValue },
    { no: 7, name: "last_measurement_time", kind: "message", T: Timestamp },
    { no: 9, name: "line_of_bearing", kind: "message", T: LineOfBearing },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Tracked {
    return new Tracked().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Tracked {
    return new Tracked().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Tracked {
    return new Tracked().fromJsonString(jsonString, options);
  }

  static equals(a: Tracked | PlainMessage<Tracked> | undefined, b: Tracked | PlainMessage<Tracked> | undefined): boolean {
    return proto3.util.equals(Tracked, a, b);
  }
}

/**
 * Data provenance.
 *
 * @generated from message anduril.entitymanager.v1.Provenance
 */
export class Provenance extends Message<Provenance> {
  /**
   * Name of the integration that produced this entity
   *
   * @generated from field: string integration_name = 5;
   */
  integrationName = "";

  /**
   * Source data type of this entity. Examples: ADSB, Link16, etc.
   *
   * @generated from field: string data_type = 6;
   */
  dataType = "";

  /**
   * Enum defining the source TO BE DEPRECATED
   *
   * @generated from field: anduril.entitymanager.v1.Source source = 1;
   */
  source = Source.INVALID;

  /**
   * An ID that allows an element from a source to be uniquely identified
   *
   * @generated from field: string source_id = 3;
   */
  sourceId = "";

  /**
   * Main update timer for the entity with the exception of overrides
   *
   * @generated from field: google.protobuf.Timestamp source_update_time = 2;
   */
  sourceUpdateTime?: Timestamp;

  /**
   * Description of the modification source. In the case of a user this is the email address.
   *
   * @generated from field: string source_description = 4;
   */
  sourceDescription = "";

  constructor(data?: PartialMessage<Provenance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Provenance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "integration_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "data_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "source", kind: "enum", T: proto3.getEnumType(Source) },
    { no: 3, name: "source_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "source_update_time", kind: "message", T: Timestamp },
    { no: 4, name: "source_description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Provenance {
    return new Provenance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Provenance {
    return new Provenance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Provenance {
    return new Provenance().fromJsonString(jsonString, options);
  }

  static equals(a: Provenance | PlainMessage<Provenance> | undefined, b: Provenance | PlainMessage<Provenance> | undefined): boolean {
    return proto3.util.equals(Provenance, a, b);
  }
}

/**
 * Indicators to describe entity to consumers.
 *
 * @generated from message anduril.entitymanager.v1.Indicators
 */
export class Indicators extends Message<Indicators> {
  /**
   * @generated from field: google.protobuf.BoolValue simulated = 1;
   */
  simulated?: boolean;

  /**
   * @generated from field: google.protobuf.BoolValue exercise = 2;
   */
  exercise?: boolean;

  /**
   * @generated from field: google.protobuf.BoolValue emergency = 3;
   */
  emergency?: boolean;

  /**
   * @generated from field: google.protobuf.BoolValue c2 = 4;
   */
  c2?: boolean;

  /**
   * @generated from field: anduril.entitymanager.v1.Deletable deletable = 5;
   */
  deletable = Deletable.INVALID;

  /**
   * Indicates the Entity should be egressed to external sources.
   * Integrations choose how the egressing happens (e.g. if an Entity needs fuzzing).
   *
   * @generated from field: google.protobuf.BoolValue egressable = 6;
   */
  egressable?: boolean;

  /**
   * A signal of arbitrary importance such that the entity should be globally marked for all users
   *
   * @generated from field: google.protobuf.BoolValue starred = 7;
   */
  starred?: boolean;

  constructor(data?: PartialMessage<Indicators>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Indicators";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "simulated", kind: "message", T: BoolValue },
    { no: 2, name: "exercise", kind: "message", T: BoolValue },
    { no: 3, name: "emergency", kind: "message", T: BoolValue },
    { no: 4, name: "c2", kind: "message", T: BoolValue },
    { no: 5, name: "deletable", kind: "enum", T: proto3.getEnumType(Deletable) },
    { no: 6, name: "egressable", kind: "message", T: BoolValue },
    { no: 7, name: "starred", kind: "message", T: BoolValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Indicators {
    return new Indicators().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Indicators {
    return new Indicators().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Indicators {
    return new Indicators().fromJsonString(jsonString, options);
  }

  static equals(a: Indicators | PlainMessage<Indicators> | undefined, b: Indicators | PlainMessage<Indicators> | undefined): boolean {
    return proto3.util.equals(Indicators, a, b);
  }
}

/**
 * Metadata about entity overrides present.
 *
 * @generated from message anduril.entitymanager.v1.Overrides
 */
export class Overrides extends Message<Overrides> {
  /**
   * @generated from field: repeated anduril.entitymanager.v1.Override override = 2;
   */
  override: Override[] = [];

  /**
   * Deprecated: do not use
   *
   * @generated from field: repeated anduril.entitymanager.v1.OverrideProvenance provenance = 1 [deprecated = true];
   * @deprecated
   */
  provenance: OverrideProvenance[] = [];

  constructor(data?: PartialMessage<Overrides>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Overrides";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "override", kind: "message", T: Override, repeated: true },
    { no: 1, name: "provenance", kind: "message", T: OverrideProvenance, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Overrides {
    return new Overrides().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Overrides {
    return new Overrides().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Overrides {
    return new Overrides().fromJsonString(jsonString, options);
  }

  static equals(a: Overrides | PlainMessage<Overrides> | undefined, b: Overrides | PlainMessage<Overrides> | undefined): boolean {
    return proto3.util.equals(Overrides, a, b);
  }
}

/**
 * Details about an override. Last write wins.
 *
 * @generated from message anduril.entitymanager.v1.Override
 */
export class Override extends Message<Override> {
  /**
   * override request id for an override request
   *
   * @generated from field: string request_id = 1;
   */
  requestId = "";

  /**
   * proto field path which is the string representation of a field.
   * example: correlated.primary_entity_id would be primary_entity_id in correlated component
   *
   * @generated from field: string field_path = 2;
   */
  fieldPath = "";

  /**
   * new field value corresponding to field path. In the shape of an empty entity with only the changed value.
   * example: entity: { mil_view: { disposition: Disposition_DISPOSITION_HOSTILE } }
   *
   * @generated from field: anduril.entitymanager.v1.Entity masked_field_value = 3;
   */
  maskedFieldValue?: Entity;

  /**
   * status of the override
   *
   * @generated from field: anduril.entitymanager.v1.OverrideStatus status = 4;
   */
  status = OverrideStatus.INVALID;

  /**
   * @generated from field: anduril.entitymanager.v1.Provenance provenance = 5;
   */
  provenance?: Provenance;

  /**
   * The type of the override, defined by the stage of the entity lifecycle that the entity was in when the override
   * was requested.
   *
   * @generated from field: anduril.entitymanager.v1.OverrideType type = 6;
   */
  type = OverrideType.INVALID;

  /**
   * Timestamp of the override request. The timestamp is generated by the Entity Manager instance that receives the request.
   *
   * @generated from field: google.protobuf.Timestamp request_timestamp = 7;
   */
  requestTimestamp?: Timestamp;

  constructor(data?: PartialMessage<Override>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.Override";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "masked_field_value", kind: "message", T: Entity },
    { no: 4, name: "status", kind: "enum", T: proto3.getEnumType(OverrideStatus) },
    { no: 5, name: "provenance", kind: "message", T: Provenance },
    { no: 6, name: "type", kind: "enum", T: proto3.getEnumType(OverrideType) },
    { no: 7, name: "request_timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Override {
    return new Override().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Override {
    return new Override().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Override {
    return new Override().fromJsonString(jsonString, options);
  }

  static equals(a: Override | PlainMessage<Override> | undefined, b: Override | PlainMessage<Override> | undefined): boolean {
    return proto3.util.equals(Override, a, b);
  }
}

/**
 * The provenance of a particular override within the entity.
 *
 * @generated from message anduril.entitymanager.v1.OverrideProvenance
 * @deprecated
 */
export class OverrideProvenance extends Message<OverrideProvenance> {
  /**
   * proto field path which is the string representation of a field.
   * example: correlated.primary_entity_id would be primary_entity_id in correlated component
   *
   * @generated from field: string field_path = 1;
   */
  fieldPath = "";

  /**
   * Deprecated: do not use
   *
   * @generated from field: string source_id = 2 [deprecated = true];
   * @deprecated
   */
  sourceId = "";

  /**
   * @generated from field: anduril.entitymanager.v1.Provenance provenance = 3;
   */
  provenance?: Provenance;

  constructor(data?: PartialMessage<OverrideProvenance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.OverrideProvenance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "source_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "provenance", kind: "message", T: Provenance },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OverrideProvenance {
    return new OverrideProvenance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OverrideProvenance {
    return new OverrideProvenance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OverrideProvenance {
    return new OverrideProvenance().fromJsonString(jsonString, options);
  }

  static equals(a: OverrideProvenance | PlainMessage<OverrideProvenance> | undefined, b: OverrideProvenance | PlainMessage<OverrideProvenance> | undefined): boolean {
    return proto3.util.equals(OverrideProvenance, a, b);
  }
}

/**
 * A component that references the primary original data source. For example, this would allow the original NITF file
 * data that was ingested to be retrieved.
 *
 * @generated from message anduril.entitymanager.v1.OriginalData
 */
export class OriginalData extends Message<OriginalData> {
  /**
   * The URL is a reference to the data's location so it can be retrieved after being converted to an entity.
   *
   * @generated from field: string url = 1;
   */
  url = "";

  /**
   * @generated from field: anduril.entitymanager.v1.OriginalData.TLE tle = 2;
   */
  tle?: OriginalData_TLE;

  constructor(data?: PartialMessage<OriginalData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.OriginalData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tle", kind: "message", T: OriginalData_TLE },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OriginalData {
    return new OriginalData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OriginalData {
    return new OriginalData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OriginalData {
    return new OriginalData().fromJsonString(jsonString, options);
  }

  static equals(a: OriginalData | PlainMessage<OriginalData> | undefined, b: OriginalData | PlainMessage<OriginalData> | undefined): boolean {
    return proto3.util.equals(OriginalData, a, b);
  }
}

/**
 * A TLE is a space industry standard for representing the characteristics of an object on orbit.
 * It is composed of two lines that are each a fixed width of 69 characters.
 *
 * @generated from message anduril.entitymanager.v1.OriginalData.TLE
 */
export class OriginalData_TLE extends Message<OriginalData_TLE> {
  /**
   * @generated from field: string line1 = 1;
   */
  line1 = "";

  /**
   * @generated from field: string line2 = 2;
   */
  line2 = "";

  constructor(data?: PartialMessage<OriginalData_TLE>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.OriginalData.TLE";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "line1", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "line2", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OriginalData_TLE {
    return new OriginalData_TLE().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OriginalData_TLE {
    return new OriginalData_TLE().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OriginalData_TLE {
    return new OriginalData_TLE().fromJsonString(jsonString, options);
  }

  static equals(a: OriginalData_TLE | PlainMessage<OriginalData_TLE> | undefined, b: OriginalData_TLE | PlainMessage<OriginalData_TLE> | undefined): boolean {
    return proto3.util.equals(OriginalData_TLE, a, b);
  }
}

/**
 * An alternate id for an Entity.
 *
 * @generated from message anduril.entitymanager.v1.AlternateId
 */
export class AlternateId extends Message<AlternateId> {
  /**
   * deprecated in favor of type
   *
   * @generated from field: string source = 1 [deprecated = true];
   * @deprecated
   */
  source = "";

  /**
   * @generated from field: string id = 2;
   */
  id = "";

  /**
   * @generated from field: anduril.entitymanager.v1.AltIdType type = 3;
   */
  type = AltIdType.INVALID;

  constructor(data?: PartialMessage<AlternateId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.AlternateId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(AltIdType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlternateId {
    return new AlternateId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlternateId {
    return new AlternateId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlternateId {
    return new AlternateId().fromJsonString(jsonString, options);
  }

  static equals(a: AlternateId | PlainMessage<AlternateId> | undefined, b: AlternateId | PlainMessage<AlternateId> | undefined): boolean {
    return proto3.util.equals(AlternateId, a, b);
  }
}

/**
 * Visual details associated with the display of an entity in the client.
 *
 * @generated from message anduril.entitymanager.v1.VisualDetails
 */
export class VisualDetails extends Message<VisualDetails> {
  /**
   * The range rings to display around an entity.
   *
   * @generated from field: anduril.entitymanager.v1.RangeRings range_rings = 1;
   */
  rangeRings?: RangeRings;

  /**
   * Control the operator's ability to interact with the entity on the UI (disable hover/click on map, etc.)
   * Not a security/access flag
   *
   * @generated from field: anduril.entitymanager.v1.InteractivityMode interactivity_mode = 2;
   */
  interactivityMode = InteractivityMode.INVALID;

  constructor(data?: PartialMessage<VisualDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.VisualDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "range_rings", kind: "message", T: RangeRings },
    { no: 2, name: "interactivity_mode", kind: "enum", T: proto3.getEnumType(InteractivityMode) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VisualDetails {
    return new VisualDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VisualDetails {
    return new VisualDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VisualDetails {
    return new VisualDetails().fromJsonString(jsonString, options);
  }

  static equals(a: VisualDetails | PlainMessage<VisualDetails> | undefined, b: VisualDetails | PlainMessage<VisualDetails> | undefined): boolean {
    return proto3.util.equals(VisualDetails, a, b);
  }
}

/**
 * Range rings allow visual assessment of map distance at varying zoom levels.
 *
 * @generated from message anduril.entitymanager.v1.RangeRings
 */
export class RangeRings extends Message<RangeRings> {
  /**
   * The minimum range ring distance, specified in meters.
   *
   * @generated from field: google.protobuf.DoubleValue min_distance_m = 1;
   */
  minDistanceM?: number;

  /**
   * The maximum range ring distance, specified in meters.
   *
   * @generated from field: google.protobuf.DoubleValue max_distance_m = 2;
   */
  maxDistanceM?: number;

  /**
   * The count of range rings.
   *
   * @generated from field: uint32 ring_count = 3;
   */
  ringCount = 0;

  constructor(data?: PartialMessage<RangeRings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.RangeRings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min_distance_m", kind: "message", T: DoubleValue },
    { no: 2, name: "max_distance_m", kind: "message", T: DoubleValue },
    { no: 3, name: "ring_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RangeRings {
    return new RangeRings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RangeRings {
    return new RangeRings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RangeRings {
    return new RangeRings().fromJsonString(jsonString, options);
  }

  static equals(a: RangeRings | PlainMessage<RangeRings> | undefined, b: RangeRings | PlainMessage<RangeRings> | undefined): boolean {
    return proto3.util.equals(RangeRings, a, b);
  }
}

/**
 * If present, signifies the entity can participate in collaborative autonomous teaming.
 * Any status about team membership will be reported here.
 *
 * @generated from message anduril.entitymanager.v1.TeamStatus
 */
export class TeamStatus extends Message<TeamStatus> {
  constructor(data?: PartialMessage<TeamStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.TeamStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TeamStatus {
    return new TeamStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TeamStatus {
    return new TeamStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TeamStatus {
    return new TeamStatus().fromJsonString(jsonString, options);
  }

  static equals(a: TeamStatus | PlainMessage<TeamStatus> | undefined, b: TeamStatus | PlainMessage<TeamStatus> | undefined): boolean {
    return proto3.util.equals(TeamStatus, a, b);
  }
}

