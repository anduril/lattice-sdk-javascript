// @generated by protoc-gen-es v1.7.2 with parameter "js_import_style=legacy_commonjs"
// @generated from file anduril/entitymanager/v1/signal.pub.proto (package anduril.entitymanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Position } from "./location.pub_pb.js";
import type { Pose, TMat2 } from "../../type/coords.pub_pb.js";

/**
 * Enumerates the possible modulation types
 *
 * @generated from enum anduril.entitymanager.v1.ModulationType
 */
export declare enum ModulationType {
  /**
   * @generated from enum value: MODULATION_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: MODULATION_TYPE_AMPLITUDE = 1;
   */
  AMPLITUDE = 1,

  /**
   * @generated from enum value: MODULATION_TYPE_FREQUENCY = 2;
   */
  FREQUENCY = 2,

  /**
   * @generated from enum value: MODULATION_TYPE_PHASE = 3;
   */
  PHASE = 3,

  /**
   * @generated from enum value: MODULATION_TYPE_SPACED = 4;
   */
  SPACED = 4,

  /**
   * @generated from enum value: MODULATION_TYPE_AMPLITUDE_SHIFT_KEYING = 5;
   */
  AMPLITUDE_SHIFT_KEYING = 5,

  /**
   * @generated from enum value: MODULATION_TYPE_FREQUENCY_SHIFT_KEYING = 6;
   */
  FREQUENCY_SHIFT_KEYING = 6,

  /**
   * @generated from enum value: MODULATION_TYPE_PHASE_SHIFT_KEYING = 7;
   */
  PHASE_SHIFT_KEYING = 7,

  /**
   * @generated from enum value: MODULATION_TYPE_MINIMUM_SHIFT_KEYING = 8;
   */
  MINIMUM_SHIFT_KEYING = 8,

  /**
   * @generated from enum value: MODULATION_TYPE_MINIMUM_SHIFT_KEYING_GAUSSIAN = 9;
   */
  MINIMUM_SHIFT_KEYING_GAUSSIAN = 9,

  /**
   * @generated from enum value: MODULATION_TYPE_SINGLE_SIDE_BAND_UPPER = 10;
   */
  SINGLE_SIDE_BAND_UPPER = 10,

  /**
   * @generated from enum value: MODULATION_TYPE_SINGLE_SIDE_BAND_LOWER = 11;
   */
  SINGLE_SIDE_BAND_LOWER = 11,

  /**
   * @generated from enum value: MODULATION_TYPE_SINGLE_SIDE_BAND_FULL_CARRIER = 12;
   */
  SINGLE_SIDE_BAND_FULL_CARRIER = 12,

  /**
   * @generated from enum value: MODULATION_TYPE_SINGLE_SIDE_BAND_SUPPRESSED_CARRIER = 13;
   */
  SINGLE_SIDE_BAND_SUPPRESSED_CARRIER = 13,

  /**
   * @generated from enum value: MODULATION_TYPE_SINGLE_SIDE_BAND_REDUCED_CARRIER = 14;
   */
  SINGLE_SIDE_BAND_REDUCED_CARRIER = 14,

  /**
   * @generated from enum value: MODULATION_TYPE_SINGLE_SIDE_BAND_WITHOUT_CARRIER = 15;
   */
  SINGLE_SIDE_BAND_WITHOUT_CARRIER = 15,

  /**
   * @generated from enum value: MODULATION_TYPE_DUAL_SIDE_BAND_FULL_CARRIER = 16;
   */
  DUAL_SIDE_BAND_FULL_CARRIER = 16,

  /**
   * @generated from enum value: MODULATION_TYPE_DUAL_SIDE_BAND_SUPPRESSED_CARRIER = 17;
   */
  DUAL_SIDE_BAND_SUPPRESSED_CARRIER = 17,

  /**
   * @generated from enum value: MODULATION_TYPE_DUAL_SIDE_BAND_REDUCED_CARRIER = 18;
   */
  DUAL_SIDE_BAND_REDUCED_CARRIER = 18,

  /**
   * @generated from enum value: MODULATION_TYPE_DUAL_SIDE_BAND_WITHOUT_CARRIER = 19;
   */
  DUAL_SIDE_BAND_WITHOUT_CARRIER = 19,

  /**
   * @generated from enum value: MODULATION_TYPE_INDEPENDENT_SIDE_BAND = 20;
   */
  INDEPENDENT_SIDE_BAND = 20,

  /**
   * @generated from enum value: MODULATION_TYPE_VESTIGIAL_SIDE_BAND = 21;
   */
  VESTIGIAL_SIDE_BAND = 21,

  /**
   * @generated from enum value: MODULATION_TYPE_ON_OFF_KEYING = 22;
   */
  ON_OFF_KEYING = 22,

  /**
   * @generated from enum value: MODULATION_TYPE_MULTI_FREQUENCY_SHIFT_KEYING = 23;
   */
  MULTI_FREQUENCY_SHIFT_KEYING = 23,

  /**
   * @generated from enum value: MODULATION_TYPE_AUDIO_FREQUENCY_SHIFT_KEYING = 24;
   */
  AUDIO_FREQUENCY_SHIFT_KEYING = 24,

  /**
   * @generated from enum value: MODULATION_TYPE_CONTINUOUS_PHASE_FREQUENCY_SHIFT_KEYING = 25;
   */
  CONTINUOUS_PHASE_FREQUENCY_SHIFT_KEYING = 25,

  /**
   * @generated from enum value: MODULATION_TYPE_C_PHASE_SHIFT_KEYING = 26;
   */
  C_PHASE_SHIFT_KEYING = 26,

  /**
   * @generated from enum value: MODULATION_TYPE_DIFFERENTIALLY_ENCODED_BINARY_PHASE_SHIFT_KEYING = 27;
   */
  DIFFERENTIALLY_ENCODED_BINARY_PHASE_SHIFT_KEYING = 27,

  /**
   * @generated from enum value: MODULATION_TYPE_DIFFERENTIALLY_ENCODED_QUADRATURE_PHASE_SHIFT_KEYING = 28;
   */
  DIFFERENTIALLY_ENCODED_QUADRATURE_PHASE_SHIFT_KEYING = 28,

  /**
   * @generated from enum value: MODULATION_TYPE_OFFSET_QUADRATURE_PHASE_SHIFT_KEYING = 29;
   */
  OFFSET_QUADRATURE_PHASE_SHIFT_KEYING = 29,

  /**
   * @generated from enum value: MODULATION_TYPE_DIFFERENTIAL_PHASE_SHIFT_KEYING = 30;
   */
  DIFFERENTIAL_PHASE_SHIFT_KEYING = 30,

  /**
   * @generated from enum value: MODULATION_TYPE_PI_4_QUADRATURE_PHASE_SHIFT_KEYING = 31;
   */
  PI_4_QUADRATURE_PHASE_SHIFT_KEYING = 31,

  /**
   * @generated from enum value: MODULATION_TYPE_STACKED_OVERLAPPING_QUADRATURE_PHASE_SHIFT_KEYING = 32;
   */
  STACKED_OVERLAPPING_QUADRATURE_PHASE_SHIFT_KEYING = 32,

  /**
   * @generated from enum value: MODULATION_TYPE_F_QUADRATURE_PHASE_SHIFT_KEYING = 33;
   */
  F_QUADRATURE_PHASE_SHIFT_KEYING = 33,

  /**
   * @generated from enum value: MODULATION_TYPE_QUADRATURE_AMPLITUDE_ANALOG = 34;
   */
  QUADRATURE_AMPLITUDE_ANALOG = 34,

  /**
   * @generated from enum value: MODULATION_TYPE_QUADRATURE_AMPLITUDE_DIGITAL = 35;
   */
  QUADRATURE_AMPLITUDE_DIGITAL = 35,

  /**
   * @generated from enum value: MODULATION_TYPE_CONTINUOUS_PHASE = 36;
   */
  CONTINUOUS_PHASE = 36,

  /**
   * @generated from enum value: MODULATION_TYPE_PULSE_POSITION = 37;
   */
  PULSE_POSITION = 37,

  /**
   * @generated from enum value: MODULATION_TYPE_TRELLIS_CODE = 38;
   */
  TRELLIS_CODE = 38,

  /**
   * @generated from enum value: MODULATION_TYPE_ORTHOGONAL_FREQUENCY_DIVISION_MULTIPLEXING = 39;
   */
  ORTHOGONAL_FREQUENCY_DIVISION_MULTIPLEXING = 39,

  /**
   * @generated from enum value: MODULATION_TYPE_FREQUENCY_HOPPING_SPREAD_SPECTRUM = 40;
   */
  FREQUENCY_HOPPING_SPREAD_SPECTRUM = 40,

  /**
   * @generated from enum value: MODULATION_TYPE_DIGITAL_SEQUENCE_SPREAD_SPECTRUM = 41;
   */
  DIGITAL_SEQUENCE_SPREAD_SPECTRUM = 41,
}

/**
 * Enumerates the possible scan types
 *
 * @generated from enum anduril.entitymanager.v1.ScanType
 */
export declare enum ScanType {
  /**
   * @generated from enum value: SCAN_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: SCAN_TYPE_CIRCULAR = 1;
   */
  CIRCULAR = 1,

  /**
   * @generated from enum value: SCAN_TYPE_BIDIRECTIONAL_HORIZONTAL_SECTOR = 2;
   */
  BIDIRECTIONAL_HORIZONTAL_SECTOR = 2,

  /**
   * @generated from enum value: SCAN_TYPE_BIDIRECTIONAL_VERTICAL_SECTOR = 3;
   */
  BIDIRECTIONAL_VERTICAL_SECTOR = 3,

  /**
   * @generated from enum value: SCAN_TYPE_NON_SCANNING = 4;
   */
  NON_SCANNING = 4,

  /**
   * @generated from enum value: SCAN_TYPE_IRREGULAR = 5;
   */
  IRREGULAR = 5,

  /**
   * @generated from enum value: SCAN_TYPE_CONICAL = 6;
   */
  CONICAL = 6,

  /**
   * @generated from enum value: SCAN_TYPE_LOBE_SWITCHING = 7;
   */
  LOBE_SWITCHING = 7,

  /**
   * @generated from enum value: SCAN_TYPE_RASTER = 8;
   */
  RASTER = 8,

  /**
   * @generated from enum value: SCAN_TYPE_CIRCULAR_VERTICAL_SECTOR = 9;
   */
  CIRCULAR_VERTICAL_SECTOR = 9,

  /**
   * @generated from enum value: SCAN_TYPE_CIRCULAR_CONICAL = 10;
   */
  CIRCULAR_CONICAL = 10,

  /**
   * @generated from enum value: SCAN_TYPE_SECTOR_CONICAL = 11;
   */
  SECTOR_CONICAL = 11,

  /**
   * @generated from enum value: SCAN_TYPE_AGILE_BEAM = 12;
   */
  AGILE_BEAM = 12,

  /**
   * @generated from enum value: SCAN_TYPE_UNIDIRECTIONAL_VERTICAL_SECTOR = 13;
   */
  UNIDIRECTIONAL_VERTICAL_SECTOR = 13,

  /**
   * @generated from enum value: SCAN_TYPE_UNIDIRECTIONAL_HORIZONTAL_SECTOR = 14;
   */
  UNIDIRECTIONAL_HORIZONTAL_SECTOR = 14,

  /**
   * @generated from enum value: SCAN_TYPE_UNIDIRECTIONAL_SECTOR = 15;
   */
  UNIDIRECTIONAL_SECTOR = 15,

  /**
   * @generated from enum value: SCAN_TYPE_BIDIRECTIONAL_SECTOR = 16;
   */
  BIDIRECTIONAL_SECTOR = 16,
}

/**
 * A component that describes an entity's signal characteristics.
 *
 * @generated from message anduril.entitymanager.v1.Signal
 */
export declare class Signal extends Message<Signal> {
  /**
   * Indicates either a frequency range or a center frequency of this signal.
   *
   * @generated from oneof anduril.entitymanager.v1.Signal.frequency_measurement
   */
  frequencyMeasurement: {
    /**
     * @generated from field: anduril.entitymanager.v1.Frequency frequency_center = 1;
     */
    value: Frequency;
    case: "frequencyCenter";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.FrequencyRange frequency_range = 2;
     */
    value: FrequencyRange;
    case: "frequencyRange";
  } | { case: undefined; value?: undefined };

  /**
   * Indicates the bandwidth of a signal (Hz).
   *
   * @generated from field: google.protobuf.DoubleValue bandwidth_hz = 3;
   */
  bandwidthHz?: number;

  /**
   * Indicates the signal to noise (SNR) of this signal.
   *
   * @generated from field: google.protobuf.DoubleValue signal_to_noise_ratio = 4;
   */
  signalToNoiseRatio?: number;

  /**
   * Indicates the signal report.
   *
   * @generated from oneof anduril.entitymanager.v1.Signal.report
   */
  report: {
    /**
     * @generated from field: anduril.entitymanager.v1.LineOfBearing line_of_bearing = 5;
     */
    value: LineOfBearing;
    case: "lineOfBearing";
  } | {
    /**
     * @generated from field: anduril.entitymanager.v1.Fixed fixed = 6;
     */
    value: Fixed;
    case: "fixed";
  } | { case: undefined; value?: undefined };

  /**
   * Emitter notations associated with this entity.
   *
   * @generated from field: repeated anduril.entitymanager.v1.EmitterNotation emitter_notations = 7;
   */
  emitterNotations: EmitterNotation[];

  /**
   * length in time of a single pulse
   *
   * @generated from field: google.protobuf.DoubleValue pulse_width_s = 8;
   */
  pulseWidthS?: number;

  /**
   * length in time between the start of two pulses
   *
   * @generated from field: anduril.entitymanager.v1.PulseRepetitionInterval pulse_repetition_interval = 9;
   */
  pulseRepetitionInterval?: PulseRepetitionInterval;

  /**
   * characteristics of the carrier signal to transmit information
   *
   * @generated from field: anduril.entitymanager.v1.Modulation modulation = 10;
   */
  modulation?: Modulation;

  /**
   * describes how a signal is observing the environment
   *
   * @generated from field: anduril.entitymanager.v1.ScanCharacteristics scan_characteristics = 11;
   */
  scanCharacteristics?: ScanCharacteristics;

  constructor(data?: PartialMessage<Signal>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.Signal";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Signal;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Signal;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Signal;

  static equals(a: Signal | PlainMessage<Signal> | undefined, b: Signal | PlainMessage<Signal> | undefined): boolean;
}

/**
 * A representation of a single emitter notation.
 *
 * @generated from message anduril.entitymanager.v1.EmitterNotation
 */
export declare class EmitterNotation extends Message<EmitterNotation> {
  /**
   * @generated from field: string emitter_notation = 1;
   */
  emitterNotation: string;

  /**
   * confidence as a percentage that the emitter notation in this component is accurate
   *
   * @generated from field: google.protobuf.DoubleValue confidence = 2;
   */
  confidence?: number;

  constructor(data?: PartialMessage<EmitterNotation>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.EmitterNotation";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EmitterNotation;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EmitterNotation;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EmitterNotation;

  static equals(a: EmitterNotation | PlainMessage<EmitterNotation> | undefined, b: EmitterNotation | PlainMessage<EmitterNotation> | undefined): boolean;
}

/**
 * A component that describes some measured value with error.
 *
 * @generated from message anduril.entitymanager.v1.Measurement
 */
export declare class Measurement extends Message<Measurement> {
  /**
   * The value of the measurement.
   *
   * @generated from field: google.protobuf.DoubleValue value = 1;
   */
  value?: number;

  /**
   * Estimated one standard deviation in same unit as the value.
   *
   * @generated from field: google.protobuf.DoubleValue sigma = 2;
   */
  sigma?: number;

  constructor(data?: PartialMessage<Measurement>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.Measurement";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Measurement;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Measurement;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Measurement;

  static equals(a: Measurement | PlainMessage<Measurement> | undefined, b: Measurement | PlainMessage<Measurement> | undefined): boolean;
}

/**
 * A component for describing frequency.
 *
 * @generated from message anduril.entitymanager.v1.Frequency
 */
export declare class Frequency extends Message<Frequency> {
  /**
   * Indicates a frequency of a signal (Hz) with its standard deviation.
   *
   * @generated from field: anduril.entitymanager.v1.Measurement frequency_hz = 1;
   */
  frequencyHz?: Measurement;

  constructor(data?: PartialMessage<Frequency>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.Frequency";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Frequency;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Frequency;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Frequency;

  static equals(a: Frequency | PlainMessage<Frequency> | undefined, b: Frequency | PlainMessage<Frequency> | undefined): boolean;
}

/**
 * A component to represent a frequency range.
 *
 * @generated from message anduril.entitymanager.v1.FrequencyRange
 */
export declare class FrequencyRange extends Message<FrequencyRange> {
  /**
   * Indicates the lowest measured frequency of a signal (Hz).
   *
   * @generated from field: anduril.entitymanager.v1.Frequency minimum_frequency_hz = 1;
   */
  minimumFrequencyHz?: Frequency;

  /**
   * Indicates the maximum measured frequency of a signal (Hz).
   *
   * @generated from field: anduril.entitymanager.v1.Frequency maximum_frequency_hz = 2;
   */
  maximumFrequencyHz?: Frequency;

  constructor(data?: PartialMessage<FrequencyRange>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.FrequencyRange";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FrequencyRange;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FrequencyRange;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FrequencyRange;

  static equals(a: FrequencyRange | PlainMessage<FrequencyRange> | undefined, b: FrequencyRange | PlainMessage<FrequencyRange> | undefined): boolean;
}

/**
 * A line of bearing of a signal.
 *
 * @generated from message anduril.entitymanager.v1.LineOfBearing
 */
export declare class LineOfBearing extends Message<LineOfBearing> {
  /**
   * `origin` and `range_bearing` have been deprecated in favor of `angle_of_arrival`
   * The location of the asset at the time of measurement.
   *
   * @generated from field: anduril.entitymanager.v1.Position origin = 1 [deprecated = true];
   * @deprecated
   */
  origin?: Position;

  /**
   * Describes the horizontal angle with respect to true north.
   *
   * @generated from field: anduril.entitymanager.v1.RangeBearing range_bearing = 2 [deprecated = true];
   * @deprecated
   */
  rangeBearing?: RangeBearing;

  /**
   * The direction pointing from this entity to the detection
   *
   * @generated from field: anduril.entitymanager.v1.AngleOfArrival angle_of_arrival = 3;
   */
  angleOfArrival?: AngleOfArrival;

  /**
   * The range of the detection in the direction defined by the angle of arrival
   *
   * @generated from oneof anduril.entitymanager.v1.LineOfBearing.detection_range
   */
  detectionRange: {
    /**
     * The estimated distance of the detection
     *
     * @generated from field: anduril.entitymanager.v1.Measurement range_estimate_m = 4;
     */
    value: Measurement;
    case: "rangeEstimateM";
  } | {
    /**
     * The maximum distance of the detection
     *
     * @generated from field: anduril.entitymanager.v1.Measurement max_range_m = 5;
     */
    value: Measurement;
    case: "maxRangeM";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<LineOfBearing>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.LineOfBearing";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LineOfBearing;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LineOfBearing;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LineOfBearing;

  static equals(a: LineOfBearing | PlainMessage<LineOfBearing> | undefined, b: LineOfBearing | PlainMessage<LineOfBearing> | undefined): boolean;
}

/**
 * The direction from which the signal is received
 *
 * @generated from message anduril.entitymanager.v1.AngleOfArrival
 */
export declare class AngleOfArrival extends Message<AngleOfArrival> {
  /**
   * Origin (LLA) and attitude (relative to ENU) of a ray pointing towards the detection. The attitude represents a
   * forward-left-up (FLU) frame where the x-axis (1, 0, 0) is pointing towards the target.
   *
   * @generated from field: anduril.type.Pose relative_pose = 1;
   */
  relativePose?: Pose;

  /**
   * Bearing/elevation covariance matrix where bearing is defined in radians CCW+ about the z-axis from the x-axis of FLU frame
   * and elevation is positive down from the FL/XY plane.
   * mxx = bearing variance in rad^2
   * mxy = bearing/elevation covariance in rad^2
   * myy = elevation variance in rad^2
   *
   * @generated from field: anduril.type.TMat2 bearing_elevation_covariance_rad2 = 2;
   */
  bearingElevationCovarianceRad2?: TMat2;

  constructor(data?: PartialMessage<AngleOfArrival>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.AngleOfArrival";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AngleOfArrival;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AngleOfArrival;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AngleOfArrival;

  static equals(a: AngleOfArrival | PlainMessage<AngleOfArrival> | undefined, b: AngleOfArrival | PlainMessage<AngleOfArrival> | undefined): boolean;
}

/**
 * A fix of a signal. No extra fields but it is expected that location should be populated when using this report.
 *
 * @generated from message anduril.entitymanager.v1.Fixed
 */
export declare class Fixed extends Message<Fixed> {
  constructor(data?: PartialMessage<Fixed>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.Fixed";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Fixed;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Fixed;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Fixed;

  static equals(a: Fixed | PlainMessage<Fixed> | undefined, b: Fixed | PlainMessage<Fixed> | undefined): boolean;
}

/**
 * Describes range and vertical and horizontal angular measurements of an entity with respect to a target.
 *
 * @generated from message anduril.entitymanager.v1.RangeBearing
 */
export declare class RangeBearing extends Message<RangeBearing> {
  /**
   * The range to a target along the measured angle in meters with its one sigma error value.
   *
   * @generated from field: anduril.entitymanager.v1.Measurement range_m = 1;
   */
  rangeM?: Measurement;

  /**
   * Horizontal angle - degrees rotated clockwise from origin_heading: 0-360.
   * Sigma is the standard deviation of the horizontal angular measurement in decimal degrees: 0-180 degrees.
   *
   * @generated from field: anduril.entitymanager.v1.Measurement range_angle_d = 2;
   */
  rangeAngleD?: Measurement;

  constructor(data?: PartialMessage<RangeBearing>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.RangeBearing";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RangeBearing;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RangeBearing;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RangeBearing;

  static equals(a: RangeBearing | PlainMessage<RangeBearing> | undefined, b: RangeBearing | PlainMessage<RangeBearing> | undefined): boolean;
}

/**
 * A component that describe the length in time between two pulses
 *
 * @generated from message anduril.entitymanager.v1.PulseRepetitionInterval
 */
export declare class PulseRepetitionInterval extends Message<PulseRepetitionInterval> {
  /**
   * @generated from field: anduril.entitymanager.v1.Measurement pulse_repetition_interval_s = 1;
   */
  pulseRepetitionIntervalS?: Measurement;

  constructor(data?: PartialMessage<PulseRepetitionInterval>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.PulseRepetitionInterval";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PulseRepetitionInterval;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PulseRepetitionInterval;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PulseRepetitionInterval;

  static equals(a: PulseRepetitionInterval | PlainMessage<PulseRepetitionInterval> | undefined, b: PulseRepetitionInterval | PlainMessage<PulseRepetitionInterval> | undefined): boolean;
}

/**
 * A component that describe how information is encoded in a transmitted signal through a carrier signal
 *
 * @generated from message anduril.entitymanager.v1.Modulation
 */
export declare class Modulation extends Message<Modulation> {
  /**
   * Modifications to the carrier signal
   *
   * @generated from field: anduril.entitymanager.v1.ModulationType modulation_type = 1;
   */
  modulationType: ModulationType;

  /**
   * describes the number of "symbols" that could be communicated with the modulation type
   * if modulation type is ASK and symbol is 4, signal could have 1 of 4 different amplitudes.
   *
   * @generated from field: google.protobuf.Int32Value symbols = 2;
   */
  symbols?: number;

  /**
   * Variations in the time intervals between pulses and the spacing and number of pulses in a series
   *
   * @generated from field: string interpulse_modulation = 3;
   */
  interpulseModulation: string;

  /**
   * describes how information is formatted within the signal during transmission
   *
   * @generated from field: anduril.entitymanager.v1.Encoding encoding = 4;
   */
  encoding?: Encoding;

  constructor(data?: PartialMessage<Modulation>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.Modulation";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Modulation;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Modulation;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Modulation;

  static equals(a: Modulation | PlainMessage<Modulation> | undefined, b: Modulation | PlainMessage<Modulation> | undefined): boolean;
}

/**
 * A component that describes the formatting of the information in a signal
 *
 * @generated from message anduril.entitymanager.v1.Encoding
 */
export declare class Encoding extends Message<Encoding> {
  /**
   * rate at which the spreading code is changing
   * a chip is a pulse of a spread spectrum code. Each data bit is spread across multiple chips (smaller time slots) using a spreading code
   *
   * @generated from field: google.protobuf.DoubleValue chip_hop_rate_num_sec = 1;
   */
  chipHopRateNumSec?: number;

  /**
   * time a transmitter remains at a particular frequency before hopping to the next on
   *
   * @generated from field: google.protobuf.DoubleValue hop_dwell_time_sec = 2;
   */
  hopDwellTimeSec?: number;

  /**
   * symbols per sec. A symbol is distinct from a bit where one symbol could be composed of multiple bits
   *
   * @generated from field: google.protobuf.DoubleValue baud_rate_num_sec = 3;
   */
  baudRateNumSec?: number;

  constructor(data?: PartialMessage<Encoding>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.Encoding";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Encoding;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Encoding;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Encoding;

  static equals(a: Encoding | PlainMessage<Encoding> | undefined, b: Encoding | PlainMessage<Encoding> | undefined): boolean;
}

/**
 * A component that describes the scanning characteristics of a signal
 *
 * @generated from message anduril.entitymanager.v1.ScanCharacteristics
 */
export declare class ScanCharacteristics extends Message<ScanCharacteristics> {
  /**
   * @generated from field: anduril.entitymanager.v1.ScanType scan_type = 1;
   */
  scanType: ScanType;

  /**
   * @generated from field: google.protobuf.DoubleValue scan_period_s = 2;
   */
  scanPeriodS?: number;

  constructor(data?: PartialMessage<ScanCharacteristics>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entitymanager.v1.ScanCharacteristics";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScanCharacteristics;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScanCharacteristics;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScanCharacteristics;

  static equals(a: ScanCharacteristics | PlainMessage<ScanCharacteristics> | undefined, b: ScanCharacteristics | PlainMessage<ScanCharacteristics> | undefined): boolean;
}

