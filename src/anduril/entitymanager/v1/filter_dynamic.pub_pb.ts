// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/entitymanager/v1/filter_dynamic.pub.proto (package anduril.entitymanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Statement } from "./filter.pub_pb.js";

/**
 * A DynamicStatement is the building block of a "runtime aware" entity filter - that is, any filter
 * which needs to perform operations against a series of entities that will need to be evaluated against
 * on demand. The DynamicStatement allows you to perform a set intersection operation across a static
 * set of entities dictated by a filter, and a dynamic set of entities dictated by a selector statement.
 *
 * For example, the expression "find me all hostile entities that reside within any assumed
 * friendly geoentity" would be represented as the following dynamic statement:
 *
 *  DynamicStatement
 *    filter
 *      predicate
 *        field_path: mil_view.disposition
 *        comparator: EQUALITY
 *        value: 2 // Hostile
 *    selector
 *      andOperation
 *        predicate1
 *          field_path: mil_view.disposition
 *          comparator: EQUALITY
 *          value: 4 // Assumed Friendly
 *        predicate2
 *          field_path: ontology.template
 *          comparator: EQUALITY
 *          value: 4 // Template Geo
 *    comparator
 *      IntersectionComparator
 *        WithinComparison
 *
 * @generated from message anduril.entitymanager.v1.DynamicStatement
 */
export class DynamicStatement extends Message<DynamicStatement> {
  /**
   * The filter statement is used to determine which entities can be compared to the dynamic series
   * of entities aggregated by the selector statement.
   *
   * @generated from field: anduril.entitymanager.v1.Statement filter = 1;
   */
  filter?: Statement;

  /**
   * The selector statement is used to determine which entities should be a part of dynamically
   * changing set. The selector should be reevaluated as entites are created or deleted.
   *
   * @generated from field: anduril.entitymanager.v1.Statement selector = 2;
   */
  selector?: Statement;

  /**
   * The comparator specifies how the set intersection operation will be performed.
   *
   * @generated from field: anduril.entitymanager.v1.IntersectionComparator comparator = 3;
   */
  comparator?: IntersectionComparator;

  constructor(data?: PartialMessage<DynamicStatement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.DynamicStatement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filter", kind: "message", T: Statement },
    { no: 2, name: "selector", kind: "message", T: Statement },
    { no: 3, name: "comparator", kind: "message", T: IntersectionComparator },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DynamicStatement {
    return new DynamicStatement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DynamicStatement {
    return new DynamicStatement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DynamicStatement {
    return new DynamicStatement().fromJsonString(jsonString, options);
  }

  static equals(a: DynamicStatement | PlainMessage<DynamicStatement> | undefined, b: DynamicStatement | PlainMessage<DynamicStatement> | undefined): boolean {
    return proto3.util.equals(DynamicStatement, a, b);
  }
}

/**
 * The IntersectionComparator determines what entities and what fields to respect within a set during
 * a set intersection operation.
 *
 * @generated from message anduril.entitymanager.v1.IntersectionComparator
 */
export class IntersectionComparator extends Message<IntersectionComparator> {
  /**
   * @generated from oneof anduril.entitymanager.v1.IntersectionComparator.comparison
   */
  comparison: {
    /**
     * @generated from field: anduril.entitymanager.v1.WithinComparison within_comparison = 1;
     */
    value: WithinComparison;
    case: "withinComparison";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<IntersectionComparator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.IntersectionComparator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "within_comparison", kind: "message", T: WithinComparison, oneof: "comparison" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntersectionComparator {
    return new IntersectionComparator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntersectionComparator {
    return new IntersectionComparator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntersectionComparator {
    return new IntersectionComparator().fromJsonString(jsonString, options);
  }

  static equals(a: IntersectionComparator | PlainMessage<IntersectionComparator> | undefined, b: IntersectionComparator | PlainMessage<IntersectionComparator> | undefined): boolean {
    return proto3.util.equals(IntersectionComparator, a, b);
  }
}

/**
 * The WithinComparison implicitly will understand how to determine which entitites reside
 * within other geo-shaped entities. This comparison is being left empty, but as a proto, to
 * support future expansions of the within comparison (eg; within range of a static distance).
 *
 * @generated from message anduril.entitymanager.v1.WithinComparison
 */
export class WithinComparison extends Message<WithinComparison> {
  constructor(data?: PartialMessage<WithinComparison>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entitymanager.v1.WithinComparison";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WithinComparison {
    return new WithinComparison().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WithinComparison {
    return new WithinComparison().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WithinComparison {
    return new WithinComparison().fromJsonString(jsonString, options);
  }

  static equals(a: WithinComparison | PlainMessage<WithinComparison> | undefined, b: WithinComparison | PlainMessage<WithinComparison> | undefined): boolean {
    return proto3.util.equals(WithinComparison, a, b);
  }
}

