// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/entityhistory/v1/entity_history_api.pub.proto (package anduril.entityhistory.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { HistoryPage, HistoryPageToken, HistoryType } from "./history.pub_pb.js";
import { Statement } from "../../entitymanager/v1/filter.pub_pb.js";

/**
 * @generated from message anduril.entityhistory.v1.ListHistoryRequest
 */
export class ListHistoryRequest extends Message<ListHistoryRequest> {
  /**
   * Specifies the history returned to the client.
   *
   * @generated from field: anduril.entityhistory.v1.HistoryQuery history_query = 1;
   */
  historyQuery?: HistoryQuery;

  /**
   * Page token in the case that the query results are paginated.
   * This will be deprecated in favor of history_page_token.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  /**
   * history_page_token should be provided as part of a request to consume paginated history data and was received via
   * the most recent ListHistoryResponse. Clients should not create this on their own and the initial ListHistoryRequest
   * should leave this field empty.
   *
   * @generated from field: anduril.entityhistory.v1.HistoryPageToken history_page_token = 3;
   */
  historyPageToken?: HistoryPageToken;

  constructor(data?: PartialMessage<ListHistoryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entityhistory.v1.ListHistoryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "history_query", kind: "message", T: HistoryQuery },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "history_page_token", kind: "message", T: HistoryPageToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListHistoryRequest {
    return new ListHistoryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListHistoryRequest {
    return new ListHistoryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListHistoryRequest {
    return new ListHistoryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListHistoryRequest | PlainMessage<ListHistoryRequest> | undefined, b: ListHistoryRequest | PlainMessage<ListHistoryRequest> | undefined): boolean {
    return proto3.util.equals(ListHistoryRequest, a, b);
  }
}

/**
 * @generated from message anduril.entityhistory.v1.ListHistoryResponse
 */
export class ListHistoryResponse extends Message<ListHistoryResponse> {
  /**
   * @generated from field: anduril.entityhistory.v1.HistoryPage history_page = 1;
   */
  historyPage?: HistoryPage;

  /**
   * If present this page token can be used to retrieve the next page of
   * history. If empty, there are no more results.
   * This will be deprecated in favor of next_history_page_token.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  /**
   * Next_history_page_token received should be provided as part of any followup requests to continue consuming the data
   * for the query requested until the HistoryPageToken reports is_complete as true.
   *
   * @generated from field: anduril.entityhistory.v1.HistoryPageToken next_history_page_token = 3;
   */
  nextHistoryPageToken?: HistoryPageToken;

  constructor(data?: PartialMessage<ListHistoryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entityhistory.v1.ListHistoryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "history_page", kind: "message", T: HistoryPage },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "next_history_page_token", kind: "message", T: HistoryPageToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListHistoryResponse {
    return new ListHistoryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListHistoryResponse {
    return new ListHistoryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListHistoryResponse {
    return new ListHistoryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListHistoryResponse | PlainMessage<ListHistoryResponse> | undefined, b: ListHistoryResponse | PlainMessage<ListHistoryResponse> | undefined): boolean {
    return proto3.util.equals(ListHistoryResponse, a, b);
  }
}

/**
 * A query for entity history. Required fields are history type and time
 * range. Downsampling and additional filter parameters are optional. If
 * no additional filter is specified, all entity historical data of the
 * specified type is returned for the provided time range.
 *
 * @generated from message anduril.entityhistory.v1.HistoryQuery
 */
export class HistoryQuery extends Message<HistoryQuery> {
  /**
   * The type of history to query.
   *
   * @generated from field: anduril.entityhistory.v1.HistoryType history_type = 1;
   */
  historyType = HistoryType.INVALID;

  /**
   * Time range for the below queries. If no query is specified, all data
   * for the history type during the time range is returned.
   *
   * @generated from field: anduril.entityhistory.v1.TimeRange time_range = 2;
   */
  timeRange?: TimeRange;

  /**
   * Downsampling to apply to a time ordered set of points. May not apply
   * to all history data types. Currently supported types are: trails.
   *
   * @generated from field: anduril.entityhistory.v1.Downsample downsample = 3;
   */
  downsample?: Downsample;

  /**
   * Filter for historical data. The applied filter limits the data returned
   * by the query to only the data with matching current entity state. The
   * filter is applied to the latest observed state recorded in a snapshot.
   * Live state is not considered.
   *
   * @generated from field: anduril.entitymanager.v1.Statement statement = 4;
   */
  statement?: Statement;

  /**
   * Set of entityIds to request history data for. If empty, all entityIds will be found by querying TimeSeries.
   *
   * @generated from field: repeated string entity_ids = 5;
   */
  entityIds: string[] = [];

  constructor(data?: PartialMessage<HistoryQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entityhistory.v1.HistoryQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "history_type", kind: "enum", T: proto3.getEnumType(HistoryType) },
    { no: 2, name: "time_range", kind: "message", T: TimeRange },
    { no: 3, name: "downsample", kind: "message", T: Downsample },
    { no: 4, name: "statement", kind: "message", T: Statement },
    { no: 5, name: "entity_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HistoryQuery {
    return new HistoryQuery().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HistoryQuery {
    return new HistoryQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HistoryQuery {
    return new HistoryQuery().fromJsonString(jsonString, options);
  }

  static equals(a: HistoryQuery | PlainMessage<HistoryQuery> | undefined, b: HistoryQuery | PlainMessage<HistoryQuery> | undefined): boolean {
    return proto3.util.equals(HistoryQuery, a, b);
  }
}

/**
 * Range of wall-clock time. If upper bound timestamp is greater than the
 * current time, the query will truncate the future time to now and return
 * any history between lower bound and now. If both of the bounds are in
 * the future, the query will report no available historical data.
 *
 * @generated from message anduril.entityhistory.v1.TimeRange
 */
export class TimeRange extends Message<TimeRange> {
  /**
   * Earliest time in the TimeRange.
   *
   * @generated from field: google.protobuf.Timestamp lower_bound_inc = 1;
   */
  lowerBoundInc?: Timestamp;

  /**
   * Latest time in the TimeRange.
   *
   * @generated from field: google.protobuf.Timestamp upper_bound_exc = 2;
   */
  upperBoundExc?: Timestamp;

  constructor(data?: PartialMessage<TimeRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entityhistory.v1.TimeRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lower_bound_inc", kind: "message", T: Timestamp },
    { no: 2, name: "upper_bound_exc", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeRange {
    return new TimeRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeRange {
    return new TimeRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeRange {
    return new TimeRange().fromJsonString(jsonString, options);
  }

  static equals(a: TimeRange | PlainMessage<TimeRange> | undefined, b: TimeRange | PlainMessage<TimeRange> | undefined): boolean {
    return proto3.util.equals(TimeRange, a, b);
  }
}

/**
 * Downsampling is applied to points in an individual historical data model.
 * Enforces each point is separated by at least downsample_duration millis.
 *
 * For example: downsample_duration = 10,000.
 * stored points = [ 0, 5,000, 10,000, 13,000, 22,000, 30,000, 35,000 ].
 * returned points = [ 0, 10,000, 22,000, 35,000 ].
 *
 * @generated from message anduril.entityhistory.v1.Downsample
 */
export class Downsample extends Message<Downsample> {
  /**
   * @generated from oneof anduril.entityhistory.v1.Downsample.type
   */
  type: {
    /**
     * @generated from field: anduril.entityhistory.v1.DownsampleDuration downsample_duration = 1;
     */
    value: DownsampleDuration;
    case: "downsampleDuration";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Downsample>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entityhistory.v1.Downsample";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "downsample_duration", kind: "message", T: DownsampleDuration, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Downsample {
    return new Downsample().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Downsample {
    return new Downsample().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Downsample {
    return new Downsample().fromJsonString(jsonString, options);
  }

  static equals(a: Downsample | PlainMessage<Downsample> | undefined, b: Downsample | PlainMessage<Downsample> | undefined): boolean {
    return proto3.util.equals(Downsample, a, b);
  }
}

/**
 * @generated from message anduril.entityhistory.v1.DownsampleDuration
 */
export class DownsampleDuration extends Message<DownsampleDuration> {
  /**
   * Downsample duration specified in milliseconds.
   *
   * @generated from field: uint32 duration_ms = 1;
   */
  durationMs = 0;

  constructor(data?: PartialMessage<DownsampleDuration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entityhistory.v1.DownsampleDuration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "duration_ms", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DownsampleDuration {
    return new DownsampleDuration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DownsampleDuration {
    return new DownsampleDuration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DownsampleDuration {
    return new DownsampleDuration().fromJsonString(jsonString, options);
  }

  static equals(a: DownsampleDuration | PlainMessage<DownsampleDuration> | undefined, b: DownsampleDuration | PlainMessage<DownsampleDuration> | undefined): boolean {
    return proto3.util.equals(DownsampleDuration, a, b);
  }
}

/**
 * Open a server stream to receive updates to entity time windows after Entity History has processed
 * a backfill event or healing job. The stream is long-lived and only delivers new updates as they arrive.
 *
 * @generated from message anduril.entityhistory.v1.StreamBackfillUpdatesRequest
 */
export class StreamBackfillUpdatesRequest extends Message<StreamBackfillUpdatesRequest> {
  constructor(data?: PartialMessage<StreamBackfillUpdatesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entityhistory.v1.StreamBackfillUpdatesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamBackfillUpdatesRequest {
    return new StreamBackfillUpdatesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamBackfillUpdatesRequest {
    return new StreamBackfillUpdatesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamBackfillUpdatesRequest {
    return new StreamBackfillUpdatesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamBackfillUpdatesRequest | PlainMessage<StreamBackfillUpdatesRequest> | undefined, b: StreamBackfillUpdatesRequest | PlainMessage<StreamBackfillUpdatesRequest> | undefined): boolean {
    return proto3.util.equals(StreamBackfillUpdatesRequest, a, b);
  }
}

/**
 * @generated from message anduril.entityhistory.v1.StreamBackfillUpdatesResponse
 */
export class StreamBackfillUpdatesResponse extends Message<StreamBackfillUpdatesResponse> {
  /**
   * @generated from field: repeated anduril.entityhistory.v1.BackfillUpdate backfill_updates = 1;
   */
  backfillUpdates: BackfillUpdate[] = [];

  constructor(data?: PartialMessage<StreamBackfillUpdatesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entityhistory.v1.StreamBackfillUpdatesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "backfill_updates", kind: "message", T: BackfillUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamBackfillUpdatesResponse {
    return new StreamBackfillUpdatesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamBackfillUpdatesResponse {
    return new StreamBackfillUpdatesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamBackfillUpdatesResponse {
    return new StreamBackfillUpdatesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamBackfillUpdatesResponse | PlainMessage<StreamBackfillUpdatesResponse> | undefined, b: StreamBackfillUpdatesResponse | PlainMessage<StreamBackfillUpdatesResponse> | undefined): boolean {
    return proto3.util.equals(StreamBackfillUpdatesResponse, a, b);
  }
}

/**
 * Indicates the entity identified by entity_id has new data available in EntityHistory for the time period described
 * by time_range.
 *
 * @generated from message anduril.entityhistory.v1.BackfillUpdate
 */
export class BackfillUpdate extends Message<BackfillUpdate> {
  /**
   * @generated from field: string entity_id = 1;
   */
  entityId = "";

  /**
   * @generated from field: anduril.entityhistory.v1.TimeRange time_range = 2;
   */
  timeRange?: TimeRange;

  constructor(data?: PartialMessage<BackfillUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.entityhistory.v1.BackfillUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "time_range", kind: "message", T: TimeRange },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BackfillUpdate {
    return new BackfillUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BackfillUpdate {
    return new BackfillUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BackfillUpdate {
    return new BackfillUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: BackfillUpdate | PlainMessage<BackfillUpdate> | undefined, b: BackfillUpdate | PlainMessage<BackfillUpdate> | undefined): boolean {
    return proto3.util.equals(BackfillUpdate, a, b);
  }
}

