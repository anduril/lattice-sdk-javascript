// @generated by protoc-gen-es v2.0.0
// @generated from file anduril/entityhistory/v1/entity_history_api.pub.proto (package anduril.entityhistory.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";
import type { HistoryPage, HistoryPageToken, HistoryType } from "./history.pub_pb";
import type { Statement } from "../../entitymanager/v1/filter.pub_pb";
import type { Timestamp } from "@bufbuild/protobuf/wkt";

/**
 * Describes the file anduril/entityhistory/v1/entity_history_api.pub.proto.
 */
export declare const file_anduril_entityhistory_v1_entity_history_api_pub: GenFile;

/**
 * @generated from message anduril.entityhistory.v1.ListHistoryRequest
 */
export declare type ListHistoryRequest = Message<"anduril.entityhistory.v1.ListHistoryRequest"> & {
  /**
   * Specifies the history returned to the client.
   *
   * @generated from field: anduril.entityhistory.v1.HistoryQuery history_query = 1;
   */
  historyQuery?: HistoryQuery;

  /**
   * Page token in the case that the query results are paginated.
   * This will be deprecated in favor of history_page_token.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken: string;

  /**
   * history_page_token should be provided as part of a request to consume paginated history data and was received via
   * the most recent ListHistoryResponse. Clients should not create this on their own and the initial ListHistoryRequest
   * should leave this field empty.
   *
   * @generated from field: anduril.entityhistory.v1.HistoryPageToken history_page_token = 3;
   */
  historyPageToken?: HistoryPageToken;
};

/**
 * Describes the message anduril.entityhistory.v1.ListHistoryRequest.
 * Use `create(ListHistoryRequestSchema)` to create a new message.
 */
export declare const ListHistoryRequestSchema: GenMessage<ListHistoryRequest>;

/**
 * @generated from message anduril.entityhistory.v1.ListHistoryResponse
 */
export declare type ListHistoryResponse = Message<"anduril.entityhistory.v1.ListHistoryResponse"> & {
  /**
   * @generated from field: anduril.entityhistory.v1.HistoryPage history_page = 1;
   */
  historyPage?: HistoryPage;

  /**
   * If present this page token can be used to retrieve the next page of
   * history. If empty, there are no more results.
   * This will be deprecated in favor of next_history_page_token.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;

  /**
   * Next_history_page_token received should be provided as part of any followup requests to continue consuming the data
   * for the query requested until the HistoryPageToken reports is_complete as true.
   *
   * @generated from field: anduril.entityhistory.v1.HistoryPageToken next_history_page_token = 3;
   */
  nextHistoryPageToken?: HistoryPageToken;
};

/**
 * Describes the message anduril.entityhistory.v1.ListHistoryResponse.
 * Use `create(ListHistoryResponseSchema)` to create a new message.
 */
export declare const ListHistoryResponseSchema: GenMessage<ListHistoryResponse>;

/**
 * A query for entity history. Required fields are history type and time
 * range. Downsampling and additional filter parameters are optional. If
 * no additional filter is specified, all entity historical data of the
 * specified type is returned for the provided time range.
 *
 * @generated from message anduril.entityhistory.v1.HistoryQuery
 */
export declare type HistoryQuery = Message<"anduril.entityhistory.v1.HistoryQuery"> & {
  /**
   * The type of history to query.
   *
   * @generated from field: anduril.entityhistory.v1.HistoryType history_type = 1;
   */
  historyType: HistoryType;

  /**
   * Time range for the below queries. If no query is specified, all data
   * for the history type during the time range is returned.
   *
   * @generated from field: anduril.entityhistory.v1.TimeRange time_range = 2;
   */
  timeRange?: TimeRange;

  /**
   * Downsampling to apply to a time ordered set of points. May not apply
   * to all history data types. Currently supported types are: trails.
   *
   * @generated from field: anduril.entityhistory.v1.Downsample downsample = 3;
   */
  downsample?: Downsample;

  /**
   * Filter for historical data. The applied filter limits the data returned
   * by the query to only the data with matching current entity state. The
   * filter is applied to the latest observed state recorded in a snapshot.
   * Live state is not considered.
   *
   * @generated from field: anduril.entitymanager.v1.Statement statement = 4;
   */
  statement?: Statement;

  /**
   * Set of entityIds to request history data for. If empty, all entityIds will be found by querying TimeSeries.
   *
   * @generated from field: repeated string entity_ids = 5;
   */
  entityIds: string[];
};

/**
 * Describes the message anduril.entityhistory.v1.HistoryQuery.
 * Use `create(HistoryQuerySchema)` to create a new message.
 */
export declare const HistoryQuerySchema: GenMessage<HistoryQuery>;

/**
 * Range of wall-clock time. If upper bound timestamp is greater than the
 * current time, the query will truncate the future time to now and return
 * any history between lower bound and now. If both of the bounds are in
 * the future, the query will report no available historical data.
 *
 * @generated from message anduril.entityhistory.v1.TimeRange
 */
export declare type TimeRange = Message<"anduril.entityhistory.v1.TimeRange"> & {
  /**
   * Earliest time in the TimeRange.
   *
   * @generated from field: google.protobuf.Timestamp lower_bound_inc = 1;
   */
  lowerBoundInc?: Timestamp;

  /**
   * Latest time in the TimeRange.
   *
   * @generated from field: google.protobuf.Timestamp upper_bound_exc = 2;
   */
  upperBoundExc?: Timestamp;
};

/**
 * Describes the message anduril.entityhistory.v1.TimeRange.
 * Use `create(TimeRangeSchema)` to create a new message.
 */
export declare const TimeRangeSchema: GenMessage<TimeRange>;

/**
 * Downsampling is applied to points in an individual historical data model.
 * Enforces each point is separated by at least downsample_duration millis.
 *
 * For example: downsample_duration = 10,000.
 * stored points = [ 0, 5,000, 10,000, 13,000, 22,000, 30,000, 35,000 ].
 * returned points = [ 0, 10,000, 22,000, 35,000 ].
 *
 * @generated from message anduril.entityhistory.v1.Downsample
 */
export declare type Downsample = Message<"anduril.entityhistory.v1.Downsample"> & {
  /**
   * @generated from oneof anduril.entityhistory.v1.Downsample.type
   */
  type: {
    /**
     * @generated from field: anduril.entityhistory.v1.DownsampleDuration downsample_duration = 1;
     */
    value: DownsampleDuration;
    case: "downsampleDuration";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message anduril.entityhistory.v1.Downsample.
 * Use `create(DownsampleSchema)` to create a new message.
 */
export declare const DownsampleSchema: GenMessage<Downsample>;

/**
 * @generated from message anduril.entityhistory.v1.DownsampleDuration
 */
export declare type DownsampleDuration = Message<"anduril.entityhistory.v1.DownsampleDuration"> & {
  /**
   * Downsample duration specified in milliseconds.
   *
   * @generated from field: uint32 duration_ms = 1;
   */
  durationMs: number;
};

/**
 * Describes the message anduril.entityhistory.v1.DownsampleDuration.
 * Use `create(DownsampleDurationSchema)` to create a new message.
 */
export declare const DownsampleDurationSchema: GenMessage<DownsampleDuration>;

/**
 * Open a server stream to receive updates to entity time windows after Entity History has processed
 * a backfill event or healing job. The stream is long-lived and only delivers new updates as they arrive.
 *
 * @generated from message anduril.entityhistory.v1.StreamBackfillUpdatesRequest
 */
export declare type StreamBackfillUpdatesRequest = Message<"anduril.entityhistory.v1.StreamBackfillUpdatesRequest"> & {
};

/**
 * Describes the message anduril.entityhistory.v1.StreamBackfillUpdatesRequest.
 * Use `create(StreamBackfillUpdatesRequestSchema)` to create a new message.
 */
export declare const StreamBackfillUpdatesRequestSchema: GenMessage<StreamBackfillUpdatesRequest>;

/**
 * @generated from message anduril.entityhistory.v1.StreamBackfillUpdatesResponse
 */
export declare type StreamBackfillUpdatesResponse = Message<"anduril.entityhistory.v1.StreamBackfillUpdatesResponse"> & {
  /**
   * @generated from field: repeated anduril.entityhistory.v1.BackfillUpdate backfill_updates = 1;
   */
  backfillUpdates: BackfillUpdate[];
};

/**
 * Describes the message anduril.entityhistory.v1.StreamBackfillUpdatesResponse.
 * Use `create(StreamBackfillUpdatesResponseSchema)` to create a new message.
 */
export declare const StreamBackfillUpdatesResponseSchema: GenMessage<StreamBackfillUpdatesResponse>;

/**
 * Indicates the entity identified by entity_id has new data available in EntityHistory for the time period described
 * by time_range.
 *
 * @generated from message anduril.entityhistory.v1.BackfillUpdate
 */
export declare type BackfillUpdate = Message<"anduril.entityhistory.v1.BackfillUpdate"> & {
  /**
   * @generated from field: string entity_id = 1;
   */
  entityId: string;

  /**
   * @generated from field: anduril.entityhistory.v1.TimeRange time_range = 2;
   */
  timeRange?: TimeRange;
};

/**
 * Describes the message anduril.entityhistory.v1.BackfillUpdate.
 * Use `create(BackfillUpdateSchema)` to create a new message.
 */
export declare const BackfillUpdateSchema: GenMessage<BackfillUpdate>;

/**
 * The EntityHistoryAPI provides UI-centric data models for understanding
 * the historic view of a battle space. The API draws heavily on the Entity
 * data model and Entity filter to form the core of its client contract.
 *
 * @generated from service anduril.entityhistory.v1.EntityHistoryAPI
 */
export declare const EntityHistoryAPI: GenService<{
  /**
   * Returns a page of history given a history query.
   *
   * @generated from rpc anduril.entityhistory.v1.EntityHistoryAPI.ListHistory
   */
  listHistory: {
    methodKind: "unary";
    input: typeof ListHistoryRequestSchema;
    output: typeof ListHistoryResponseSchema;
  },
}>;

