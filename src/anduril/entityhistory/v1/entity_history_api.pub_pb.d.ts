// @generated by protoc-gen-es v1.7.2
// @generated from file anduril/entityhistory/v1/entity_history_api.pub.proto (package anduril.entityhistory.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { HistoryPage, HistoryPageToken, HistoryType } from "./history.pub_pb.js";
import type { Statement } from "../../entitymanager/v1/filter.pub_pb.js";

/**
 * @generated from message anduril.entityhistory.v1.ListHistoryRequest
 */
export declare class ListHistoryRequest extends Message<ListHistoryRequest> {
  /**
   * Specifies the history returned to the client.
   *
   * @generated from field: anduril.entityhistory.v1.HistoryQuery history_query = 1;
   */
  historyQuery?: HistoryQuery;

  /**
   * Page token in the case that the query results are paginated.
   * This will be deprecated in favor of history_page_token.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken: string;

  /**
   * history_page_token should be provided as part of a request to consume paginated history data and was received via
   * the most recent ListHistoryResponse. Clients should not create this on their own and the initial ListHistoryRequest
   * should leave this field empty.
   *
   * @generated from field: anduril.entityhistory.v1.HistoryPageToken history_page_token = 3;
   */
  historyPageToken?: HistoryPageToken;

  constructor(data?: PartialMessage<ListHistoryRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entityhistory.v1.ListHistoryRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListHistoryRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListHistoryRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListHistoryRequest;

  static equals(a: ListHistoryRequest | PlainMessage<ListHistoryRequest> | undefined, b: ListHistoryRequest | PlainMessage<ListHistoryRequest> | undefined): boolean;
}

/**
 * @generated from message anduril.entityhistory.v1.ListHistoryResponse
 */
export declare class ListHistoryResponse extends Message<ListHistoryResponse> {
  /**
   * @generated from field: anduril.entityhistory.v1.HistoryPage history_page = 1;
   */
  historyPage?: HistoryPage;

  /**
   * If present this page token can be used to retrieve the next page of
   * history. If empty, there are no more results.
   * This will be deprecated in favor of next_history_page_token.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;

  /**
   * Next_history_page_token received should be provided as part of any followup requests to continue consuming the data
   * for the query requested until the HistoryPageToken reports is_complete as true.
   *
   * @generated from field: anduril.entityhistory.v1.HistoryPageToken next_history_page_token = 3;
   */
  nextHistoryPageToken?: HistoryPageToken;

  constructor(data?: PartialMessage<ListHistoryResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entityhistory.v1.ListHistoryResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListHistoryResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListHistoryResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListHistoryResponse;

  static equals(a: ListHistoryResponse | PlainMessage<ListHistoryResponse> | undefined, b: ListHistoryResponse | PlainMessage<ListHistoryResponse> | undefined): boolean;
}

/**
 * A query for entity history. Required fields are history type and time
 * range. Downsampling and additional filter parameters are optional. If
 * no additional filter is specified, all entity historical data of the
 * specified type is returned for the provided time range.
 *
 * @generated from message anduril.entityhistory.v1.HistoryQuery
 */
export declare class HistoryQuery extends Message<HistoryQuery> {
  /**
   * The type of history to query.
   *
   * @generated from field: anduril.entityhistory.v1.HistoryType history_type = 1;
   */
  historyType: HistoryType;

  /**
   * Time range for the below queries. If no query is specified, all data
   * for the history type during the time range is returned.
   *
   * @generated from field: anduril.entityhistory.v1.TimeRange time_range = 2;
   */
  timeRange?: TimeRange;

  /**
   * Downsampling to apply to a time ordered set of points. May not apply
   * to all history data types. Currently supported types are: trails.
   *
   * @generated from field: anduril.entityhistory.v1.Downsample downsample = 3;
   */
  downsample?: Downsample;

  /**
   * Filter for historical data. The applied filter limits the data returned
   * by the query to only the data with matching current entity state. The
   * filter is applied to the latest observed state recorded in a snapshot.
   * Live state is not considered.
   *
   * @generated from field: anduril.entitymanager.v1.Statement statement = 4;
   */
  statement?: Statement;

  /**
   * Set of entityIds to request history data for. If empty, all entityIds will be found by querying TimeSeries.
   *
   * @generated from field: repeated string entity_ids = 5;
   */
  entityIds: string[];

  constructor(data?: PartialMessage<HistoryQuery>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entityhistory.v1.HistoryQuery";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HistoryQuery;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HistoryQuery;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HistoryQuery;

  static equals(a: HistoryQuery | PlainMessage<HistoryQuery> | undefined, b: HistoryQuery | PlainMessage<HistoryQuery> | undefined): boolean;
}

/**
 * Range of wall-clock time. If upper bound timestamp is greater than the
 * current time, the query will truncate the future time to now and return
 * any history between lower bound and now. If both of the bounds are in
 * the future, the query will report no available historical data.
 *
 * @generated from message anduril.entityhistory.v1.TimeRange
 */
export declare class TimeRange extends Message<TimeRange> {
  /**
   * Earliest time in the TimeRange.
   *
   * @generated from field: google.protobuf.Timestamp lower_bound_inc = 1;
   */
  lowerBoundInc?: Timestamp;

  /**
   * Latest time in the TimeRange.
   *
   * @generated from field: google.protobuf.Timestamp upper_bound_exc = 2;
   */
  upperBoundExc?: Timestamp;

  constructor(data?: PartialMessage<TimeRange>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entityhistory.v1.TimeRange";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeRange;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeRange;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeRange;

  static equals(a: TimeRange | PlainMessage<TimeRange> | undefined, b: TimeRange | PlainMessage<TimeRange> | undefined): boolean;
}

/**
 * Downsampling is applied to points in an individual historical data model.
 * Enforces each point is separated by at least downsample_duration millis.
 *
 * For example: downsample_duration = 10,000.
 * stored points = [ 0, 5,000, 10,000, 13,000, 22,000, 30,000, 35,000 ].
 * returned points = [ 0, 10,000, 22,000, 35,000 ].
 *
 * @generated from message anduril.entityhistory.v1.Downsample
 */
export declare class Downsample extends Message<Downsample> {
  /**
   * @generated from oneof anduril.entityhistory.v1.Downsample.type
   */
  type: {
    /**
     * @generated from field: anduril.entityhistory.v1.DownsampleDuration downsample_duration = 1;
     */
    value: DownsampleDuration;
    case: "downsampleDuration";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Downsample>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entityhistory.v1.Downsample";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Downsample;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Downsample;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Downsample;

  static equals(a: Downsample | PlainMessage<Downsample> | undefined, b: Downsample | PlainMessage<Downsample> | undefined): boolean;
}

/**
 * @generated from message anduril.entityhistory.v1.DownsampleDuration
 */
export declare class DownsampleDuration extends Message<DownsampleDuration> {
  /**
   * Downsample duration specified in milliseconds.
   *
   * @generated from field: uint32 duration_ms = 1;
   */
  durationMs: number;

  constructor(data?: PartialMessage<DownsampleDuration>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entityhistory.v1.DownsampleDuration";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DownsampleDuration;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DownsampleDuration;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DownsampleDuration;

  static equals(a: DownsampleDuration | PlainMessage<DownsampleDuration> | undefined, b: DownsampleDuration | PlainMessage<DownsampleDuration> | undefined): boolean;
}

/**
 * Open a server stream to receive updates to entity time windows after Entity History has processed
 * a backfill event or healing job. The stream is long-lived and only delivers new updates as they arrive.
 *
 * @generated from message anduril.entityhistory.v1.StreamBackfillUpdatesRequest
 */
export declare class StreamBackfillUpdatesRequest extends Message<StreamBackfillUpdatesRequest> {
  constructor(data?: PartialMessage<StreamBackfillUpdatesRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entityhistory.v1.StreamBackfillUpdatesRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamBackfillUpdatesRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamBackfillUpdatesRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamBackfillUpdatesRequest;

  static equals(a: StreamBackfillUpdatesRequest | PlainMessage<StreamBackfillUpdatesRequest> | undefined, b: StreamBackfillUpdatesRequest | PlainMessage<StreamBackfillUpdatesRequest> | undefined): boolean;
}

/**
 * @generated from message anduril.entityhistory.v1.StreamBackfillUpdatesResponse
 */
export declare class StreamBackfillUpdatesResponse extends Message<StreamBackfillUpdatesResponse> {
  /**
   * @generated from field: repeated anduril.entityhistory.v1.BackfillUpdate backfill_updates = 1;
   */
  backfillUpdates: BackfillUpdate[];

  constructor(data?: PartialMessage<StreamBackfillUpdatesResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entityhistory.v1.StreamBackfillUpdatesResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamBackfillUpdatesResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamBackfillUpdatesResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamBackfillUpdatesResponse;

  static equals(a: StreamBackfillUpdatesResponse | PlainMessage<StreamBackfillUpdatesResponse> | undefined, b: StreamBackfillUpdatesResponse | PlainMessage<StreamBackfillUpdatesResponse> | undefined): boolean;
}

/**
 * Indicates the entity identified by entity_id has new data available in EntityHistory for the time period described
 * by time_range.
 *
 * @generated from message anduril.entityhistory.v1.BackfillUpdate
 */
export declare class BackfillUpdate extends Message<BackfillUpdate> {
  /**
   * @generated from field: string entity_id = 1;
   */
  entityId: string;

  /**
   * @generated from field: anduril.entityhistory.v1.TimeRange time_range = 2;
   */
  timeRange?: TimeRange;

  constructor(data?: PartialMessage<BackfillUpdate>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.entityhistory.v1.BackfillUpdate";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BackfillUpdate;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BackfillUpdate;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BackfillUpdate;

  static equals(a: BackfillUpdate | PlainMessage<BackfillUpdate> | undefined, b: BackfillUpdate | PlainMessage<BackfillUpdate> | undefined): boolean;
}

