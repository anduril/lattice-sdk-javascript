// @generated by protoc-gen-es v1.7.2 with parameter "js_import_style=legacy_commonjs"
// @generated from file anduril/entityhistory/v1/entity_history_api.pub.proto (package anduril.entityhistory.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

const { proto3, Timestamp } = require("@bufbuild/protobuf");
const { HistoryPage, HistoryPageToken, HistoryType } = require("./history.pub_pb.js");
const { Statement } = require("../../entitymanager/v1/filter.pub_pb.js");

/**
 * @generated from message anduril.entityhistory.v1.ListHistoryRequest
 */
const ListHistoryRequest = proto3.makeMessageType(
  "anduril.entityhistory.v1.ListHistoryRequest",
  () => [
    { no: 1, name: "history_query", kind: "message", T: HistoryQuery },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "history_page_token", kind: "message", T: HistoryPageToken },
  ],
);

/**
 * @generated from message anduril.entityhistory.v1.ListHistoryResponse
 */
const ListHistoryResponse = proto3.makeMessageType(
  "anduril.entityhistory.v1.ListHistoryResponse",
  () => [
    { no: 1, name: "history_page", kind: "message", T: HistoryPage },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "next_history_page_token", kind: "message", T: HistoryPageToken },
  ],
);

/**
 * A query for entity history. Required fields are history type and time
 * range. Downsampling and additional filter parameters are optional. If
 * no additional filter is specified, all entity historical data of the
 * specified type is returned for the provided time range.
 *
 * @generated from message anduril.entityhistory.v1.HistoryQuery
 */
const HistoryQuery = proto3.makeMessageType(
  "anduril.entityhistory.v1.HistoryQuery",
  () => [
    { no: 1, name: "history_type", kind: "enum", T: proto3.getEnumType(HistoryType) },
    { no: 2, name: "time_range", kind: "message", T: TimeRange },
    { no: 3, name: "downsample", kind: "message", T: Downsample },
    { no: 4, name: "statement", kind: "message", T: Statement },
    { no: 5, name: "entity_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ],
);

/**
 * Range of wall-clock time. If upper bound timestamp is greater than the
 * current time, the query will truncate the future time to now and return
 * any history between lower bound and now. If both of the bounds are in
 * the future, the query will report no available historical data.
 *
 * @generated from message anduril.entityhistory.v1.TimeRange
 */
const TimeRange = proto3.makeMessageType(
  "anduril.entityhistory.v1.TimeRange",
  () => [
    { no: 1, name: "lower_bound_inc", kind: "message", T: Timestamp },
    { no: 2, name: "upper_bound_exc", kind: "message", T: Timestamp },
  ],
);

/**
 * Downsampling is applied to points in an individual historical data model.
 * Enforces each point is separated by at least downsample_duration millis.
 *
 * For example: downsample_duration = 10,000.
 * stored points = [ 0, 5,000, 10,000, 13,000, 22,000, 30,000, 35,000 ].
 * returned points = [ 0, 10,000, 22,000, 35,000 ].
 *
 * @generated from message anduril.entityhistory.v1.Downsample
 */
const Downsample = proto3.makeMessageType(
  "anduril.entityhistory.v1.Downsample",
  () => [
    { no: 1, name: "downsample_duration", kind: "message", T: DownsampleDuration, oneof: "type" },
  ],
);

/**
 * @generated from message anduril.entityhistory.v1.DownsampleDuration
 */
const DownsampleDuration = proto3.makeMessageType(
  "anduril.entityhistory.v1.DownsampleDuration",
  () => [
    { no: 1, name: "duration_ms", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ],
);

/**
 * Open a server stream to receive updates to entity time windows after Entity History has processed
 * a backfill event or healing job. The stream is long-lived and only delivers new updates as they arrive.
 *
 * @generated from message anduril.entityhistory.v1.StreamBackfillUpdatesRequest
 */
const StreamBackfillUpdatesRequest = proto3.makeMessageType(
  "anduril.entityhistory.v1.StreamBackfillUpdatesRequest",
  [],
);

/**
 * @generated from message anduril.entityhistory.v1.StreamBackfillUpdatesResponse
 */
const StreamBackfillUpdatesResponse = proto3.makeMessageType(
  "anduril.entityhistory.v1.StreamBackfillUpdatesResponse",
  () => [
    { no: 1, name: "backfill_updates", kind: "message", T: BackfillUpdate, repeated: true },
  ],
);

/**
 * Indicates the entity identified by entity_id has new data available in EntityHistory for the time period described
 * by time_range.
 *
 * @generated from message anduril.entityhistory.v1.BackfillUpdate
 */
const BackfillUpdate = proto3.makeMessageType(
  "anduril.entityhistory.v1.BackfillUpdate",
  () => [
    { no: 1, name: "entity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "time_range", kind: "message", T: TimeRange },
  ],
);


exports.ListHistoryRequest = ListHistoryRequest;
exports.ListHistoryResponse = ListHistoryResponse;
exports.HistoryQuery = HistoryQuery;
exports.TimeRange = TimeRange;
exports.Downsample = Downsample;
exports.DownsampleDuration = DownsampleDuration;
exports.StreamBackfillUpdatesRequest = StreamBackfillUpdatesRequest;
exports.StreamBackfillUpdatesResponse = StreamBackfillUpdatesResponse;
exports.BackfillUpdate = BackfillUpdate;
