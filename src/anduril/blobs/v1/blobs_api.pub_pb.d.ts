// @generated by protoc-gen-es v1.7.2
// @generated from file anduril/blobs/v1/blobs_api.pub.proto (package anduril.blobs.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { BlobMetadata, BlobProvenance } from "./common.pub_pb.js";

/**
 * Create and store a new blob (<=2MB).
 *
 * @generated from message anduril.blobs.v1.CreateBlobRequest
 */
export declare class CreateBlobRequest extends Message<CreateBlobRequest> {
  /**
   * blobs created will be namespaced by client_id
   *
   * @generated from field: string client_id = 1;
   */
  clientId: string;

  /**
   * unique (per client) key for the blob
   *
   * @generated from field: string key = 2;
   */
  key: string;

  /**
   * timestamp after which should no longer retain this blob. required and cannot be > 90 days in the future.
   *
   * @generated from field: google.protobuf.Timestamp retention_time = 3;
   */
  retentionTime?: Timestamp;

  /**
   * optional md5 sum/hash of contents. if provided, will be validated against md5 of contents
   *
   * @generated from field: bytes md5 = 4;
   */
  md5: Uint8Array;

  /**
   * contents of the entire blob, maximum size is 2MB (2 * 1024 * 1024 bytes)
   *
   * @generated from field: bytes contents = 5;
   */
  contents: Uint8Array;

  /**
   * details regarding the blob's origin - aka source and type
   *
   * @generated from field: anduril.blobs.v1.BlobProvenance provenance = 6;
   */
  provenance?: BlobProvenance;

  constructor(data?: PartialMessage<CreateBlobRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.blobs.v1.CreateBlobRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateBlobRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateBlobRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateBlobRequest;

  static equals(a: CreateBlobRequest | PlainMessage<CreateBlobRequest> | undefined, b: CreateBlobRequest | PlainMessage<CreateBlobRequest> | undefined): boolean;
}

/**
 * @generated from message anduril.blobs.v1.CreateBlobResponse
 */
export declare class CreateBlobResponse extends Message<CreateBlobResponse> {
  /**
   * @generated from field: anduril.blobs.v1.BlobMetadata metadata = 1;
   */
  metadata?: BlobMetadata;

  /**
   * URL at which the blob can be fetched
   *
   * @generated from field: string url = 2;
   */
  url: string;

  constructor(data?: PartialMessage<CreateBlobResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.blobs.v1.CreateBlobResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateBlobResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateBlobResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateBlobResponse;

  static equals(a: CreateBlobResponse | PlainMessage<CreateBlobResponse> | undefined, b: CreateBlobResponse | PlainMessage<CreateBlobResponse> | undefined): boolean;
}

/**
 * Create and store a new blob. Only the first 'CreateBlobChunkedRequest' message in the client stream needs
 * to contain metadata specific fields (IE: client_id, key, md5 etc.). Metadata fields set on all requests
 * ensuing the first request will be ignored.
 *
 * @generated from message anduril.blobs.v1.CreateBlobChunkedRequest
 */
export declare class CreateBlobChunkedRequest extends Message<CreateBlobChunkedRequest> {
  /**
   * blobs created will be namespaced by client_id
   *
   * @generated from field: string client_id = 1;
   */
  clientId: string;

  /**
   * unique (per client) key for the blob
   *
   * @generated from field: string key = 2;
   */
  key: string;

  /**
   * timestamp after which should no longer retain this blob. required and cannot be > 90 days in the future.
   *
   * @generated from field: google.protobuf.Timestamp retention_time = 3;
   */
  retentionTime?: Timestamp;

  /**
   * optional md5 sum/hash of contents. if provided, will be validated against the md5 of all contents in aggregate
   *
   * @generated from field: bytes md5 = 4;
   */
  md5: Uint8Array;

  /**
   * contents of the blob chunk, maximum size is 2MB per message (2 * 1024 * 1024 bytes)
   *
   * @generated from field: bytes chunk_contents = 5;
   */
  chunkContents: Uint8Array;

  /**
   * details regarding the blob's origin - aka source and type
   *
   * @generated from field: anduril.blobs.v1.BlobProvenance provenance = 6;
   */
  provenance?: BlobProvenance;

  constructor(data?: PartialMessage<CreateBlobChunkedRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.blobs.v1.CreateBlobChunkedRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateBlobChunkedRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateBlobChunkedRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateBlobChunkedRequest;

  static equals(a: CreateBlobChunkedRequest | PlainMessage<CreateBlobChunkedRequest> | undefined, b: CreateBlobChunkedRequest | PlainMessage<CreateBlobChunkedRequest> | undefined): boolean;
}

/**
 * @generated from message anduril.blobs.v1.CreateBlobChunkedResponse
 */
export declare class CreateBlobChunkedResponse extends Message<CreateBlobChunkedResponse> {
  /**
   * @generated from field: anduril.blobs.v1.BlobMetadata metadata = 1;
   */
  metadata?: BlobMetadata;

  /**
   * URL at which the blob can be fetched
   *
   * @generated from field: string url = 2;
   */
  url: string;

  constructor(data?: PartialMessage<CreateBlobChunkedResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.blobs.v1.CreateBlobChunkedResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateBlobChunkedResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateBlobChunkedResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateBlobChunkedResponse;

  static equals(a: CreateBlobChunkedResponse | PlainMessage<CreateBlobChunkedResponse> | undefined, b: CreateBlobChunkedResponse | PlainMessage<CreateBlobChunkedResponse> | undefined): boolean;
}

/**
 * @generated from message anduril.blobs.v1.GetBlobRequest
 */
export declare class GetBlobRequest extends Message<GetBlobRequest> {
  /**
   * @generated from field: string client_id = 1;
   */
  clientId: string;

  /**
   * @generated from field: string key = 2;
   */
  key: string;

  constructor(data?: PartialMessage<GetBlobRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.blobs.v1.GetBlobRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetBlobRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetBlobRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetBlobRequest;

  static equals(a: GetBlobRequest | PlainMessage<GetBlobRequest> | undefined, b: GetBlobRequest | PlainMessage<GetBlobRequest> | undefined): boolean;
}

/**
 * @generated from message anduril.blobs.v1.GetBlobResponse
 */
export declare class GetBlobResponse extends Message<GetBlobResponse> {
  /**
   * contents of the blob, maximum size of each response message contents in stream is capped at 2MB.
   *
   * @generated from field: bytes contents = 1;
   */
  contents: Uint8Array;

  /**
   * metadata will only be present in the first stream message
   *
   * @generated from field: anduril.blobs.v1.BlobMetadata metadata = 2;
   */
  metadata?: BlobMetadata;

  constructor(data?: PartialMessage<GetBlobResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.blobs.v1.GetBlobResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetBlobResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetBlobResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetBlobResponse;

  static equals(a: GetBlobResponse | PlainMessage<GetBlobResponse> | undefined, b: GetBlobResponse | PlainMessage<GetBlobResponse> | undefined): boolean;
}

/**
 * @generated from message anduril.blobs.v1.HeadBlobRequest
 */
export declare class HeadBlobRequest extends Message<HeadBlobRequest> {
  /**
   * @generated from field: string client_id = 1;
   */
  clientId: string;

  /**
   * @generated from field: string key = 2;
   */
  key: string;

  constructor(data?: PartialMessage<HeadBlobRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.blobs.v1.HeadBlobRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeadBlobRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeadBlobRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeadBlobRequest;

  static equals(a: HeadBlobRequest | PlainMessage<HeadBlobRequest> | undefined, b: HeadBlobRequest | PlainMessage<HeadBlobRequest> | undefined): boolean;
}

/**
 * @generated from message anduril.blobs.v1.HeadBlobResponse
 */
export declare class HeadBlobResponse extends Message<HeadBlobResponse> {
  /**
   * @generated from field: anduril.blobs.v1.BlobMetadata metadata = 1;
   */
  metadata?: BlobMetadata;

  /**
   * URL at which the blob can be fetched
   *
   * @generated from field: string url = 2;
   */
  url: string;

  constructor(data?: PartialMessage<HeadBlobResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.blobs.v1.HeadBlobResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeadBlobResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeadBlobResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeadBlobResponse;

  static equals(a: HeadBlobResponse | PlainMessage<HeadBlobResponse> | undefined, b: HeadBlobResponse | PlainMessage<HeadBlobResponse> | undefined): boolean;
}

/**
 * @generated from message anduril.blobs.v1.StreamBlobMetadataRequest
 */
export declare class StreamBlobMetadataRequest extends Message<StreamBlobMetadataRequest> {
  /**
   * The blob client_id to stream.
   *
   * @generated from field: string client_id = 1;
   */
  clientId: string;

  constructor(data?: PartialMessage<StreamBlobMetadataRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.blobs.v1.StreamBlobMetadataRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamBlobMetadataRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamBlobMetadataRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamBlobMetadataRequest;

  static equals(a: StreamBlobMetadataRequest | PlainMessage<StreamBlobMetadataRequest> | undefined, b: StreamBlobMetadataRequest | PlainMessage<StreamBlobMetadataRequest> | undefined): boolean;
}

/**
 * @generated from message anduril.blobs.v1.StreamBlobMetadataResponse
 */
export declare class StreamBlobMetadataResponse extends Message<StreamBlobMetadataResponse> {
  /**
   * The set of blob announcement metadata returned from a StreamBlobMetadataResponse.
   *
   * @generated from field: repeated anduril.blobs.v1.BlobAnnouncement announcements = 1;
   */
  announcements: BlobAnnouncement[];

  constructor(data?: PartialMessage<StreamBlobMetadataResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.blobs.v1.StreamBlobMetadataResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamBlobMetadataResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamBlobMetadataResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamBlobMetadataResponse;

  static equals(a: StreamBlobMetadataResponse | PlainMessage<StreamBlobMetadataResponse> | undefined, b: StreamBlobMetadataResponse | PlainMessage<StreamBlobMetadataResponse> | undefined): boolean;
}

/**
 * @generated from message anduril.blobs.v1.BlobAnnouncement
 */
export declare class BlobAnnouncement extends Message<BlobAnnouncement> {
  /**
   * The announced blob's specific client-driven namespace.
   *
   * @generated from field: string client_id = 1;
   */
  clientId: string;

  /**
   * The announced blob's unique key.
   *
   * @generated from field: string key = 2;
   */
  key: string;

  /**
   * The metadata describing the blob's contents.
   *
   * @generated from field: anduril.blobs.v1.BlobMetadata metadata = 3;
   */
  metadata?: BlobMetadata;

  constructor(data?: PartialMessage<BlobAnnouncement>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.blobs.v1.BlobAnnouncement";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlobAnnouncement;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlobAnnouncement;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlobAnnouncement;

  static equals(a: BlobAnnouncement | PlainMessage<BlobAnnouncement> | undefined, b: BlobAnnouncement | PlainMessage<BlobAnnouncement> | undefined): boolean;
}

