// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/blobs/v1/blobs_api.pub.proto (package anduril.blobs.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { BlobMetadata, BlobProvenance } from "./common.pub_pb.js";

/**
 * Create and store a new blob (<=2MB).
 *
 * @generated from message anduril.blobs.v1.CreateBlobRequest
 */
export class CreateBlobRequest extends Message<CreateBlobRequest> {
  /**
   * blobs created will be namespaced by client_id
   *
   * @generated from field: string client_id = 1;
   */
  clientId = "";

  /**
   * unique (per client) key for the blob
   *
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * timestamp after which should no longer retain this blob. required and cannot be > 90 days in the future.
   *
   * @generated from field: google.protobuf.Timestamp retention_time = 3;
   */
  retentionTime?: Timestamp;

  /**
   * optional md5 sum/hash of contents. if provided, will be validated against md5 of contents
   *
   * @generated from field: bytes md5 = 4;
   */
  md5 = new Uint8Array(0);

  /**
   * contents of the entire blob, maximum size is 2MB (2 * 1024 * 1024 bytes)
   *
   * @generated from field: bytes contents = 5;
   */
  contents = new Uint8Array(0);

  /**
   * details regarding the blob's origin - aka source and type
   *
   * @generated from field: anduril.blobs.v1.BlobProvenance provenance = 6;
   */
  provenance?: BlobProvenance;

  constructor(data?: PartialMessage<CreateBlobRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.blobs.v1.CreateBlobRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "retention_time", kind: "message", T: Timestamp },
    { no: 4, name: "md5", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "contents", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "provenance", kind: "message", T: BlobProvenance },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateBlobRequest {
    return new CreateBlobRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateBlobRequest {
    return new CreateBlobRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateBlobRequest {
    return new CreateBlobRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateBlobRequest | PlainMessage<CreateBlobRequest> | undefined, b: CreateBlobRequest | PlainMessage<CreateBlobRequest> | undefined): boolean {
    return proto3.util.equals(CreateBlobRequest, a, b);
  }
}

/**
 * @generated from message anduril.blobs.v1.CreateBlobResponse
 */
export class CreateBlobResponse extends Message<CreateBlobResponse> {
  /**
   * @generated from field: anduril.blobs.v1.BlobMetadata metadata = 1;
   */
  metadata?: BlobMetadata;

  /**
   * URL at which the blob can be fetched
   *
   * @generated from field: string url = 2;
   */
  url = "";

  constructor(data?: PartialMessage<CreateBlobResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.blobs.v1.CreateBlobResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: BlobMetadata },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateBlobResponse {
    return new CreateBlobResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateBlobResponse {
    return new CreateBlobResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateBlobResponse {
    return new CreateBlobResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateBlobResponse | PlainMessage<CreateBlobResponse> | undefined, b: CreateBlobResponse | PlainMessage<CreateBlobResponse> | undefined): boolean {
    return proto3.util.equals(CreateBlobResponse, a, b);
  }
}

/**
 * Create and store a new blob. Only the first 'CreateBlobChunkedRequest' message in the client stream needs
 * to contain metadata specific fields (IE: client_id, key, md5 etc.). Metadata fields set on all requests
 * ensuing the first request will be ignored.
 *
 * @generated from message anduril.blobs.v1.CreateBlobChunkedRequest
 */
export class CreateBlobChunkedRequest extends Message<CreateBlobChunkedRequest> {
  /**
   * blobs created will be namespaced by client_id
   *
   * @generated from field: string client_id = 1;
   */
  clientId = "";

  /**
   * unique (per client) key for the blob
   *
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * timestamp after which should no longer retain this blob. required and cannot be > 90 days in the future.
   *
   * @generated from field: google.protobuf.Timestamp retention_time = 3;
   */
  retentionTime?: Timestamp;

  /**
   * optional md5 sum/hash of contents. if provided, will be validated against the md5 of all contents in aggregate
   *
   * @generated from field: bytes md5 = 4;
   */
  md5 = new Uint8Array(0);

  /**
   * contents of the blob chunk, maximum size is 2MB per message (2 * 1024 * 1024 bytes)
   *
   * @generated from field: bytes chunk_contents = 5;
   */
  chunkContents = new Uint8Array(0);

  /**
   * details regarding the blob's origin - aka source and type
   *
   * @generated from field: anduril.blobs.v1.BlobProvenance provenance = 6;
   */
  provenance?: BlobProvenance;

  constructor(data?: PartialMessage<CreateBlobChunkedRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.blobs.v1.CreateBlobChunkedRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "retention_time", kind: "message", T: Timestamp },
    { no: 4, name: "md5", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "chunk_contents", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "provenance", kind: "message", T: BlobProvenance },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateBlobChunkedRequest {
    return new CreateBlobChunkedRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateBlobChunkedRequest {
    return new CreateBlobChunkedRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateBlobChunkedRequest {
    return new CreateBlobChunkedRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateBlobChunkedRequest | PlainMessage<CreateBlobChunkedRequest> | undefined, b: CreateBlobChunkedRequest | PlainMessage<CreateBlobChunkedRequest> | undefined): boolean {
    return proto3.util.equals(CreateBlobChunkedRequest, a, b);
  }
}

/**
 * @generated from message anduril.blobs.v1.CreateBlobChunkedResponse
 */
export class CreateBlobChunkedResponse extends Message<CreateBlobChunkedResponse> {
  /**
   * @generated from field: anduril.blobs.v1.BlobMetadata metadata = 1;
   */
  metadata?: BlobMetadata;

  /**
   * URL at which the blob can be fetched
   *
   * @generated from field: string url = 2;
   */
  url = "";

  constructor(data?: PartialMessage<CreateBlobChunkedResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.blobs.v1.CreateBlobChunkedResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: BlobMetadata },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateBlobChunkedResponse {
    return new CreateBlobChunkedResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateBlobChunkedResponse {
    return new CreateBlobChunkedResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateBlobChunkedResponse {
    return new CreateBlobChunkedResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateBlobChunkedResponse | PlainMessage<CreateBlobChunkedResponse> | undefined, b: CreateBlobChunkedResponse | PlainMessage<CreateBlobChunkedResponse> | undefined): boolean {
    return proto3.util.equals(CreateBlobChunkedResponse, a, b);
  }
}

/**
 * @generated from message anduril.blobs.v1.GetBlobRequest
 */
export class GetBlobRequest extends Message<GetBlobRequest> {
  /**
   * @generated from field: string client_id = 1;
   */
  clientId = "";

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  constructor(data?: PartialMessage<GetBlobRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.blobs.v1.GetBlobRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetBlobRequest {
    return new GetBlobRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetBlobRequest {
    return new GetBlobRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetBlobRequest {
    return new GetBlobRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetBlobRequest | PlainMessage<GetBlobRequest> | undefined, b: GetBlobRequest | PlainMessage<GetBlobRequest> | undefined): boolean {
    return proto3.util.equals(GetBlobRequest, a, b);
  }
}

/**
 * @generated from message anduril.blobs.v1.GetBlobResponse
 */
export class GetBlobResponse extends Message<GetBlobResponse> {
  /**
   * contents of the blob, maximum size of each response message contents in stream is capped at 2MB.
   *
   * @generated from field: bytes contents = 1;
   */
  contents = new Uint8Array(0);

  /**
   * metadata will only be present in the first stream message
   *
   * @generated from field: anduril.blobs.v1.BlobMetadata metadata = 2;
   */
  metadata?: BlobMetadata;

  constructor(data?: PartialMessage<GetBlobResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.blobs.v1.GetBlobResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "contents", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "metadata", kind: "message", T: BlobMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetBlobResponse {
    return new GetBlobResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetBlobResponse {
    return new GetBlobResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetBlobResponse {
    return new GetBlobResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetBlobResponse | PlainMessage<GetBlobResponse> | undefined, b: GetBlobResponse | PlainMessage<GetBlobResponse> | undefined): boolean {
    return proto3.util.equals(GetBlobResponse, a, b);
  }
}

/**
 * @generated from message anduril.blobs.v1.HeadBlobRequest
 */
export class HeadBlobRequest extends Message<HeadBlobRequest> {
  /**
   * @generated from field: string client_id = 1;
   */
  clientId = "";

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  constructor(data?: PartialMessage<HeadBlobRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.blobs.v1.HeadBlobRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeadBlobRequest {
    return new HeadBlobRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeadBlobRequest {
    return new HeadBlobRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeadBlobRequest {
    return new HeadBlobRequest().fromJsonString(jsonString, options);
  }

  static equals(a: HeadBlobRequest | PlainMessage<HeadBlobRequest> | undefined, b: HeadBlobRequest | PlainMessage<HeadBlobRequest> | undefined): boolean {
    return proto3.util.equals(HeadBlobRequest, a, b);
  }
}

/**
 * @generated from message anduril.blobs.v1.HeadBlobResponse
 */
export class HeadBlobResponse extends Message<HeadBlobResponse> {
  /**
   * @generated from field: anduril.blobs.v1.BlobMetadata metadata = 1;
   */
  metadata?: BlobMetadata;

  /**
   * URL at which the blob can be fetched
   *
   * @generated from field: string url = 2;
   */
  url = "";

  constructor(data?: PartialMessage<HeadBlobResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.blobs.v1.HeadBlobResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metadata", kind: "message", T: BlobMetadata },
    { no: 2, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeadBlobResponse {
    return new HeadBlobResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeadBlobResponse {
    return new HeadBlobResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeadBlobResponse {
    return new HeadBlobResponse().fromJsonString(jsonString, options);
  }

  static equals(a: HeadBlobResponse | PlainMessage<HeadBlobResponse> | undefined, b: HeadBlobResponse | PlainMessage<HeadBlobResponse> | undefined): boolean {
    return proto3.util.equals(HeadBlobResponse, a, b);
  }
}

/**
 * @generated from message anduril.blobs.v1.StreamBlobMetadataRequest
 */
export class StreamBlobMetadataRequest extends Message<StreamBlobMetadataRequest> {
  /**
   * The blob client_id to stream.
   *
   * @generated from field: string client_id = 1;
   */
  clientId = "";

  constructor(data?: PartialMessage<StreamBlobMetadataRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.blobs.v1.StreamBlobMetadataRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamBlobMetadataRequest {
    return new StreamBlobMetadataRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamBlobMetadataRequest {
    return new StreamBlobMetadataRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamBlobMetadataRequest {
    return new StreamBlobMetadataRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamBlobMetadataRequest | PlainMessage<StreamBlobMetadataRequest> | undefined, b: StreamBlobMetadataRequest | PlainMessage<StreamBlobMetadataRequest> | undefined): boolean {
    return proto3.util.equals(StreamBlobMetadataRequest, a, b);
  }
}

/**
 * @generated from message anduril.blobs.v1.StreamBlobMetadataResponse
 */
export class StreamBlobMetadataResponse extends Message<StreamBlobMetadataResponse> {
  /**
   * The set of blob announcement metadata returned from a StreamBlobMetadataResponse.
   *
   * @generated from field: repeated anduril.blobs.v1.BlobAnnouncement announcements = 1;
   */
  announcements: BlobAnnouncement[] = [];

  constructor(data?: PartialMessage<StreamBlobMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.blobs.v1.StreamBlobMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "announcements", kind: "message", T: BlobAnnouncement, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamBlobMetadataResponse {
    return new StreamBlobMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamBlobMetadataResponse {
    return new StreamBlobMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamBlobMetadataResponse {
    return new StreamBlobMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamBlobMetadataResponse | PlainMessage<StreamBlobMetadataResponse> | undefined, b: StreamBlobMetadataResponse | PlainMessage<StreamBlobMetadataResponse> | undefined): boolean {
    return proto3.util.equals(StreamBlobMetadataResponse, a, b);
  }
}

/**
 * @generated from message anduril.blobs.v1.BlobAnnouncement
 */
export class BlobAnnouncement extends Message<BlobAnnouncement> {
  /**
   * The announced blob's specific client-driven namespace.
   *
   * @generated from field: string client_id = 1;
   */
  clientId = "";

  /**
   * The announced blob's unique key.
   *
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * The metadata describing the blob's contents.
   *
   * @generated from field: anduril.blobs.v1.BlobMetadata metadata = 3;
   */
  metadata?: BlobMetadata;

  constructor(data?: PartialMessage<BlobAnnouncement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.blobs.v1.BlobAnnouncement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "metadata", kind: "message", T: BlobMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlobAnnouncement {
    return new BlobAnnouncement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlobAnnouncement {
    return new BlobAnnouncement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlobAnnouncement {
    return new BlobAnnouncement().fromJsonString(jsonString, options);
  }

  static equals(a: BlobAnnouncement | PlainMessage<BlobAnnouncement> | undefined, b: BlobAnnouncement | PlainMessage<BlobAnnouncement> | undefined): boolean {
    return proto3.util.equals(BlobAnnouncement, a, b);
  }
}

