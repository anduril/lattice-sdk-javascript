// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/type/coords.pub.proto (package anduril.type, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * Spherical angular coordinates
 *
 * @generated from message anduril.type.ThetaPhi
 */
export class ThetaPhi extends Message<ThetaPhi> {
  /**
   * Angle clockwise relative to forward in degrees (Azimuth).
   *
   * @generated from field: double theta = 1;
   */
  theta = 0;

  /**
   * Angle upward relative to forward in degrees (Elevation).
   *
   * @generated from field: double phi = 2;
   */
  phi = 0;

  constructor(data?: PartialMessage<ThetaPhi>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.ThetaPhi";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "theta", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "phi", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ThetaPhi {
    return new ThetaPhi().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ThetaPhi {
    return new ThetaPhi().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ThetaPhi {
    return new ThetaPhi().fromJsonString(jsonString, options);
  }

  static equals(a: ThetaPhi | PlainMessage<ThetaPhi> | undefined, b: ThetaPhi | PlainMessage<ThetaPhi> | undefined): boolean {
    return proto3.util.equals(ThetaPhi, a, b);
  }
}

/**
 * @generated from message anduril.type.LLA
 */
export class LLA extends Message<LLA> {
  /**
   * WGS84 longitude in decimal degrees
   *
   * @generated from field: double lon = 1;
   */
  lon = 0;

  /**
   * WGS84 geodetic latitude in decimal degrees
   *
   * @generated from field: double lat = 2;
   */
  lat = 0;

  /**
   * altitude in meters above either WGS84 or EGM96 (see altitude_reference)
   *
   * @generated from field: double alt = 3;
   */
  alt = 0;

  /**
   * [default=false] indicates that altitude is either unset or so uncertain that it is meaningless
   *
   * @generated from field: bool is2d = 4;
   */
  is2d = false;

  /**
   * Meaning of alt.
   * altitude in meters above either WGS84 or EGM96, use altitude_reference to
   * determine what zero means.
   *
   * @generated from field: anduril.type.LLA.AltitudeReference altitude_reference = 5;
   */
  altitudeReference = LLA_AltitudeReference.INVALID;

  constructor(data?: PartialMessage<LLA>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.LLA";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lon", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "lat", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "alt", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "is2d", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "altitude_reference", kind: "enum", T: proto3.getEnumType(LLA_AltitudeReference) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LLA {
    return new LLA().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LLA {
    return new LLA().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LLA {
    return new LLA().fromJsonString(jsonString, options);
  }

  static equals(a: LLA | PlainMessage<LLA> | undefined, b: LLA | PlainMessage<LLA> | undefined): boolean {
    return proto3.util.equals(LLA, a, b);
  }
}

/**
 * What altitude of zero refers to.
 *
 * @generated from enum anduril.type.LLA.AltitudeReference
 */
export enum LLA_AltitudeReference {
  /**
   * Depending on the context its possible INVALID just means that it is
   * clear from the context (e.g. this is LLA is named lla_hae).
   * This also might mean AGL which would depend on what height map you are
   * using.
   *
   * @generated from enum value: ALTITUDE_REFERENCE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * commonly called height above ellipsoid (HAE)
   *
   * @generated from enum value: ALTITUDE_REFERENCE_HEIGHT_ABOVE_WGS84 = 1;
   */
  HEIGHT_ABOVE_WGS84 = 1,

  /**
   * commonly called mean sea level (MSL)
   *
   * @generated from enum value: ALTITUDE_REFERENCE_HEIGHT_ABOVE_EGM96 = 2;
   */
  HEIGHT_ABOVE_EGM96 = 2,

  /**
   * Publishing an altitude with an unkown reference
   *
   * @generated from enum value: ALTITUDE_REFERENCE_UNKNOWN = 3;
   */
  UNKNOWN = 3,

  /**
   * ADSB sometimes published barometrically-measured alt
   *
   * @generated from enum value: ALTITUDE_REFERENCE_BAROMETRIC = 4;
   */
  BAROMETRIC = 4,

  /**
   * Positive distance above sea floor (ASF) at a specific lat/lon
   *
   * @generated from enum value: ALTITUDE_REFERENCE_ABOVE_SEA_FLOOR = 5;
   */
  ABOVE_SEA_FLOOR = 5,

  /**
   * Positive distance below surface at a specific lat/lon
   *
   * @generated from enum value: ALTITUDE_REFERENCE_BELOW_SEA_SURFACE = 6;
   */
  BELOW_SEA_SURFACE = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(LLA_AltitudeReference)
proto3.util.setEnumType(LLA_AltitudeReference, "anduril.type.LLA.AltitudeReference", [
  { no: 0, name: "ALTITUDE_REFERENCE_INVALID" },
  { no: 1, name: "ALTITUDE_REFERENCE_HEIGHT_ABOVE_WGS84" },
  { no: 2, name: "ALTITUDE_REFERENCE_HEIGHT_ABOVE_EGM96" },
  { no: 3, name: "ALTITUDE_REFERENCE_UNKNOWN" },
  { no: 4, name: "ALTITUDE_REFERENCE_BAROMETRIC" },
  { no: 5, name: "ALTITUDE_REFERENCE_ABOVE_SEA_FLOOR" },
  { no: 6, name: "ALTITUDE_REFERENCE_BELOW_SEA_SURFACE" },
]);

/**
 * @generated from message anduril.type.ENU
 */
export class ENU extends Message<ENU> {
  /**
   * @generated from field: double e = 1;
   */
  e = 0;

  /**
   * @generated from field: double n = 2;
   */
  n = 0;

  /**
   * @generated from field: double u = 3;
   */
  u = 0;

  constructor(data?: PartialMessage<ENU>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.ENU";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "e", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "n", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "u", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ENU {
    return new ENU().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ENU {
    return new ENU().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ENU {
    return new ENU().fromJsonString(jsonString, options);
  }

  static equals(a: ENU | PlainMessage<ENU> | undefined, b: ENU | PlainMessage<ENU> | undefined): boolean {
    return proto3.util.equals(ENU, a, b);
  }
}

/**
 * Holds ECI (Earth-Centered Inertial, https://en.wikipedia.org/wiki/Earth-centered_inertial)
 * coordinates.
 *
 * @generated from message anduril.type.ECI
 */
export class ECI extends Message<ECI> {
  /**
   * Holds the x-coordinate of ECI.
   *
   * @generated from field: double x = 1;
   */
  x = 0;

  /**
   * Holds the y-coordinate of ECI.
   *
   * @generated from field: double y = 2;
   */
  y = 0;

  /**
   * Holds the z-coordinate of ECI.
   *
   * @generated from field: double z = 3;
   */
  z = 0;

  constructor(data?: PartialMessage<ECI>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.ECI";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "y", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "z", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ECI {
    return new ECI().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ECI {
    return new ECI().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ECI {
    return new ECI().fromJsonString(jsonString, options);
  }

  static equals(a: ECI | PlainMessage<ECI> | undefined, b: ECI | PlainMessage<ECI> | undefined): boolean {
    return proto3.util.equals(ECI, a, b);
  }
}

/**
 * @generated from message anduril.type.Vec2
 */
export class Vec2 extends Message<Vec2> {
  /**
   * @generated from field: double x = 1;
   */
  x = 0;

  /**
   * @generated from field: double y = 2;
   */
  y = 0;

  constructor(data?: PartialMessage<Vec2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.Vec2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "y", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vec2 {
    return new Vec2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vec2 {
    return new Vec2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vec2 {
    return new Vec2().fromJsonString(jsonString, options);
  }

  static equals(a: Vec2 | PlainMessage<Vec2> | undefined, b: Vec2 | PlainMessage<Vec2> | undefined): boolean {
    return proto3.util.equals(Vec2, a, b);
  }
}

/**
 * @generated from message anduril.type.Vec2f
 */
export class Vec2f extends Message<Vec2f> {
  /**
   * @generated from field: float x = 1;
   */
  x = 0;

  /**
   * @generated from field: float y = 2;
   */
  y = 0;

  constructor(data?: PartialMessage<Vec2f>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.Vec2f";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "y", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vec2f {
    return new Vec2f().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vec2f {
    return new Vec2f().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vec2f {
    return new Vec2f().fromJsonString(jsonString, options);
  }

  static equals(a: Vec2f | PlainMessage<Vec2f> | undefined, b: Vec2f | PlainMessage<Vec2f> | undefined): boolean {
    return proto3.util.equals(Vec2f, a, b);
  }
}

/**
 * @generated from message anduril.type.Vec3
 */
export class Vec3 extends Message<Vec3> {
  /**
   * @generated from field: double x = 1;
   */
  x = 0;

  /**
   * @generated from field: double y = 2;
   */
  y = 0;

  /**
   * @generated from field: double z = 3;
   */
  z = 0;

  constructor(data?: PartialMessage<Vec3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.Vec3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "y", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "z", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vec3 {
    return new Vec3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vec3 {
    return new Vec3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vec3 {
    return new Vec3().fromJsonString(jsonString, options);
  }

  static equals(a: Vec3 | PlainMessage<Vec3> | undefined, b: Vec3 | PlainMessage<Vec3> | undefined): boolean {
    return proto3.util.equals(Vec3, a, b);
  }
}

/**
 * @generated from message anduril.type.Vec3f
 */
export class Vec3f extends Message<Vec3f> {
  /**
   * @generated from field: float x = 1;
   */
  x = 0;

  /**
   * @generated from field: float y = 2;
   */
  y = 0;

  /**
   * @generated from field: float z = 3;
   */
  z = 0;

  constructor(data?: PartialMessage<Vec3f>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.Vec3f";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "y", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "z", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vec3f {
    return new Vec3f().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vec3f {
    return new Vec3f().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vec3f {
    return new Vec3f().fromJsonString(jsonString, options);
  }

  static equals(a: Vec3f | PlainMessage<Vec3f> | undefined, b: Vec3f | PlainMessage<Vec3f> | undefined): boolean {
    return proto3.util.equals(Vec3f, a, b);
  }
}

/**
 * @generated from message anduril.type.Quaternion
 */
export class Quaternion extends Message<Quaternion> {
  /**
   * x, y, z are vector portion, w is scalar
   *
   * @generated from field: double x = 1;
   */
  x = 0;

  /**
   * @generated from field: double y = 2;
   */
  y = 0;

  /**
   * @generated from field: double z = 3;
   */
  z = 0;

  /**
   * @generated from field: double w = 4;
   */
  w = 0;

  constructor(data?: PartialMessage<Quaternion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.Quaternion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "y", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "z", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "w", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Quaternion {
    return new Quaternion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Quaternion {
    return new Quaternion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Quaternion {
    return new Quaternion().fromJsonString(jsonString, options);
  }

  static equals(a: Quaternion | PlainMessage<Quaternion> | undefined, b: Quaternion | PlainMessage<Quaternion> | undefined): boolean {
    return proto3.util.equals(Quaternion, a, b);
  }
}

/**
 * Yaw-Pitch in radians
 *
 * @generated from message anduril.type.YawPitch
 */
export class YawPitch extends Message<YawPitch> {
  /**
   * @generated from field: double yaw = 1;
   */
  yaw = 0;

  /**
   * @generated from field: double pitch = 2;
   */
  pitch = 0;

  constructor(data?: PartialMessage<YawPitch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.YawPitch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "yaw", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "pitch", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): YawPitch {
    return new YawPitch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): YawPitch {
    return new YawPitch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): YawPitch {
    return new YawPitch().fromJsonString(jsonString, options);
  }

  static equals(a: YawPitch | PlainMessage<YawPitch> | undefined, b: YawPitch | PlainMessage<YawPitch> | undefined): boolean {
    return proto3.util.equals(YawPitch, a, b);
  }
}

/**
 * Yaw-Pitch-Roll in degrees.
 *
 * @generated from message anduril.type.YPR
 */
export class YPR extends Message<YPR> {
  /**
   * @generated from field: double yaw = 1;
   */
  yaw = 0;

  /**
   * @generated from field: double pitch = 2;
   */
  pitch = 0;

  /**
   * @generated from field: double roll = 3;
   */
  roll = 0;

  constructor(data?: PartialMessage<YPR>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.YPR";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "yaw", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "pitch", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "roll", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): YPR {
    return new YPR().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): YPR {
    return new YPR().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): YPR {
    return new YPR().fromJsonString(jsonString, options);
  }

  static equals(a: YPR | PlainMessage<YPR> | undefined, b: YPR | PlainMessage<YPR> | undefined): boolean {
    return proto3.util.equals(YPR, a, b);
  }
}

/**
 * @generated from message anduril.type.Pose
 */
export class Pose extends Message<Pose> {
  /**
   * Geospatial location defined by this Pose.
   *
   * @generated from field: anduril.type.LLA pos = 1;
   */
  pos?: LLA;

  /**
   * The quaternion to transform a point in the Pose frame to the ENU frame. The Pose frame could be Body, Turret,
   * etc and is determined by the context in which this Pose is used.
   * The normal convention for defining orientation is to list the frames of transformation, for example
   * att_gimbal_to_enu is the quaternion which transforms a point in the gimbal frame to the body frame, but
   * in this case we truncate to att_enu because the Pose frame isn't defined. A potentially better name for this
   * field would have been att_pose_to_enu.
   *
   * Implementations of this quaternion should left multiply this quaternion to transform a point from the Pose frame
   * to the enu frame. Following the geometry-cpp rotation convention, the following example would be valid:
   * (https://ghe.anduril.dev/autonomy/geometry-cpp/blob/master/src/Rotation.h#L90)
   *
   * Point<Pose\> posePt{1,0,0};
   * Rotation<Enu, Pose\> attPoseToEnu{};
   * Point<Enu\> = attPoseToEnu*posePt;
   *
   * This transformed point represents some vector in ENU space that is aligned with the x axis of the attPoseToEnu
   * matrix.
   *
   * An alternative matrix expression is as follows:
   * ptEnu = M x ptPose
   *
   * @generated from field: anduril.type.Quaternion att_enu = 2;
   */
  attEnu?: Quaternion;

  constructor(data?: PartialMessage<Pose>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.Pose";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pos", kind: "message", T: LLA },
    { no: 2, name: "att_enu", kind: "message", T: Quaternion },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pose {
    return new Pose().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pose {
    return new Pose().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pose {
    return new Pose().fromJsonString(jsonString, options);
  }

  static equals(a: Pose | PlainMessage<Pose> | undefined, b: Pose | PlainMessage<Pose> | undefined): boolean {
    return proto3.util.equals(Pose, a, b);
  }
}

/**
 * @generated from message anduril.type.LLAPolygon
 */
export class LLAPolygon extends Message<LLAPolygon> {
  /**
   * standard is that points are defined in a counter-clockwise order. this
   * is only the exterior ring of a polygon, no holes are supported.
   *
   * @generated from field: repeated anduril.type.LLA points = 1;
   */
  points: LLA[] = [];

  constructor(data?: PartialMessage<LLAPolygon>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.LLAPolygon";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "points", kind: "message", T: LLA, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LLAPolygon {
    return new LLAPolygon().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LLAPolygon {
    return new LLAPolygon().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LLAPolygon {
    return new LLAPolygon().fromJsonString(jsonString, options);
  }

  static equals(a: LLAPolygon | PlainMessage<LLAPolygon> | undefined, b: LLAPolygon | PlainMessage<LLAPolygon> | undefined): boolean {
    return proto3.util.equals(LLAPolygon, a, b);
  }
}

/**
 * @generated from message anduril.type.AERPolygon
 */
export class AERPolygon extends Message<AERPolygon> {
  /**
   * Azimuth-Range-Elevation
   *
   * @generated from field: repeated anduril.type.Spherical points = 1;
   */
  points: Spherical[] = [];

  constructor(data?: PartialMessage<AERPolygon>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.AERPolygon";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "points", kind: "message", T: Spherical, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AERPolygon {
    return new AERPolygon().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AERPolygon {
    return new AERPolygon().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AERPolygon {
    return new AERPolygon().fromJsonString(jsonString, options);
  }

  static equals(a: AERPolygon | PlainMessage<AERPolygon> | undefined, b: AERPolygon | PlainMessage<AERPolygon> | undefined): boolean {
    return proto3.util.equals(AERPolygon, a, b);
  }
}

/**
 * @generated from message anduril.type.LLAPath
 */
export class LLAPath extends Message<LLAPath> {
  /**
   * Ordered list of points on the path.
   *
   * @generated from field: repeated anduril.type.LLA points = 1;
   */
  points: LLA[] = [];

  /**
   * True if the last point on the path connects to the first in a closed
   * loop
   *
   * @generated from field: bool loop = 2;
   */
  loop = false;

  constructor(data?: PartialMessage<LLAPath>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.LLAPath";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "points", kind: "message", T: LLA, repeated: true },
    { no: 2, name: "loop", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LLAPath {
    return new LLAPath().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LLAPath {
    return new LLAPath().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LLAPath {
    return new LLAPath().fromJsonString(jsonString, options);
  }

  static equals(a: LLAPath | PlainMessage<LLAPath> | undefined, b: LLAPath | PlainMessage<LLAPath> | undefined): boolean {
    return proto3.util.equals(LLAPath, a, b);
  }
}

/**
 * @generated from message anduril.type.Spherical
 */
export class Spherical extends Message<Spherical> {
  /**
   * azimuth angle in radians
   *
   * @generated from field: double az = 1;
   */
  az = 0;

  /**
   * elevation angle in radians, we'll use 0 = XY plane
   *
   * @generated from field: double el = 2;
   */
  el = 0;

  /**
   * range in meters
   *
   * @generated from field: double range = 3;
   */
  range = 0;

  constructor(data?: PartialMessage<Spherical>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.Spherical";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "az", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "el", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "range", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Spherical {
    return new Spherical().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Spherical {
    return new Spherical().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Spherical {
    return new Spherical().fromJsonString(jsonString, options);
  }

  static equals(a: Spherical | PlainMessage<Spherical> | undefined, b: Spherical | PlainMessage<Spherical> | undefined): boolean {
    return proto3.util.equals(Spherical, a, b);
  }
}

/**
 * @generated from message anduril.type.DoubleRange
 */
export class DoubleRange extends Message<DoubleRange> {
  /**
   * @generated from field: double min = 1;
   */
  min = 0;

  /**
   * @generated from field: double max = 2;
   */
  max = 0;

  constructor(data?: PartialMessage<DoubleRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.DoubleRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "max", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleRange {
    return new DoubleRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleRange {
    return new DoubleRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleRange {
    return new DoubleRange().fromJsonString(jsonString, options);
  }

  static equals(a: DoubleRange | PlainMessage<DoubleRange> | undefined, b: DoubleRange | PlainMessage<DoubleRange> | undefined): boolean {
    return proto3.util.equals(DoubleRange, a, b);
  }
}

/**
 * @generated from message anduril.type.Uint64Range
 */
export class Uint64Range extends Message<Uint64Range> {
  /**
   * @generated from field: uint64 min = 1;
   */
  min = protoInt64.zero;

  /**
   * @generated from field: uint64 max = 2;
   */
  max = protoInt64.zero;

  constructor(data?: PartialMessage<Uint64Range>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.Uint64Range";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "max", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Uint64Range {
    return new Uint64Range().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Uint64Range {
    return new Uint64Range().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Uint64Range {
    return new Uint64Range().fromJsonString(jsonString, options);
  }

  static equals(a: Uint64Range | PlainMessage<Uint64Range> | undefined, b: Uint64Range | PlainMessage<Uint64Range> | undefined): boolean {
    return proto3.util.equals(Uint64Range, a, b);
  }
}

/**
 * A symmetric 4D matrix only representing the upper right triangle, useful for covariance matrices.
 *
 * @generated from message anduril.type.TMat4f
 */
export class TMat4f extends Message<TMat4f> {
  /**
   * @generated from field: float m00 = 1;
   */
  m00 = 0;

  /**
   * @generated from field: float m01 = 2;
   */
  m01 = 0;

  /**
   * @generated from field: float m02 = 3;
   */
  m02 = 0;

  /**
   * @generated from field: float m03 = 4;
   */
  m03 = 0;

  /**
   * @generated from field: float m11 = 5;
   */
  m11 = 0;

  /**
   * @generated from field: float m12 = 6;
   */
  m12 = 0;

  /**
   * @generated from field: float m13 = 7;
   */
  m13 = 0;

  /**
   * @generated from field: float m22 = 8;
   */
  m22 = 0;

  /**
   * @generated from field: float m23 = 9;
   */
  m23 = 0;

  /**
   * @generated from field: float m33 = 10;
   */
  m33 = 0;

  constructor(data?: PartialMessage<TMat4f>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.TMat4f";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "m00", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "m01", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "m02", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "m03", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "m11", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 6, name: "m12", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 7, name: "m13", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 8, name: "m22", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 9, name: "m23", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 10, name: "m33", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TMat4f {
    return new TMat4f().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TMat4f {
    return new TMat4f().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TMat4f {
    return new TMat4f().fromJsonString(jsonString, options);
  }

  static equals(a: TMat4f | PlainMessage<TMat4f> | undefined, b: TMat4f | PlainMessage<TMat4f> | undefined): boolean {
    return proto3.util.equals(TMat4f, a, b);
  }
}

/**
 * A symmetric 3D matrix only representing the upper right triangle, useful for covariance matrices.
 *
 * @generated from message anduril.type.TMat3
 */
export class TMat3 extends Message<TMat3> {
  /**
   * @generated from field: double mxx = 1;
   */
  mxx = 0;

  /**
   * @generated from field: double mxy = 2;
   */
  mxy = 0;

  /**
   * @generated from field: double mxz = 3;
   */
  mxz = 0;

  /**
   * @generated from field: double myy = 4;
   */
  myy = 0;

  /**
   * @generated from field: double myz = 5;
   */
  myz = 0;

  /**
   * @generated from field: double mzz = 6;
   */
  mzz = 0;

  constructor(data?: PartialMessage<TMat3>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.TMat3";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mxx", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "mxy", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "mxz", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "myy", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "myz", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "mzz", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TMat3 {
    return new TMat3().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TMat3 {
    return new TMat3().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TMat3 {
    return new TMat3().fromJsonString(jsonString, options);
  }

  static equals(a: TMat3 | PlainMessage<TMat3> | undefined, b: TMat3 | PlainMessage<TMat3> | undefined): boolean {
    return proto3.util.equals(TMat3, a, b);
  }
}

/**
 * symmetric 2d matrix only representing the upper right triangle, useful for
 * covariance matrices
 *
 * @generated from message anduril.type.TMat2
 */
export class TMat2 extends Message<TMat2> {
  /**
   * @generated from field: double mxx = 1;
   */
  mxx = 0;

  /**
   * @generated from field: double mxy = 2;
   */
  mxy = 0;

  /**
   * @generated from field: double myy = 3;
   */
  myy = 0;

  constructor(data?: PartialMessage<TMat2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.TMat2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mxx", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "mxy", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "myy", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TMat2 {
    return new TMat2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TMat2 {
    return new TMat2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TMat2 {
    return new TMat2().fromJsonString(jsonString, options);
  }

  static equals(a: TMat2 | PlainMessage<TMat2> | undefined, b: TMat2 | PlainMessage<TMat2> | undefined): boolean {
    return proto3.util.equals(TMat2, a, b);
  }
}

/**
 * Rx + t, Technically this is a duplicate of AffineTransform
 * but Affine Transform isn't really an affine transform (since it doesn't allow
 * skewing and stretching).
 *
 * @generated from message anduril.type.RigidTransform
 */
export class RigidTransform extends Message<RigidTransform> {
  /**
   * @generated from field: anduril.type.Quaternion rotation = 3;
   */
  rotation?: Quaternion;

  /**
   * @generated from field: anduril.type.Vec3 translation = 4;
   */
  translation?: Vec3;

  constructor(data?: PartialMessage<RigidTransform>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.type.RigidTransform";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "rotation", kind: "message", T: Quaternion },
    { no: 4, name: "translation", kind: "message", T: Vec3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RigidTransform {
    return new RigidTransform().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RigidTransform {
    return new RigidTransform().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RigidTransform {
    return new RigidTransform().fromJsonString(jsonString, options);
  }

  static equals(a: RigidTransform | PlainMessage<RigidTransform> | undefined, b: RigidTransform | PlainMessage<RigidTransform> | undefined): boolean {
    return proto3.util.equals(RigidTransform, a, b);
  }
}

