// @generated by protoc-gen-es v1.7.2
// @generated from file anduril/type/coords.pub.proto (package anduril.type, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { proto3 } from "@bufbuild/protobuf";

/**
 * Spherical angular coordinates
 *
 * @generated from message anduril.type.ThetaPhi
 */
export const ThetaPhi = proto3.makeMessageType(
  "anduril.type.ThetaPhi",
  () => [
    { no: 1, name: "theta", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "phi", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ],
);

/**
 * @generated from message anduril.type.LLA
 */
export const LLA = proto3.makeMessageType(
  "anduril.type.LLA",
  () => [
    { no: 1, name: "lon", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "lat", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "alt", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "is2d", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "altitude_reference", kind: "enum", T: proto3.getEnumType(LLA_AltitudeReference) },
  ],
);

/**
 * What altitude of zero refers to.
 *
 * @generated from enum anduril.type.LLA.AltitudeReference
 */
export const LLA_AltitudeReference = proto3.makeEnum(
  "anduril.type.LLA.AltitudeReference",
  [
    {no: 0, name: "ALTITUDE_REFERENCE_INVALID", localName: "INVALID"},
    {no: 1, name: "ALTITUDE_REFERENCE_HEIGHT_ABOVE_WGS84", localName: "HEIGHT_ABOVE_WGS84"},
    {no: 2, name: "ALTITUDE_REFERENCE_HEIGHT_ABOVE_EGM96", localName: "HEIGHT_ABOVE_EGM96"},
    {no: 3, name: "ALTITUDE_REFERENCE_UNKNOWN", localName: "UNKNOWN"},
    {no: 4, name: "ALTITUDE_REFERENCE_BAROMETRIC", localName: "BAROMETRIC"},
    {no: 5, name: "ALTITUDE_REFERENCE_ABOVE_SEA_FLOOR", localName: "ABOVE_SEA_FLOOR"},
    {no: 6, name: "ALTITUDE_REFERENCE_BELOW_SEA_SURFACE", localName: "BELOW_SEA_SURFACE"},
  ],
);

/**
 * @generated from message anduril.type.ENU
 */
export const ENU = proto3.makeMessageType(
  "anduril.type.ENU",
  () => [
    { no: 1, name: "e", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "n", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "u", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ],
);

/**
 * Holds ECI (Earth-Centered Inertial, https://en.wikipedia.org/wiki/Earth-centered_inertial)
 * coordinates.
 *
 * @generated from message anduril.type.ECI
 */
export const ECI = proto3.makeMessageType(
  "anduril.type.ECI",
  () => [
    { no: 1, name: "x", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "y", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "z", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ],
);

/**
 * @generated from message anduril.type.Vec2
 */
export const Vec2 = proto3.makeMessageType(
  "anduril.type.Vec2",
  () => [
    { no: 1, name: "x", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "y", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ],
);

/**
 * @generated from message anduril.type.Vec2f
 */
export const Vec2f = proto3.makeMessageType(
  "anduril.type.Vec2f",
  () => [
    { no: 1, name: "x", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "y", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ],
);

/**
 * @generated from message anduril.type.Vec3
 */
export const Vec3 = proto3.makeMessageType(
  "anduril.type.Vec3",
  () => [
    { no: 1, name: "x", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "y", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "z", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ],
);

/**
 * @generated from message anduril.type.Vec3f
 */
export const Vec3f = proto3.makeMessageType(
  "anduril.type.Vec3f",
  () => [
    { no: 1, name: "x", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "y", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "z", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ],
);

/**
 * @generated from message anduril.type.Quaternion
 */
export const Quaternion = proto3.makeMessageType(
  "anduril.type.Quaternion",
  () => [
    { no: 1, name: "x", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "y", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "z", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "w", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ],
);

/**
 * Yaw-Pitch in radians
 *
 * @generated from message anduril.type.YawPitch
 */
export const YawPitch = proto3.makeMessageType(
  "anduril.type.YawPitch",
  () => [
    { no: 1, name: "yaw", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "pitch", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ],
);

/**
 * Yaw-Pitch-Roll in degrees.
 *
 * @generated from message anduril.type.YPR
 */
export const YPR = proto3.makeMessageType(
  "anduril.type.YPR",
  () => [
    { no: 1, name: "yaw", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "pitch", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "roll", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ],
);

/**
 * @generated from message anduril.type.Pose
 */
export const Pose = proto3.makeMessageType(
  "anduril.type.Pose",
  () => [
    { no: 1, name: "pos", kind: "message", T: LLA },
    { no: 2, name: "att_enu", kind: "message", T: Quaternion },
  ],
);

/**
 * @generated from message anduril.type.LLAPolygon
 */
export const LLAPolygon = proto3.makeMessageType(
  "anduril.type.LLAPolygon",
  () => [
    { no: 1, name: "points", kind: "message", T: LLA, repeated: true },
  ],
);

/**
 * @generated from message anduril.type.AERPolygon
 */
export const AERPolygon = proto3.makeMessageType(
  "anduril.type.AERPolygon",
  () => [
    { no: 1, name: "points", kind: "message", T: Spherical, repeated: true },
  ],
);

/**
 * @generated from message anduril.type.LLAPath
 */
export const LLAPath = proto3.makeMessageType(
  "anduril.type.LLAPath",
  () => [
    { no: 1, name: "points", kind: "message", T: LLA, repeated: true },
    { no: 2, name: "loop", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * @generated from message anduril.type.Spherical
 */
export const Spherical = proto3.makeMessageType(
  "anduril.type.Spherical",
  () => [
    { no: 1, name: "az", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "el", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "range", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ],
);

/**
 * @generated from message anduril.type.DoubleRange
 */
export const DoubleRange = proto3.makeMessageType(
  "anduril.type.DoubleRange",
  () => [
    { no: 1, name: "min", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "max", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ],
);

/**
 * @generated from message anduril.type.Uint64Range
 */
export const Uint64Range = proto3.makeMessageType(
  "anduril.type.Uint64Range",
  () => [
    { no: 1, name: "min", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "max", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ],
);

/**
 * A symmetric 4D matrix only representing the upper right triangle, useful for covariance matrices.
 *
 * @generated from message anduril.type.TMat4f
 */
export const TMat4f = proto3.makeMessageType(
  "anduril.type.TMat4f",
  () => [
    { no: 1, name: "m00", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "m01", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "m02", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "m03", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "m11", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 6, name: "m12", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 7, name: "m13", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 8, name: "m22", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 9, name: "m23", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 10, name: "m33", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ],
);

/**
 * A symmetric 3D matrix only representing the upper right triangle, useful for covariance matrices.
 *
 * @generated from message anduril.type.TMat3
 */
export const TMat3 = proto3.makeMessageType(
  "anduril.type.TMat3",
  () => [
    { no: 1, name: "mxx", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "mxy", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "mxz", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "myy", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "myz", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "mzz", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ],
);

/**
 * symmetric 2d matrix only representing the upper right triangle, useful for
 * covariance matrices
 *
 * @generated from message anduril.type.TMat2
 */
export const TMat2 = proto3.makeMessageType(
  "anduril.type.TMat2",
  () => [
    { no: 1, name: "mxx", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "mxy", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "myy", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ],
);

/**
 * Rx + t, Technically this is a duplicate of AffineTransform
 * but Affine Transform isn't really an affine transform (since it doesn't allow
 * skewing and stretching).
 *
 * @generated from message anduril.type.RigidTransform
 */
export const RigidTransform = proto3.makeMessageType(
  "anduril.type.RigidTransform",
  () => [
    { no: 3, name: "rotation", kind: "message", T: Quaternion },
    { no: 4, name: "translation", kind: "message", T: Vec3 },
  ],
);

