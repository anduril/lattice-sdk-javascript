// @generated by protoc-gen-es v1.7.2 with parameter "js_import_style=legacy_commonjs"
// @generated from file anduril/type/coords.pub.proto (package anduril.type, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Spherical angular coordinates
 *
 * @generated from message anduril.type.ThetaPhi
 */
export declare class ThetaPhi extends Message<ThetaPhi> {
  /**
   * Angle clockwise relative to forward in degrees (Azimuth).
   *
   * @generated from field: double theta = 1;
   */
  theta: number;

  /**
   * Angle upward relative to forward in degrees (Elevation).
   *
   * @generated from field: double phi = 2;
   */
  phi: number;

  constructor(data?: PartialMessage<ThetaPhi>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.ThetaPhi";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ThetaPhi;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ThetaPhi;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ThetaPhi;

  static equals(a: ThetaPhi | PlainMessage<ThetaPhi> | undefined, b: ThetaPhi | PlainMessage<ThetaPhi> | undefined): boolean;
}

/**
 * @generated from message anduril.type.LLA
 */
export declare class LLA extends Message<LLA> {
  /**
   * WGS84 longitude in decimal degrees
   *
   * @generated from field: double lon = 1;
   */
  lon: number;

  /**
   * WGS84 geodetic latitude in decimal degrees
   *
   * @generated from field: double lat = 2;
   */
  lat: number;

  /**
   * altitude in meters above either WGS84 or EGM96 (see altitude_reference)
   *
   * @generated from field: double alt = 3;
   */
  alt: number;

  /**
   * [default=false] indicates that altitude is either unset or so uncertain that it is meaningless
   *
   * @generated from field: bool is2d = 4;
   */
  is2d: boolean;

  /**
   * Meaning of alt.
   * altitude in meters above either WGS84 or EGM96, use altitude_reference to
   * determine what zero means.
   *
   * @generated from field: anduril.type.LLA.AltitudeReference altitude_reference = 5;
   */
  altitudeReference: LLA_AltitudeReference;

  constructor(data?: PartialMessage<LLA>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.LLA";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LLA;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LLA;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LLA;

  static equals(a: LLA | PlainMessage<LLA> | undefined, b: LLA | PlainMessage<LLA> | undefined): boolean;
}

/**
 * What altitude of zero refers to.
 *
 * @generated from enum anduril.type.LLA.AltitudeReference
 */
export declare enum LLA_AltitudeReference {
  /**
   * Depending on the context its possible INVALID just means that it is
   * clear from the context (e.g. this is LLA is named lla_hae).
   * This also might mean AGL which would depend on what height map you are
   * using.
   *
   * @generated from enum value: ALTITUDE_REFERENCE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * commonly called height above ellipsoid (HAE)
   *
   * @generated from enum value: ALTITUDE_REFERENCE_HEIGHT_ABOVE_WGS84 = 1;
   */
  HEIGHT_ABOVE_WGS84 = 1,

  /**
   * commonly called mean sea level (MSL)
   *
   * @generated from enum value: ALTITUDE_REFERENCE_HEIGHT_ABOVE_EGM96 = 2;
   */
  HEIGHT_ABOVE_EGM96 = 2,

  /**
   * Publishing an altitude with an unkown reference
   *
   * @generated from enum value: ALTITUDE_REFERENCE_UNKNOWN = 3;
   */
  UNKNOWN = 3,

  /**
   * ADSB sometimes published barometrically-measured alt
   *
   * @generated from enum value: ALTITUDE_REFERENCE_BAROMETRIC = 4;
   */
  BAROMETRIC = 4,

  /**
   * Positive distance above sea floor (ASF) at a specific lat/lon
   *
   * @generated from enum value: ALTITUDE_REFERENCE_ABOVE_SEA_FLOOR = 5;
   */
  ABOVE_SEA_FLOOR = 5,

  /**
   * Positive distance below surface at a specific lat/lon
   *
   * @generated from enum value: ALTITUDE_REFERENCE_BELOW_SEA_SURFACE = 6;
   */
  BELOW_SEA_SURFACE = 6,
}

/**
 * @generated from message anduril.type.ENU
 */
export declare class ENU extends Message<ENU> {
  /**
   * @generated from field: double e = 1;
   */
  e: number;

  /**
   * @generated from field: double n = 2;
   */
  n: number;

  /**
   * @generated from field: double u = 3;
   */
  u: number;

  constructor(data?: PartialMessage<ENU>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.ENU";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ENU;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ENU;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ENU;

  static equals(a: ENU | PlainMessage<ENU> | undefined, b: ENU | PlainMessage<ENU> | undefined): boolean;
}

/**
 * Holds ECI (Earth-Centered Inertial, https://en.wikipedia.org/wiki/Earth-centered_inertial)
 * coordinates.
 *
 * @generated from message anduril.type.ECI
 */
export declare class ECI extends Message<ECI> {
  /**
   * Holds the x-coordinate of ECI.
   *
   * @generated from field: double x = 1;
   */
  x: number;

  /**
   * Holds the y-coordinate of ECI.
   *
   * @generated from field: double y = 2;
   */
  y: number;

  /**
   * Holds the z-coordinate of ECI.
   *
   * @generated from field: double z = 3;
   */
  z: number;

  constructor(data?: PartialMessage<ECI>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.ECI";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ECI;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ECI;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ECI;

  static equals(a: ECI | PlainMessage<ECI> | undefined, b: ECI | PlainMessage<ECI> | undefined): boolean;
}

/**
 * @generated from message anduril.type.Vec2
 */
export declare class Vec2 extends Message<Vec2> {
  /**
   * @generated from field: double x = 1;
   */
  x: number;

  /**
   * @generated from field: double y = 2;
   */
  y: number;

  constructor(data?: PartialMessage<Vec2>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.Vec2";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vec2;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vec2;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vec2;

  static equals(a: Vec2 | PlainMessage<Vec2> | undefined, b: Vec2 | PlainMessage<Vec2> | undefined): boolean;
}

/**
 * @generated from message anduril.type.Vec2f
 */
export declare class Vec2f extends Message<Vec2f> {
  /**
   * @generated from field: float x = 1;
   */
  x: number;

  /**
   * @generated from field: float y = 2;
   */
  y: number;

  constructor(data?: PartialMessage<Vec2f>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.Vec2f";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vec2f;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vec2f;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vec2f;

  static equals(a: Vec2f | PlainMessage<Vec2f> | undefined, b: Vec2f | PlainMessage<Vec2f> | undefined): boolean;
}

/**
 * @generated from message anduril.type.Vec3
 */
export declare class Vec3 extends Message<Vec3> {
  /**
   * @generated from field: double x = 1;
   */
  x: number;

  /**
   * @generated from field: double y = 2;
   */
  y: number;

  /**
   * @generated from field: double z = 3;
   */
  z: number;

  constructor(data?: PartialMessage<Vec3>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.Vec3";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vec3;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vec3;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vec3;

  static equals(a: Vec3 | PlainMessage<Vec3> | undefined, b: Vec3 | PlainMessage<Vec3> | undefined): boolean;
}

/**
 * @generated from message anduril.type.Vec3f
 */
export declare class Vec3f extends Message<Vec3f> {
  /**
   * @generated from field: float x = 1;
   */
  x: number;

  /**
   * @generated from field: float y = 2;
   */
  y: number;

  /**
   * @generated from field: float z = 3;
   */
  z: number;

  constructor(data?: PartialMessage<Vec3f>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.Vec3f";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vec3f;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vec3f;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vec3f;

  static equals(a: Vec3f | PlainMessage<Vec3f> | undefined, b: Vec3f | PlainMessage<Vec3f> | undefined): boolean;
}

/**
 * @generated from message anduril.type.Quaternion
 */
export declare class Quaternion extends Message<Quaternion> {
  /**
   * x, y, z are vector portion, w is scalar
   *
   * @generated from field: double x = 1;
   */
  x: number;

  /**
   * @generated from field: double y = 2;
   */
  y: number;

  /**
   * @generated from field: double z = 3;
   */
  z: number;

  /**
   * @generated from field: double w = 4;
   */
  w: number;

  constructor(data?: PartialMessage<Quaternion>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.Quaternion";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Quaternion;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Quaternion;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Quaternion;

  static equals(a: Quaternion | PlainMessage<Quaternion> | undefined, b: Quaternion | PlainMessage<Quaternion> | undefined): boolean;
}

/**
 * Yaw-Pitch in radians
 *
 * @generated from message anduril.type.YawPitch
 */
export declare class YawPitch extends Message<YawPitch> {
  /**
   * @generated from field: double yaw = 1;
   */
  yaw: number;

  /**
   * @generated from field: double pitch = 2;
   */
  pitch: number;

  constructor(data?: PartialMessage<YawPitch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.YawPitch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): YawPitch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): YawPitch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): YawPitch;

  static equals(a: YawPitch | PlainMessage<YawPitch> | undefined, b: YawPitch | PlainMessage<YawPitch> | undefined): boolean;
}

/**
 * Yaw-Pitch-Roll in degrees.
 *
 * @generated from message anduril.type.YPR
 */
export declare class YPR extends Message<YPR> {
  /**
   * @generated from field: double yaw = 1;
   */
  yaw: number;

  /**
   * @generated from field: double pitch = 2;
   */
  pitch: number;

  /**
   * @generated from field: double roll = 3;
   */
  roll: number;

  constructor(data?: PartialMessage<YPR>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.YPR";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): YPR;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): YPR;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): YPR;

  static equals(a: YPR | PlainMessage<YPR> | undefined, b: YPR | PlainMessage<YPR> | undefined): boolean;
}

/**
 * @generated from message anduril.type.Pose
 */
export declare class Pose extends Message<Pose> {
  /**
   * Geospatial location defined by this Pose.
   *
   * @generated from field: anduril.type.LLA pos = 1;
   */
  pos?: LLA;

  /**
   * The quaternion to transform a point in the Pose frame to the ENU frame. The Pose frame could be Body, Turret,
   * etc and is determined by the context in which this Pose is used.
   * The normal convention for defining orientation is to list the frames of transformation, for example
   * att_gimbal_to_enu is the quaternion which transforms a point in the gimbal frame to the body frame, but
   * in this case we truncate to att_enu because the Pose frame isn't defined. A potentially better name for this
   * field would have been att_pose_to_enu.
   *
   * Implementations of this quaternion should left multiply this quaternion to transform a point from the Pose frame
   * to the enu frame. Following the geometry-cpp rotation convention, the following example would be valid:
   * (https://ghe.anduril.dev/autonomy/geometry-cpp/blob/master/src/Rotation.h#L90)
   *
   * Point<Pose\> posePt{1,0,0};
   * Rotation<Enu, Pose\> attPoseToEnu{};
   * Point<Enu\> = attPoseToEnu*posePt;
   *
   * This transformed point represents some vector in ENU space that is aligned with the x axis of the attPoseToEnu
   * matrix.
   *
   * An alternative matrix expression is as follows:
   * ptEnu = M x ptPose
   *
   * @generated from field: anduril.type.Quaternion att_enu = 2;
   */
  attEnu?: Quaternion;

  constructor(data?: PartialMessage<Pose>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.Pose";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pose;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pose;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pose;

  static equals(a: Pose | PlainMessage<Pose> | undefined, b: Pose | PlainMessage<Pose> | undefined): boolean;
}

/**
 * @generated from message anduril.type.LLAPolygon
 */
export declare class LLAPolygon extends Message<LLAPolygon> {
  /**
   * standard is that points are defined in a counter-clockwise order. this
   * is only the exterior ring of a polygon, no holes are supported.
   *
   * @generated from field: repeated anduril.type.LLA points = 1;
   */
  points: LLA[];

  constructor(data?: PartialMessage<LLAPolygon>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.LLAPolygon";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LLAPolygon;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LLAPolygon;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LLAPolygon;

  static equals(a: LLAPolygon | PlainMessage<LLAPolygon> | undefined, b: LLAPolygon | PlainMessage<LLAPolygon> | undefined): boolean;
}

/**
 * @generated from message anduril.type.AERPolygon
 */
export declare class AERPolygon extends Message<AERPolygon> {
  /**
   * Azimuth-Range-Elevation
   *
   * @generated from field: repeated anduril.type.Spherical points = 1;
   */
  points: Spherical[];

  constructor(data?: PartialMessage<AERPolygon>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.AERPolygon";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AERPolygon;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AERPolygon;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AERPolygon;

  static equals(a: AERPolygon | PlainMessage<AERPolygon> | undefined, b: AERPolygon | PlainMessage<AERPolygon> | undefined): boolean;
}

/**
 * @generated from message anduril.type.LLAPath
 */
export declare class LLAPath extends Message<LLAPath> {
  /**
   * Ordered list of points on the path.
   *
   * @generated from field: repeated anduril.type.LLA points = 1;
   */
  points: LLA[];

  /**
   * True if the last point on the path connects to the first in a closed
   * loop
   *
   * @generated from field: bool loop = 2;
   */
  loop: boolean;

  constructor(data?: PartialMessage<LLAPath>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.LLAPath";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LLAPath;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LLAPath;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LLAPath;

  static equals(a: LLAPath | PlainMessage<LLAPath> | undefined, b: LLAPath | PlainMessage<LLAPath> | undefined): boolean;
}

/**
 * @generated from message anduril.type.Spherical
 */
export declare class Spherical extends Message<Spherical> {
  /**
   * azimuth angle in radians
   *
   * @generated from field: double az = 1;
   */
  az: number;

  /**
   * elevation angle in radians, we'll use 0 = XY plane
   *
   * @generated from field: double el = 2;
   */
  el: number;

  /**
   * range in meters
   *
   * @generated from field: double range = 3;
   */
  range: number;

  constructor(data?: PartialMessage<Spherical>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.Spherical";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Spherical;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Spherical;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Spherical;

  static equals(a: Spherical | PlainMessage<Spherical> | undefined, b: Spherical | PlainMessage<Spherical> | undefined): boolean;
}

/**
 * @generated from message anduril.type.DoubleRange
 */
export declare class DoubleRange extends Message<DoubleRange> {
  /**
   * @generated from field: double min = 1;
   */
  min: number;

  /**
   * @generated from field: double max = 2;
   */
  max: number;

  constructor(data?: PartialMessage<DoubleRange>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.DoubleRange";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DoubleRange;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DoubleRange;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DoubleRange;

  static equals(a: DoubleRange | PlainMessage<DoubleRange> | undefined, b: DoubleRange | PlainMessage<DoubleRange> | undefined): boolean;
}

/**
 * @generated from message anduril.type.Uint64Range
 */
export declare class Uint64Range extends Message<Uint64Range> {
  /**
   * @generated from field: uint64 min = 1;
   */
  min: bigint;

  /**
   * @generated from field: uint64 max = 2;
   */
  max: bigint;

  constructor(data?: PartialMessage<Uint64Range>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.Uint64Range";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Uint64Range;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Uint64Range;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Uint64Range;

  static equals(a: Uint64Range | PlainMessage<Uint64Range> | undefined, b: Uint64Range | PlainMessage<Uint64Range> | undefined): boolean;
}

/**
 * A symmetric 4D matrix only representing the upper right triangle, useful for covariance matrices.
 *
 * @generated from message anduril.type.TMat4f
 */
export declare class TMat4f extends Message<TMat4f> {
  /**
   * @generated from field: float m00 = 1;
   */
  m00: number;

  /**
   * @generated from field: float m01 = 2;
   */
  m01: number;

  /**
   * @generated from field: float m02 = 3;
   */
  m02: number;

  /**
   * @generated from field: float m03 = 4;
   */
  m03: number;

  /**
   * @generated from field: float m11 = 5;
   */
  m11: number;

  /**
   * @generated from field: float m12 = 6;
   */
  m12: number;

  /**
   * @generated from field: float m13 = 7;
   */
  m13: number;

  /**
   * @generated from field: float m22 = 8;
   */
  m22: number;

  /**
   * @generated from field: float m23 = 9;
   */
  m23: number;

  /**
   * @generated from field: float m33 = 10;
   */
  m33: number;

  constructor(data?: PartialMessage<TMat4f>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.TMat4f";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TMat4f;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TMat4f;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TMat4f;

  static equals(a: TMat4f | PlainMessage<TMat4f> | undefined, b: TMat4f | PlainMessage<TMat4f> | undefined): boolean;
}

/**
 * A symmetric 3D matrix only representing the upper right triangle, useful for covariance matrices.
 *
 * @generated from message anduril.type.TMat3
 */
export declare class TMat3 extends Message<TMat3> {
  /**
   * @generated from field: double mxx = 1;
   */
  mxx: number;

  /**
   * @generated from field: double mxy = 2;
   */
  mxy: number;

  /**
   * @generated from field: double mxz = 3;
   */
  mxz: number;

  /**
   * @generated from field: double myy = 4;
   */
  myy: number;

  /**
   * @generated from field: double myz = 5;
   */
  myz: number;

  /**
   * @generated from field: double mzz = 6;
   */
  mzz: number;

  constructor(data?: PartialMessage<TMat3>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.TMat3";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TMat3;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TMat3;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TMat3;

  static equals(a: TMat3 | PlainMessage<TMat3> | undefined, b: TMat3 | PlainMessage<TMat3> | undefined): boolean;
}

/**
 * symmetric 2d matrix only representing the upper right triangle, useful for
 * covariance matrices
 *
 * @generated from message anduril.type.TMat2
 */
export declare class TMat2 extends Message<TMat2> {
  /**
   * @generated from field: double mxx = 1;
   */
  mxx: number;

  /**
   * @generated from field: double mxy = 2;
   */
  mxy: number;

  /**
   * @generated from field: double myy = 3;
   */
  myy: number;

  constructor(data?: PartialMessage<TMat2>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.TMat2";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TMat2;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TMat2;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TMat2;

  static equals(a: TMat2 | PlainMessage<TMat2> | undefined, b: TMat2 | PlainMessage<TMat2> | undefined): boolean;
}

/**
 * Rx + t, Technically this is a duplicate of AffineTransform
 * but Affine Transform isn't really an affine transform (since it doesn't allow
 * skewing and stretching).
 *
 * @generated from message anduril.type.RigidTransform
 */
export declare class RigidTransform extends Message<RigidTransform> {
  /**
   * @generated from field: anduril.type.Quaternion rotation = 3;
   */
  rotation?: Quaternion;

  /**
   * @generated from field: anduril.type.Vec3 translation = 4;
   */
  translation?: Vec3;

  constructor(data?: PartialMessage<RigidTransform>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.type.RigidTransform";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RigidTransform;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RigidTransform;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RigidTransform;

  static equals(a: RigidTransform | PlainMessage<RigidTransform> | undefined, b: RigidTransform | PlainMessage<RigidTransform> | undefined): boolean;
}

