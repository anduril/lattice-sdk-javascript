// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/taskmanager/v1/task_manager_api.pub.proto (package anduril.taskmanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Any, Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Principal, Relations, StatusUpdate, Task, TaskEntity, TaskEvent, TaskView } from "./task.pub_pb.js";

/**
 * Request to create a Task.
 *
 * @generated from message anduril.taskmanager.v1.CreateTaskRequest
 */
export class CreateTaskRequest extends Message<CreateTaskRequest> {
  /**
   * Human readable display name for this Task, should be short (<100 chars).
   *
   * @generated from field: string display_name = 1;
   */
  displayName = "";

  /**
   * Full task parameterization, must be a message under anduril/tasks/v*\/.
   *
   * @generated from field: google.protobuf.Any specification = 2;
   */
  specification?: Any;

  /**
   * Who or what is creating this Task. For example, if a user created this Task via a UI, it would
   *  contain the "user" Principal type with the user ID of that user. Or if a service is calling the
   *  CreateTask endpoint, then a "service" Principal type is to be provided.
   *
   * @generated from field: anduril.taskmanager.v1.Principal author = 3;
   */
  author?: Principal;

  /**
   * Any relationships associated with this Task, such as a parent Task or an assignee this Task is designated to
   *  for execution.
   *
   * @generated from field: anduril.taskmanager.v1.Relations relations = 5;
   */
  relations?: Relations;

  /**
   * Longer, free form human readable description of this Task.
   *
   * @generated from field: string description = 6;
   */
  description = "";

  /**
   * If set, then task-manager will not trigger execution of this task on an agent. Useful for when ingesting
   * tasks from an external system that is triggering execution of tasks on agents.
   *
   * @generated from field: bool is_executed_elsewhere = 7;
   */
  isExecutedElsewhere = false;

  /**
   * If non-empty, will set the requested Task ID, otherwise will generate a new random GUID.
   *  Will reject if supplied Task ID does not match `[A-Za-z0-9_-.]{5,36}`.
   *
   * @generated from field: string task_id = 8;
   */
  taskId = "";

  /**
   * Indicates an initial set of entities that can be used to execute an entity aware task.
   * For example, an entity Objective, an entity Keep In Zone, etc.
   *
   * @generated from field: repeated anduril.taskmanager.v1.TaskEntity initial_entities = 9;
   */
  initialEntities: TaskEntity[] = [];

  constructor(data?: PartialMessage<CreateTaskRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.CreateTaskRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "specification", kind: "message", T: Any },
    { no: 3, name: "author", kind: "message", T: Principal },
    { no: 5, name: "relations", kind: "message", T: Relations },
    { no: 6, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "is_executed_elsewhere", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "task_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "initial_entities", kind: "message", T: TaskEntity, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateTaskRequest {
    return new CreateTaskRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateTaskRequest {
    return new CreateTaskRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateTaskRequest {
    return new CreateTaskRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateTaskRequest | PlainMessage<CreateTaskRequest> | undefined, b: CreateTaskRequest | PlainMessage<CreateTaskRequest> | undefined): boolean {
    return proto3.util.equals(CreateTaskRequest, a, b);
  }
}

/**
 * Response to a Create Task request.
 *
 * @generated from message anduril.taskmanager.v1.CreateTaskResponse
 */
export class CreateTaskResponse extends Message<CreateTaskResponse> {
  /**
   * Task that was created.
   *
   * @generated from field: anduril.taskmanager.v1.Task task = 1;
   */
  task?: Task;

  constructor(data?: PartialMessage<CreateTaskResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.CreateTaskResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task", kind: "message", T: Task },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateTaskResponse {
    return new CreateTaskResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateTaskResponse {
    return new CreateTaskResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateTaskResponse {
    return new CreateTaskResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateTaskResponse | PlainMessage<CreateTaskResponse> | undefined, b: CreateTaskResponse | PlainMessage<CreateTaskResponse> | undefined): boolean {
    return proto3.util.equals(CreateTaskResponse, a, b);
  }
}

/**
 * Request to get a Task.
 *
 * @generated from message anduril.taskmanager.v1.GetTaskRequest
 */
export class GetTaskRequest extends Message<GetTaskRequest> {
  /**
   * ID of Task to get.
   *
   * @generated from field: string task_id = 1;
   */
  taskId = "";

  /**
   * Optional - if > 0, will get specific definition_version, otherwise latest (highest) definition_version is used.
   *
   * @generated from field: uint32 definition_version = 2;
   */
  definitionVersion = 0;

  /**
   * Optional - select which view of the task to fetch. If not set, defaults to TASK_VIEW_MANAGER.
   *
   * @generated from field: anduril.taskmanager.v1.TaskView task_view = 3;
   */
  taskView = TaskView.INVALID;

  constructor(data?: PartialMessage<GetTaskRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.GetTaskRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "definition_version", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "task_view", kind: "enum", T: proto3.getEnumType(TaskView) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTaskRequest {
    return new GetTaskRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTaskRequest {
    return new GetTaskRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTaskRequest {
    return new GetTaskRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetTaskRequest | PlainMessage<GetTaskRequest> | undefined, b: GetTaskRequest | PlainMessage<GetTaskRequest> | undefined): boolean {
    return proto3.util.equals(GetTaskRequest, a, b);
  }
}

/**
 * Response to a Get Task request.
 *
 * @generated from message anduril.taskmanager.v1.GetTaskResponse
 */
export class GetTaskResponse extends Message<GetTaskResponse> {
  /**
   * Task that received.
   *
   * @generated from field: anduril.taskmanager.v1.Task task = 1;
   */
  task?: Task;

  constructor(data?: PartialMessage<GetTaskResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.GetTaskResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task", kind: "message", T: Task },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTaskResponse {
    return new GetTaskResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTaskResponse {
    return new GetTaskResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTaskResponse {
    return new GetTaskResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetTaskResponse | PlainMessage<GetTaskResponse> | undefined, b: GetTaskResponse | PlainMessage<GetTaskResponse> | undefined): boolean {
    return proto3.util.equals(GetTaskResponse, a, b);
  }
}

/**
 * Request to update a Task.
 *
 * @generated from message anduril.taskmanager.v1.UpdateTaskRequest
 */
export class UpdateTaskRequest extends Message<UpdateTaskRequest> {
  /**
   * New Task definition.
   *
   * @generated from field: anduril.taskmanager.v1.Task task = 1;
   */
  task?: Task;

  /**
   * If set, execution of this Task is managed elsewhere, not by task-manager.
   * In other words, Task Manager will not attempt to update the assigned agent with execution instructions.
   * We note that this will also override the existing is_executed_elsewhere value in the Task
   * object provided in this request.
   *
   * @generated from field: bool is_executed_elsewhere = 7;
   */
  isExecutedElsewhere = false;

  constructor(data?: PartialMessage<UpdateTaskRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.UpdateTaskRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task", kind: "message", T: Task },
    { no: 7, name: "is_executed_elsewhere", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateTaskRequest {
    return new UpdateTaskRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateTaskRequest {
    return new UpdateTaskRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateTaskRequest {
    return new UpdateTaskRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateTaskRequest | PlainMessage<UpdateTaskRequest> | undefined, b: UpdateTaskRequest | PlainMessage<UpdateTaskRequest> | undefined): boolean {
    return proto3.util.equals(UpdateTaskRequest, a, b);
  }
}

/**
 * Response to an Update Task request.
 *
 * @generated from message anduril.taskmanager.v1.UpdateTaskResponse
 */
export class UpdateTaskResponse extends Message<UpdateTaskResponse> {
  /**
   * the updated task
   *
   * @generated from field: anduril.taskmanager.v1.Task task = 1;
   */
  task?: Task;

  constructor(data?: PartialMessage<UpdateTaskResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.UpdateTaskResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task", kind: "message", T: Task },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateTaskResponse {
    return new UpdateTaskResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateTaskResponse {
    return new UpdateTaskResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateTaskResponse {
    return new UpdateTaskResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateTaskResponse | PlainMessage<UpdateTaskResponse> | undefined, b: UpdateTaskResponse | PlainMessage<UpdateTaskResponse> | undefined): boolean {
    return proto3.util.equals(UpdateTaskResponse, a, b);
  }
}

/**
 * Request to update a Task's status.
 *
 * @generated from message anduril.taskmanager.v1.UpdateStatusRequest
 */
export class UpdateStatusRequest extends Message<UpdateStatusRequest> {
  /**
   * The updated status.
   *
   * @generated from field: anduril.taskmanager.v1.StatusUpdate status_update = 1;
   */
  statusUpdate?: StatusUpdate;

  constructor(data?: PartialMessage<UpdateStatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.UpdateStatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status_update", kind: "message", T: StatusUpdate },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateStatusRequest {
    return new UpdateStatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateStatusRequest {
    return new UpdateStatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateStatusRequest {
    return new UpdateStatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateStatusRequest | PlainMessage<UpdateStatusRequest> | undefined, b: UpdateStatusRequest | PlainMessage<UpdateStatusRequest> | undefined): boolean {
    return proto3.util.equals(UpdateStatusRequest, a, b);
  }
}

/**
 * Response to an Update Status request.
 *
 * @generated from message anduril.taskmanager.v1.UpdateStatusResponse
 */
export class UpdateStatusResponse extends Message<UpdateStatusResponse> {
  /**
   * The updated Task.
   *
   * @generated from field: anduril.taskmanager.v1.Task task = 1;
   */
  task?: Task;

  constructor(data?: PartialMessage<UpdateStatusResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.UpdateStatusResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task", kind: "message", T: Task },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateStatusResponse {
    return new UpdateStatusResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateStatusResponse {
    return new UpdateStatusResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateStatusResponse {
    return new UpdateStatusResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateStatusResponse | PlainMessage<UpdateStatusResponse> | undefined, b: UpdateStatusResponse | PlainMessage<UpdateStatusResponse> | undefined): boolean {
    return proto3.util.equals(UpdateStatusResponse, a, b);
  }
}

/**
 * Request to Stream Tasks. Returns all live Tasks (aka all not-DONE Tasks).
 *
 * @generated from message anduril.taskmanager.v1.StreamTasksRequest
 */
export class StreamTasksRequest extends Message<StreamTasksRequest> {
  /**
   * Optional rate limiting on StreamTasksResponses.
   *
   * @generated from field: anduril.taskmanager.v1.RateLimit rate_limit = 1;
   */
  rateLimit?: RateLimit;

  /**
   * Optional additional views of a Task.
   * If not set, defaults to TASK_VIEW_MANAGER.
   *
   * @generated from field: repeated anduril.taskmanager.v1.TaskView views = 2;
   */
  views: TaskView[] = [];

  /**
   * Optional period (in milliseconds) at which a Heartbeat message will be sent on the
   * message stream. If this field is unset then no Heartbeat messages are sent.
   *
   * @generated from field: uint32 heartbeat_period_millis = 3;
   */
  heartbeatPeriodMillis = 0;

  constructor(data?: PartialMessage<StreamTasksRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.StreamTasksRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rate_limit", kind: "message", T: RateLimit },
    { no: 2, name: "views", kind: "enum", T: proto3.getEnumType(TaskView), repeated: true },
    { no: 3, name: "heartbeat_period_millis", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamTasksRequest {
    return new StreamTasksRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamTasksRequest {
    return new StreamTasksRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamTasksRequest {
    return new StreamTasksRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamTasksRequest | PlainMessage<StreamTasksRequest> | undefined, b: StreamTasksRequest | PlainMessage<StreamTasksRequest> | undefined): boolean {
    return proto3.util.equals(StreamTasksRequest, a, b);
  }
}

/**
 * Response stream will be fed all matching pre-existing live Tasks, plus any new events ongoing.
 *
 * @generated from message anduril.taskmanager.v1.StreamTasksResponse
 */
export class StreamTasksResponse extends Message<StreamTasksResponse> {
  /**
   * Task event associated with the streaming request.
   *
   * @generated from field: anduril.taskmanager.v1.TaskEvent task_event = 1;
   */
  taskEvent?: TaskEvent;

  /**
   * Heartbeat message signaling liveliness of the stream.
   *
   * @generated from field: anduril.taskmanager.v1.Heartbeat heartbeat = 2;
   */
  heartbeat?: Heartbeat;

  constructor(data?: PartialMessage<StreamTasksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.StreamTasksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_event", kind: "message", T: TaskEvent },
    { no: 2, name: "heartbeat", kind: "message", T: Heartbeat },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamTasksResponse {
    return new StreamTasksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamTasksResponse {
    return new StreamTasksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamTasksResponse {
    return new StreamTasksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamTasksResponse | PlainMessage<StreamTasksResponse> | undefined, b: StreamTasksResponse | PlainMessage<StreamTasksResponse> | undefined): boolean {
    return proto3.util.equals(StreamTasksResponse, a, b);
  }
}

/**
 * Rate limiting / down-sampling parameters.
 *
 * @generated from message anduril.taskmanager.v1.RateLimit
 */
export class RateLimit extends Message<RateLimit> {
  /**
   * Specifies a minimum duration in milliseconds after an update for a given task before another one
   * will be sent for the same task.
   * A value of 0 is treated as unset. If set, value must be >= 250.
   * Example: if set to 1000, and 4 events occur (ms since start) at T0, T500, T900, T2100, then
   * event from T0 will be sent at T0, T500 will be dropped, T900 will be sent at minimum of T1000,
   * and T2100 will be sent on time (2100)
   * This will only limit updates, other events will be sent immediately, with a delete clearing anything held
   *
   * @generated from field: uint32 update_per_task_limit_ms = 1;
   */
  updatePerTaskLimitMs = 0;

  constructor(data?: PartialMessage<RateLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.RateLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "update_per_task_limit_ms", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimit {
    return new RateLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimit {
    return new RateLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimit {
    return new RateLimit().fromJsonString(jsonString, options);
  }

  static equals(a: RateLimit | PlainMessage<RateLimit> | undefined, b: RateLimit | PlainMessage<RateLimit> | undefined): boolean {
    return proto3.util.equals(RateLimit, a, b);
  }
}

/**
 * @generated from message anduril.taskmanager.v1.Heartbeat
 */
export class Heartbeat extends Message<Heartbeat> {
  /**
   * The time at which the Heartbeat was sent.
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<Heartbeat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.Heartbeat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Heartbeat {
    return new Heartbeat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Heartbeat {
    return new Heartbeat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Heartbeat {
    return new Heartbeat().fromJsonString(jsonString, options);
  }

  static equals(a: Heartbeat | PlainMessage<Heartbeat> | undefined, b: Heartbeat | PlainMessage<Heartbeat> | undefined): boolean {
    return proto3.util.equals(Heartbeat, a, b);
  }
}

