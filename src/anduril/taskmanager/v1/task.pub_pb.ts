// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/taskmanager/v1/task.pub.proto (package anduril.taskmanager.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Any, Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Entity } from "../../entitymanager/v1/entity.pub_pb.js";

/**
 * The Status of a Task definition through its lifecycle. Each Definition Version can have its own Status.
 * For example, Definition v1 could go CREATED -> SENT -> WILCO -> REPLACED, with v2 then potentially in sent Status.
 *
 * @generated from enum anduril.taskmanager.v1.Status
 */
export enum Status {
  /**
   * @generated from enum value: STATUS_INVALID = 0;
   */
  INVALID = 0,

  /**
   * Initial creation Status.
   *
   * @generated from enum value: STATUS_CREATED = 1;
   */
  CREATED = 1,

  /**
   * Scheduled within Task Manager to be sent at a future time.
   *
   * @generated from enum value: STATUS_SCHEDULED_IN_MANAGER = 2;
   */
  SCHEDULED_IN_MANAGER = 2,

  /**
   * Sent to another system (Asset), no receipt yet.
   *
   * @generated from enum value: STATUS_SENT = 3;
   */
  SENT = 3,

  /**
   * In case of a human operated asset assignee, the machine was reachable and responded, but operator did not ACK yet.
   *
   * @generated from enum value: STATUS_MACHINE_RECEIPT = 4;
   */
  MACHINE_RECEIPT = 4,

  /**
   * Assignee (either human or system in case of autonomous robot) has acknowledged receipt of Task.
   *
   * @generated from enum value: STATUS_ACK = 5;
   */
  ACK = 5,

  /**
   * Assignee confirmed they "will comply" / intend to execute Task.
   *
   * @generated from enum value: STATUS_WILCO = 6;
   */
  WILCO = 6,

  /**
   * Task was started and is actively executing.
   *
   * @generated from enum value: STATUS_EXECUTING = 7;
   */
  EXECUTING = 7,

  /**
   * Task is on hold, waiting for additional updates/information before proceeding.
   *
   * @generated from enum value: STATUS_WAITING_FOR_UPDATE = 8;
   */
  WAITING_FOR_UPDATE = 8,

  /**
   * Task was completed successfully.
   *
   * @generated from enum value: STATUS_DONE_OK = 9;
   */
  DONE_OK = 9,

  /**
   * Task has reached a terminal state but did not complete successfully, see error code/message.
   *
   * @generated from enum value: STATUS_DONE_NOT_OK = 10;
   */
  DONE_NOT_OK = 10,

  /**
   * This definition version was replaced.
   *
   * @generated from enum value: STATUS_REPLACED = 11;
   */
  REPLACED = 11,

  /**
   * A Task was requested to be cancelled but not yet confirmed, will eventually move to DONE_NOT_OK.
   *
   * @generated from enum value: STATUS_CANCEL_REQUESTED = 12;
   */
  CANCEL_REQUESTED = 12,

  /**
   * A Task was requested to be completed successfully but not yet confirmed, will eventually move to DONE_NOT_OK / DONE_OK.
   *
   * @generated from enum value: STATUS_COMPLETE_REQUESTED = 13;
   */
  COMPLETE_REQUESTED = 13,

  /**
   * This definition version was rejected, intended to be used when an Agent does not accept a new version of a task
   * and continues using previous version
   *
   * @generated from enum value: STATUS_VERSION_REJECTED = 14;
   */
  VERSION_REJECTED = 14,
}
// Retrieve enum metadata with: proto3.getEnumType(Status)
proto3.util.setEnumType(Status, "anduril.taskmanager.v1.Status", [
  { no: 0, name: "STATUS_INVALID" },
  { no: 1, name: "STATUS_CREATED" },
  { no: 2, name: "STATUS_SCHEDULED_IN_MANAGER" },
  { no: 3, name: "STATUS_SENT" },
  { no: 4, name: "STATUS_MACHINE_RECEIPT" },
  { no: 5, name: "STATUS_ACK" },
  { no: 6, name: "STATUS_WILCO" },
  { no: 7, name: "STATUS_EXECUTING" },
  { no: 8, name: "STATUS_WAITING_FOR_UPDATE" },
  { no: 9, name: "STATUS_DONE_OK" },
  { no: 10, name: "STATUS_DONE_NOT_OK" },
  { no: 11, name: "STATUS_REPLACED" },
  { no: 12, name: "STATUS_CANCEL_REQUESTED" },
  { no: 13, name: "STATUS_COMPLETE_REQUESTED" },
  { no: 14, name: "STATUS_VERSION_REJECTED" },
]);

/**
 * Error code associated with a Task error.
 *
 * @generated from enum anduril.taskmanager.v1.ErrorCode
 */
export enum ErrorCode {
  /**
   * @generated from enum value: ERROR_CODE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * Task was cancelled by requester.
   *
   * @generated from enum value: ERROR_CODE_CANCELLED = 1;
   */
  CANCELLED = 1,

  /**
   * Task was rejected by assignee, see message for details.
   *
   * @generated from enum value: ERROR_CODE_REJECTED = 2;
   */
  REJECTED = 2,

  /**
   * Task Manager gave up waiting for a receipt/ack from assignee.
   *
   * @generated from enum value: ERROR_CODE_TIMEOUT = 3;
   */
  TIMEOUT = 3,

  /**
   * Task attempted to execute, but failed.
   *
   * @generated from enum value: ERROR_CODE_FAILED = 4;
   */
  FAILED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ErrorCode)
proto3.util.setEnumType(ErrorCode, "anduril.taskmanager.v1.ErrorCode", [
  { no: 0, name: "ERROR_CODE_INVALID" },
  { no: 1, name: "ERROR_CODE_CANCELLED" },
  { no: 2, name: "ERROR_CODE_REJECTED" },
  { no: 3, name: "ERROR_CODE_TIMEOUT" },
  { no: 4, name: "ERROR_CODE_FAILED" },
]);

/**
 * The type of Task event.
 *
 * @generated from enum anduril.taskmanager.v1.EventType
 */
export enum EventType {
  /**
   * @generated from enum value: EVENT_TYPE_INVALID = 0;
   */
  INVALID = 0,

  /**
   * Task was created.
   *
   * @generated from enum value: EVENT_TYPE_CREATED = 1;
   */
  CREATED = 1,

  /**
   * Task was updated.
   *
   * @generated from enum value: EVENT_TYPE_UPDATE = 2;
   */
  UPDATE = 2,

  /**
   * Task already existed, but sent on a new stream connection.
   *
   * @generated from enum value: EVENT_TYPE_PREEXISTING = 3;
   */
  PREEXISTING = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(EventType)
proto3.util.setEnumType(EventType, "anduril.taskmanager.v1.EventType", [
  { no: 0, name: "EVENT_TYPE_INVALID" },
  { no: 1, name: "EVENT_TYPE_CREATED" },
  { no: 2, name: "EVENT_TYPE_UPDATE" },
  { no: 3, name: "EVENT_TYPE_PREEXISTING" },
]);

/**
 * View of a Task through its lifecycle.
 * For example, a definition v1 of a task may be running on an agent, indicated by TASK_VIEW_AGENT,
 * while the definition v2 may not have been received yet, indicated by TASK_VIEW_MANAGER.
 *
 * @generated from enum anduril.taskmanager.v1.TaskView
 */
export enum TaskView {
  /**
   * @generated from enum value: TASK_VIEW_INVALID = 0;
   */
  INVALID = 0,

  /**
   * Represents the most recent version of the Task known to Task Manager
   *
   * @generated from enum value: TASK_VIEW_MANAGER = 1;
   */
  MANAGER = 1,

  /**
   * Represents the most recent version of the Task acknowledged or updated by an Agent
   *
   * @generated from enum value: TASK_VIEW_AGENT = 2;
   */
  AGENT = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(TaskView)
proto3.util.setEnumType(TaskView, "anduril.taskmanager.v1.TaskView", [
  { no: 0, name: "TASK_VIEW_INVALID" },
  { no: 1, name: "TASK_VIEW_MANAGER" },
  { no: 2, name: "TASK_VIEW_AGENT" },
]);

/**
 * A Task is something an agent can be asked to do within a battle space, typically against a given objective.
 *
 * @generated from message anduril.taskmanager.v1.Task
 */
export class Task extends Message<Task> {
  /**
   * Version of this Task.
   *
   * @generated from field: anduril.taskmanager.v1.TaskVersion version = 1;
   */
  version?: TaskVersion;

  /**
   * Human readable display name for this Task, should be short (<100 chars).
   *
   * @generated from field: string display_name = 2;
   */
  displayName = "";

  /**
   * Full Task parameterization, must be a message under anduril/tasks/v*\/
   *
   * @generated from field: google.protobuf.Any specification = 3;
   */
  specification?: Any;

  /**
   * Records who created this Task. This field will not change after the Task has been created.
   *
   * @generated from field: anduril.taskmanager.v1.Principal created_by = 16;
   */
  createdBy?: Principal;

  /**
   * Records who updated this Task last.
   *
   * @generated from field: anduril.taskmanager.v1.Principal last_updated_by = 4;
   */
  lastUpdatedBy?: Principal;

  /**
   * Records the time of last update.
   *
   * @generated from field: google.protobuf.Timestamp last_update_time = 9;
   */
  lastUpdateTime?: Timestamp;

  /**
   * The status of this Task.
   *
   * @generated from field: anduril.taskmanager.v1.TaskStatus status = 5;
   */
  status?: TaskStatus;

  /**
   * If the Task has been scheduled to execute, what time it should execute at.
   *
   * @generated from field: google.protobuf.Timestamp scheduled_time = 6;
   */
  scheduledTime?: Timestamp;

  /**
   * Any related Tasks associated with this, typically includes an assignee for this Task and/or a parent.
   *
   * @generated from field: anduril.taskmanager.v1.Relations relations = 8;
   */
  relations?: Relations;

  /**
   * Longer, free form human readable description of this Task
   *
   * @generated from field: string description = 10;
   */
  description = "";

  /**
   * If set, execution of this Task is managed elsewhere, not by Task Manager.
   * In other words, Task manager will not attempt to update the assigned agent with execution instructions.
   *
   * @generated from field: bool is_executed_elsewhere = 11;
   */
  isExecutedElsewhere = false;

  /**
   * Time of Task creation.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 13;
   */
  createTime?: Timestamp;

  /**
   * If populated, designates this to be a replicated Task.
   *
   * @generated from field: anduril.taskmanager.v1.Replication replication = 14;
   */
  replication?: Replication;

  /**
   * If populated, indicates an initial set of entities that can be used to execute an entity aware task
   * For example, an entity Objective, an entity Keep In Zone, etc.
   * These will not be updated during execution. If a taskable agent needs continuous updates on the entities from the
   * COP, can call entity-manager, or use an AlternateId escape hatch.
   *
   * @generated from field: repeated anduril.taskmanager.v1.TaskEntity initial_entities = 15;
   */
  initialEntities: TaskEntity[] = [];

  /**
   * The networked owner of this Task. Populated on creation to be the asset on which the Task Manager is running. DO NOT
   * UNDER ANY CIRCUMSTANCES change or modify this field. It is used to ensure that linear writes occur on the node responsible
   * for replication of task data to other nodes running Task Manager.
   *
   * @generated from field: anduril.taskmanager.v1.Owner owner = 12;
   */
  owner?: Owner;

  constructor(data?: PartialMessage<Task>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.Task";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "message", T: TaskVersion },
    { no: 2, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "specification", kind: "message", T: Any },
    { no: 16, name: "created_by", kind: "message", T: Principal },
    { no: 4, name: "last_updated_by", kind: "message", T: Principal },
    { no: 9, name: "last_update_time", kind: "message", T: Timestamp },
    { no: 5, name: "status", kind: "message", T: TaskStatus },
    { no: 6, name: "scheduled_time", kind: "message", T: Timestamp },
    { no: 8, name: "relations", kind: "message", T: Relations },
    { no: 10, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "is_executed_elsewhere", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "create_time", kind: "message", T: Timestamp },
    { no: 14, name: "replication", kind: "message", T: Replication },
    { no: 15, name: "initial_entities", kind: "message", T: TaskEntity, repeated: true },
    { no: 12, name: "owner", kind: "message", T: Owner },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Task {
    return new Task().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Task {
    return new Task().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Task {
    return new Task().fromJsonString(jsonString, options);
  }

  static equals(a: Task | PlainMessage<Task> | undefined, b: Task | PlainMessage<Task> | undefined): boolean {
    return proto3.util.equals(Task, a, b);
  }
}

/**
 * TaskStatus is contains information regarding the status of a Task at any given time. Can include related information
 *  such as any progress towards Task completion, or any associated results if Task completed.
 *
 * @generated from message anduril.taskmanager.v1.TaskStatus
 */
export class TaskStatus extends Message<TaskStatus> {
  /**
   * Status of the Task.
   *
   * @generated from field: anduril.taskmanager.v1.Status status = 1;
   */
  status = Status.INVALID;

  /**
   * Any errors associated with the Task.
   *
   * @generated from field: anduril.taskmanager.v1.TaskError task_error = 2;
   */
  taskError?: TaskError;

  /**
   * Any incremental progress on the Task, should be from the tasks/v*\/progress folder.
   *
   * @generated from field: google.protobuf.Any progress = 4;
   */
  progress?: Any;

  /**
   * Any final result of the Task, should be from tasks/v*\/result folder.
   *
   * @generated from field: google.protobuf.Any result = 5;
   */
  result?: Any;

  /**
   * Time the Task began execution, may not be known even for executing Tasks.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 6;
   */
  startTime?: Timestamp;

  /**
   * Any estimate for how the Task will progress, should be from tasks/v*\/estimates folder.
   *
   * @generated from field: google.protobuf.Any estimate = 7;
   */
  estimate?: Any;

  /**
   * Any allocated agents of the Task.
   *
   * @generated from field: anduril.taskmanager.v1.Allocation allocation = 8;
   */
  allocation?: Allocation;

  constructor(data?: PartialMessage<TaskStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.TaskStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(Status) },
    { no: 2, name: "task_error", kind: "message", T: TaskError },
    { no: 4, name: "progress", kind: "message", T: Any },
    { no: 5, name: "result", kind: "message", T: Any },
    { no: 6, name: "start_time", kind: "message", T: Timestamp },
    { no: 7, name: "estimate", kind: "message", T: Any },
    { no: 8, name: "allocation", kind: "message", T: Allocation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskStatus {
    return new TaskStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskStatus {
    return new TaskStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskStatus {
    return new TaskStatus().fromJsonString(jsonString, options);
  }

  static equals(a: TaskStatus | PlainMessage<TaskStatus> | undefined, b: TaskStatus | PlainMessage<TaskStatus> | undefined): boolean {
    return proto3.util.equals(TaskStatus, a, b);
  }
}

/**
 * TaskError contains an error code and message typically associated to a Task.
 *
 * @generated from message anduril.taskmanager.v1.TaskError
 */
export class TaskError extends Message<TaskError> {
  /**
   * Error code for Task error.
   *
   * @generated from field: anduril.taskmanager.v1.ErrorCode code = 1;
   */
  code = ErrorCode.INVALID;

  /**
   * Descriptive human-readable string regarding this error.
   *
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<TaskError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.TaskError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(ErrorCode) },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskError {
    return new TaskError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskError {
    return new TaskError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskError {
    return new TaskError().fromJsonString(jsonString, options);
  }

  static equals(a: TaskError | PlainMessage<TaskError> | undefined, b: TaskError | PlainMessage<TaskError> | undefined): boolean {
    return proto3.util.equals(TaskError, a, b);
  }
}

/**
 * A Principal is an entity that has authority over this Task.
 *
 * @generated from message anduril.taskmanager.v1.Principal
 */
export class Principal extends Message<Principal> {
  /**
   * A Principal can be either a human user, or a system.
   *
   * @generated from oneof anduril.taskmanager.v1.Principal.agent
   */
  agent: {
    /**
     * @generated from field: anduril.taskmanager.v1.System system = 1;
     */
    value: System;
    case: "system";
  } | {
    /**
     * @generated from field: anduril.taskmanager.v1.User user = 2;
     */
    value: User;
    case: "user";
  } | {
    /**
     * @generated from field: anduril.taskmanager.v1.Team team = 4;
     */
    value: Team;
    case: "team";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The Principal _this_ Principal is acting on behalf of. For example, if there is a Flux node connected to a non-Flux node,
   * and that Flux node wants to act "on behalf of" that non-Flux node, _this_ Principal would represent the Flux node, and
   * this "on_behalf_of" Principal would represent the non-Flux node.
   *
   * Likely only populated once in the nesting (i.e. the "on_behalf_of" Principal would not have another "on_behalf_of" in most cases).
   *
   * @generated from field: anduril.taskmanager.v1.Principal on_behalf_of = 3;
   */
  onBehalfOf?: Principal;

  constructor(data?: PartialMessage<Principal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.Principal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "system", kind: "message", T: System, oneof: "agent" },
    { no: 2, name: "user", kind: "message", T: User, oneof: "agent" },
    { no: 4, name: "team", kind: "message", T: Team, oneof: "agent" },
    { no: 3, name: "on_behalf_of", kind: "message", T: Principal },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Principal {
    return new Principal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Principal {
    return new Principal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Principal {
    return new Principal().fromJsonString(jsonString, options);
  }

  static equals(a: Principal | PlainMessage<Principal> | undefined, b: Principal | PlainMessage<Principal> | undefined): boolean {
    return proto3.util.equals(Principal, a, b);
  }
}

/**
 * System Principal representing some autonomous system.
 *
 * @generated from message anduril.taskmanager.v1.System
 */
export class System extends Message<System> {
  /**
   * Name of the service associated with this System.
   *
   * @generated from field: string service_name = 1;
   */
  serviceName = "";

  /**
   * The Entity ID of the System.
   *
   * @generated from field: string entity_id = 2;
   */
  entityId = "";

  /**
   * The Asset ID of the System.
   *
   * @generated from field: string asset_id = 3;
   */
  assetId = "";

  /**
   * Whether the System Principal (for example, an Asset) can own scheduling.
   * This means we bypass manager-owned scheduling and defer to the system
   * Principal to handle scheduling and give us status updates for the Task.
   * Regardless of the value defined by the client, the Task Manager will
   * determine and set this value appropriately.
   *
   * @generated from field: bool manages_own_scheduling = 4;
   */
  managesOwnScheduling = false;

  constructor(data?: PartialMessage<System>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.System";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "service_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "entity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "asset_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "manages_own_scheduling", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): System {
    return new System().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): System {
    return new System().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): System {
    return new System().fromJsonString(jsonString, options);
  }

  static equals(a: System | PlainMessage<System> | undefined, b: System | PlainMessage<System> | undefined): boolean {
    return proto3.util.equals(System, a, b);
  }
}

/**
 * A User Principal representing a human.
 *
 * @generated from message anduril.taskmanager.v1.User
 */
export class User extends Message<User> {
  /**
   * The User ID associated with this User.
   *
   * @generated from field: string user_id = 1;
   */
  userId = "";

  constructor(data?: PartialMessage<User>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.User";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): User {
    return new User().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): User {
    return new User().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): User {
    return new User().fromJsonString(jsonString, options);
  }

  static equals(a: User | PlainMessage<User> | undefined, b: User | PlainMessage<User> | undefined): boolean {
    return proto3.util.equals(User, a, b);
  }
}

/**
 * Relations describes the relationships of this Task, such as assignment, or if the Task has any parents.
 *
 * @generated from message anduril.taskmanager.v1.Relations
 */
export class Relations extends Message<Relations> {
  /**
   * Who or what, if anyone, this Task is currently assigned to.
   *
   * @generated from field: anduril.taskmanager.v1.Principal assignee = 1;
   */
  assignee?: Principal;

  /**
   * If this Task is a "sub-Task", what is its parent, none if empty.
   *
   * @generated from field: string parent_task_id = 2;
   */
  parentTaskId = "";

  constructor(data?: PartialMessage<Relations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.Relations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "assignee", kind: "message", T: Principal },
    { no: 2, name: "parent_task_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Relations {
    return new Relations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Relations {
    return new Relations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Relations {
    return new Relations().fromJsonString(jsonString, options);
  }

  static equals(a: Relations | PlainMessage<Relations> | undefined, b: Relations | PlainMessage<Relations> | undefined): boolean {
    return proto3.util.equals(Relations, a, b);
  }
}

/**
 * Holds Tasks and its associated Events, e.g. CREATED.
 *
 * @generated from message anduril.taskmanager.v1.TaskEvent
 */
export class TaskEvent extends Message<TaskEvent> {
  /**
   * Type of Event.
   *
   * @generated from field: anduril.taskmanager.v1.EventType event_type = 1;
   */
  eventType = EventType.INVALID;

  /**
   * Task associated with this TaskEvent.
   *
   * @generated from field: anduril.taskmanager.v1.Task task = 2;
   */
  task?: Task;

  /**
   * View associated with this task.
   *
   * @generated from field: anduril.taskmanager.v1.TaskView task_view = 3;
   */
  taskView = TaskView.INVALID;

  /**
   * ===== Time Series Updates =====
   *
   * Timestamp for time-series to index.
   *
   * @generated from field: google.protobuf.Timestamp time = 4;
   */
  time?: Timestamp;

  constructor(data?: PartialMessage<TaskEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.TaskEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event_type", kind: "enum", T: proto3.getEnumType(EventType) },
    { no: 2, name: "task", kind: "message", T: Task },
    { no: 3, name: "task_view", kind: "enum", T: proto3.getEnumType(TaskView) },
    { no: 4, name: "time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskEvent {
    return new TaskEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskEvent {
    return new TaskEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskEvent {
    return new TaskEvent().fromJsonString(jsonString, options);
  }

  static equals(a: TaskEvent | PlainMessage<TaskEvent> | undefined, b: TaskEvent | PlainMessage<TaskEvent> | undefined): boolean {
    return proto3.util.equals(TaskEvent, a, b);
  }
}

/**
 * Version of a Task.
 *
 * @generated from message anduril.taskmanager.v1.TaskVersion
 */
export class TaskVersion extends Message<TaskVersion> {
  /**
   * The unique ID for this Task.
   *
   * @generated from field: string task_id = 1;
   */
  taskId = "";

  /**
   * Increments on definition (i.e. not TaskStatus) change. 0 is unset, starts at 1 on creation.
   *
   * @generated from field: uint32 definition_version = 2;
   */
  definitionVersion = 0;

  /**
   * Increments on changes to TaskStatus. 0 is unset, starts at 1 on creation.
   *
   * @generated from field: uint32 status_version = 3;
   */
  statusVersion = 0;

  constructor(data?: PartialMessage<TaskVersion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.TaskVersion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "definition_version", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "status_version", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskVersion {
    return new TaskVersion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskVersion {
    return new TaskVersion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskVersion {
    return new TaskVersion().fromJsonString(jsonString, options);
  }

  static equals(a: TaskVersion | PlainMessage<TaskVersion> | undefined, b: TaskVersion | PlainMessage<TaskVersion> | undefined): boolean {
    return proto3.util.equals(TaskVersion, a, b);
  }
}

/**
 * a Task status update that could come in via RPC or Flux.
 *
 * @generated from message anduril.taskmanager.v1.StatusUpdate
 */
export class StatusUpdate extends Message<StatusUpdate> {
  /**
   * Version of the Task.
   *
   * @generated from field: anduril.taskmanager.v1.TaskVersion version = 1;
   */
  version?: TaskVersion;

  /**
   * Status of the Task.
   *
   * @generated from field: anduril.taskmanager.v1.TaskStatus status = 2;
   */
  status?: TaskStatus;

  /**
   * Author of the StatusUpdate message. Used to set the LastUpdatedBy field of the Task.
   *
   * @generated from field: anduril.taskmanager.v1.Principal author = 3;
   */
  author?: Principal;

  /**
   * Typically provided if a user is manually managing a Task, or if an asset owns scheduling.
   *
   * @generated from field: google.protobuf.Timestamp scheduled_time = 4;
   */
  scheduledTime?: Timestamp;

  constructor(data?: PartialMessage<StatusUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.StatusUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "message", T: TaskVersion },
    { no: 2, name: "status", kind: "message", T: TaskStatus },
    { no: 3, name: "author", kind: "message", T: Principal },
    { no: 4, name: "scheduled_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatusUpdate {
    return new StatusUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatusUpdate {
    return new StatusUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatusUpdate {
    return new StatusUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: StatusUpdate | PlainMessage<StatusUpdate> | undefined, b: StatusUpdate | PlainMessage<StatusUpdate> | undefined): boolean {
    return proto3.util.equals(StatusUpdate, a, b);
  }
}

/**
 * Flux message representing a Task create or update.
 *
 * @generated from message anduril.taskmanager.v1.DefinitionUpdate
 */
export class DefinitionUpdate extends Message<DefinitionUpdate> {
  /**
   * New task definition being created or updated.
   * The last_updated_by and specification fields inside the task object must be defined.
   * Definition version must also be incremented by the publisher on updates.
   * We do not look at the fields create_time or last_update_time in this object,
   * they are instead set by task-manager.
   *
   * @generated from field: anduril.taskmanager.v1.Task task = 1;
   */
  task?: Task;

  constructor(data?: PartialMessage<DefinitionUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.DefinitionUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "task", kind: "message", T: Task },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DefinitionUpdate {
    return new DefinitionUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DefinitionUpdate {
    return new DefinitionUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DefinitionUpdate {
    return new DefinitionUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: DefinitionUpdate | PlainMessage<DefinitionUpdate> | undefined, b: DefinitionUpdate | PlainMessage<DefinitionUpdate> | undefined): boolean {
    return proto3.util.equals(DefinitionUpdate, a, b);
  }
}

/**
 * Owner designates the networked flux node responsible for linear writes of a Task data.
 *
 * @generated from message anduril.taskmanager.v1.Owner
 */
export class Owner extends Message<Owner> {
  /**
   * Flux Asset ID of the owner.
   *
   * @generated from field: string asset_id = 1;
   */
  assetId = "";

  /**
   * Entity ID of the owner.
   *
   * @generated from field: string entity_id = 2;
   */
  entityId = "";

  constructor(data?: PartialMessage<Owner>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.Owner";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "asset_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "entity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Owner {
    return new Owner().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Owner {
    return new Owner().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Owner {
    return new Owner().fromJsonString(jsonString, options);
  }

  static equals(a: Owner | PlainMessage<Owner> | undefined, b: Owner | PlainMessage<Owner> | undefined): boolean {
    return proto3.util.equals(Owner, a, b);
  }
}

/**
 * Any metadata associated with the replication of a Task.
 *
 * @generated from message anduril.taskmanager.v1.Replication
 */
export class Replication extends Message<Replication> {
  /**
   * Time by which this Task should be assumed to be stale.
   *
   * @generated from field: google.protobuf.Timestamp stale_time = 1;
   */
  staleTime?: Timestamp;

  constructor(data?: PartialMessage<Replication>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.Replication";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stale_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Replication {
    return new Replication().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Replication {
    return new Replication().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Replication {
    return new Replication().fromJsonString(jsonString, options);
  }

  static equals(a: Replication | PlainMessage<Replication> | undefined, b: Replication | PlainMessage<Replication> | undefined): boolean {
    return proto3.util.equals(Replication, a, b);
  }
}

/**
 * Allocation contains a list of agents allocated to a Task.
 *
 * @generated from message anduril.taskmanager.v1.Allocation
 */
export class Allocation extends Message<Allocation> {
  /**
   * Agents actively being utilized in a Task.
   *
   * @generated from field: repeated anduril.taskmanager.v1.Agent active_agents = 1;
   */
  activeAgents: Agent[] = [];

  constructor(data?: PartialMessage<Allocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.Allocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "active_agents", kind: "message", T: Agent, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Allocation {
    return new Allocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Allocation {
    return new Allocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Allocation {
    return new Allocation().fromJsonString(jsonString, options);
  }

  static equals(a: Allocation | PlainMessage<Allocation> | undefined, b: Allocation | PlainMessage<Allocation> | undefined): boolean {
    return proto3.util.equals(Allocation, a, b);
  }
}

/**
 * Represents a team of agents
 *
 * @generated from message anduril.taskmanager.v1.Team
 */
export class Team extends Message<Team> {
  /**
   * Entity ID of the team
   *
   * @generated from field: string entity_id = 1;
   */
  entityId = "";

  /**
   * @generated from field: repeated anduril.taskmanager.v1.Agent members = 2;
   */
  members: Agent[] = [];

  constructor(data?: PartialMessage<Team>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.Team";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "members", kind: "message", T: Agent, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Team {
    return new Team().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Team {
    return new Team().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Team {
    return new Team().fromJsonString(jsonString, options);
  }

  static equals(a: Team | PlainMessage<Team> | undefined, b: Team | PlainMessage<Team> | undefined): boolean {
    return proto3.util.equals(Team, a, b);
  }
}

/**
 * Represents an Agent on the Battlespace.
 *
 * @generated from message anduril.taskmanager.v1.Agent
 */
export class Agent extends Message<Agent> {
  /**
   * Asset ID of the agent.
   *
   * @generated from field: string asset_id = 1;
   */
  assetId = "";

  /**
   * Entity ID of the agent.
   *
   * @generated from field: string entity_id = 2;
   */
  entityId = "";

  constructor(data?: PartialMessage<Agent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.Agent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "asset_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "entity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Agent {
    return new Agent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Agent {
    return new Agent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Agent {
    return new Agent().fromJsonString(jsonString, options);
  }

  static equals(a: Agent | PlainMessage<Agent> | undefined, b: Agent | PlainMessage<Agent> | undefined): boolean {
    return proto3.util.equals(Agent, a, b);
  }
}

/**
 * Wrapper of an entity passed in Tasking, used to hold an additional information, and as a future extension point.
 *
 * @generated from message anduril.taskmanager.v1.TaskEntity
 */
export class TaskEntity extends Message<TaskEntity> {
  /**
   * The wrapped entity-manager entity.
   *
   * @generated from field: anduril.entitymanager.v1.Entity entity = 1;
   */
  entity?: Entity;

  /**
   * Indicates that this entity was generated from a snapshot of a live entity.
   *
   * @generated from field: bool snapshot = 2;
   */
  snapshot = false;

  constructor(data?: PartialMessage<TaskEntity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.taskmanager.v1.TaskEntity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity", kind: "message", T: Entity },
    { no: 2, name: "snapshot", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskEntity {
    return new TaskEntity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskEntity {
    return new TaskEntity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskEntity {
    return new TaskEntity().fromJsonString(jsonString, options);
  }

  static equals(a: TaskEntity | PlainMessage<TaskEntity> | undefined, b: TaskEntity | PlainMessage<TaskEntity> | undefined): boolean {
    return proto3.util.equals(TaskEntity, a, b);
  }
}

