// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/tasks/v2/shared/isr.pub.proto (package anduril.tasks.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { DoubleValue, FloatValue, Message, proto3, Timestamp, UInt32Value, UInt64Value } from "@bufbuild/protobuf";
import { Objective, Point } from "../objective.pub_pb.js";
import { Agent, ControlArea, DurationRange } from "../common.pub_pb.js";

/**
 * Direction of the loiter relative to the front of the vehicle.
 *
 * @generated from enum anduril.tasks.v2.OrbitDirection
 */
export enum OrbitDirection {
  /**
   * @generated from enum value: ORBIT_DIRECTION_DIRECTION_INVALID = 0;
   */
  DIRECTION_INVALID = 0,

  /**
   * @generated from enum value: ORBIT_DIRECTION_RIGHT = 1;
   */
  RIGHT = 1,

  /**
   * @generated from enum value: ORBIT_DIRECTION_LEFT = 2;
   */
  LEFT = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(OrbitDirection)
proto3.util.setEnumType(OrbitDirection, "anduril.tasks.v2.OrbitDirection", [
  { no: 0, name: "ORBIT_DIRECTION_DIRECTION_INVALID" },
  { no: 1, name: "ORBIT_DIRECTION_RIGHT" },
  { no: 2, name: "ORBIT_DIRECTION_LEFT" },
]);

/**
 * @generated from enum anduril.tasks.v2.OrbitPattern
 */
export enum OrbitPattern {
  /**
   * @generated from enum value: ORBIT_PATTERN_INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: ORBIT_PATTERN_CIRCLE = 1;
   */
  CIRCLE = 1,

  /**
   * @generated from enum value: ORBIT_PATTERN_RACETRACK = 2;
   */
  RACETRACK = 2,

  /**
   * @generated from enum value: ORBIT_PATTERN_FIGURE_EIGHT = 3;
   */
  FIGURE_EIGHT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(OrbitPattern)
proto3.util.setEnumType(OrbitPattern, "anduril.tasks.v2.OrbitPattern", [
  { no: 0, name: "ORBIT_PATTERN_INVALID" },
  { no: 1, name: "ORBIT_PATTERN_CIRCLE" },
  { no: 2, name: "ORBIT_PATTERN_RACETRACK" },
  { no: 3, name: "ORBIT_PATTERN_FIGURE_EIGHT" },
]);

/**
 * Maps to BREVITY code INVESTIGATE.
 *
 * @generated from message anduril.tasks.v2.Investigate
 */
export class Investigate extends Message<Investigate> {
  /**
   * Indicates where to investigate.
   *
   * @generated from field: anduril.tasks.v2.Objective objective = 1;
   */
  objective?: Objective;

  /**
   * Optional common ISR parameters.
   *
   * @generated from field: anduril.tasks.v2.ISRParameters parameters = 2;
   */
  parameters?: ISRParameters;

  constructor(data?: PartialMessage<Investigate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.Investigate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objective", kind: "message", T: Objective },
    { no: 2, name: "parameters", kind: "message", T: ISRParameters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Investigate {
    return new Investigate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Investigate {
    return new Investigate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Investigate {
    return new Investigate().fromJsonString(jsonString, options);
  }

  static equals(a: Investigate | PlainMessage<Investigate> | undefined, b: Investigate | PlainMessage<Investigate> | undefined): boolean {
    return proto3.util.equals(Investigate, a, b);
  }
}

/**
 * Maps to BREVITY code ID with type Visual.
 *
 * @generated from message anduril.tasks.v2.VisualId
 */
export class VisualId extends Message<VisualId> {
  /**
   * Indicates what to identify.
   *
   * @generated from field: anduril.tasks.v2.Objective objective = 1;
   */
  objective?: Objective;

  /**
   * Optional common ISR parameters.
   *
   * @generated from field: anduril.tasks.v2.ISRParameters parameters = 2;
   */
  parameters?: ISRParameters;

  constructor(data?: PartialMessage<VisualId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.VisualId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objective", kind: "message", T: Objective },
    { no: 2, name: "parameters", kind: "message", T: ISRParameters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VisualId {
    return new VisualId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VisualId {
    return new VisualId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VisualId {
    return new VisualId().fromJsonString(jsonString, options);
  }

  static equals(a: VisualId | PlainMessage<VisualId> | undefined, b: VisualId | PlainMessage<VisualId> | undefined): boolean {
    return proto3.util.equals(VisualId, a, b);
  }
}

/**
 * Maps to BREVITY code MAP.
 *
 * @generated from message anduril.tasks.v2.Map
 */
export class Map extends Message<Map> {
  /**
   * Indicates where to perform the SAR.
   *
   * @generated from field: anduril.tasks.v2.Objective objective = 1;
   */
  objective?: Objective;

  /**
   * Optional common ISR parameters.
   *
   * @generated from field: anduril.tasks.v2.ISRParameters parameters = 2;
   */
  parameters?: ISRParameters;

  /**
   * minimum desired NIIRS (National Image Interpretability Rating Scales) see https://irp.fas.org/imint/niirs.htm
   *
   * @generated from field: google.protobuf.UInt32Value min_niirs = 3;
   */
  minNiirs?: number;

  constructor(data?: PartialMessage<Map>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.Map";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objective", kind: "message", T: Objective },
    { no: 2, name: "parameters", kind: "message", T: ISRParameters },
    { no: 3, name: "min_niirs", kind: "message", T: UInt32Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Map {
    return new Map().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Map {
    return new Map().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Map {
    return new Map().fromJsonString(jsonString, options);
  }

  static equals(a: Map | PlainMessage<Map> | undefined, b: Map | PlainMessage<Map> | undefined): boolean {
    return proto3.util.equals(Map, a, b);
  }
}

/**
 * Maps to the Loiter behavior within the FlightTask type within UCI v2.
 *
 * @generated from message anduril.tasks.v2.Loiter
 */
export class Loiter extends Message<Loiter> {
  /**
   * Indicates where to perform the loiter.
   *
   * @generated from field: anduril.tasks.v2.Objective objective = 1;
   */
  objective?: Objective;

  /**
   * Specifies the details of the loiter.
   *
   * @generated from field: anduril.tasks.v2.LoiterType loiter_type = 2;
   */
  loiterType?: LoiterType;

  /**
   * Optional common ISR parameters.
   * The loiter radius and bearing should be inferred from the standoff_distance and standoff_angle respectively.
   *
   * @generated from field: anduril.tasks.v2.ISRParameters parameters = 3;
   */
  parameters?: ISRParameters;

  constructor(data?: PartialMessage<Loiter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.Loiter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objective", kind: "message", T: Objective },
    { no: 2, name: "loiter_type", kind: "message", T: LoiterType },
    { no: 3, name: "parameters", kind: "message", T: ISRParameters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Loiter {
    return new Loiter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Loiter {
    return new Loiter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Loiter {
    return new Loiter().fromJsonString(jsonString, options);
  }

  static equals(a: Loiter | PlainMessage<Loiter> | undefined, b: Loiter | PlainMessage<Loiter> | undefined): boolean {
    return proto3.util.equals(Loiter, a, b);
  }
}

/**
 * Represents intent to search an area. Maps to the Area Search Team Task within the Mission Autonomy Task Model.
 *
 * @generated from message anduril.tasks.v2.AreaSearch
 */
export class AreaSearch extends Message<AreaSearch> {
  /**
   * Indicates where to perform the area search.
   *
   * @generated from field: anduril.tasks.v2.Objective objective = 1;
   */
  objective?: Objective;

  /**
   * Priors that can be used to inform this AreaSearch.
   *
   * @generated from field: repeated anduril.tasks.v2.Prior priors = 2;
   */
  priors: Prior[] = [];

  /**
   * Agents participating in this AreaSearch.
   *
   * @generated from field: repeated anduril.tasks.v2.Agent participants = 3;
   */
  participants: Agent[] = [];

  /**
   * Control Area for this AreaSearch.
   *
   * TODO: populate remaining fields here as we iterate on the AreaSearch integration.
   *
   * @generated from field: repeated anduril.tasks.v2.ControlArea control_areas = 4;
   */
  controlAreas: ControlArea[] = [];

  constructor(data?: PartialMessage<AreaSearch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.AreaSearch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objective", kind: "message", T: Objective },
    { no: 2, name: "priors", kind: "message", T: Prior, repeated: true },
    { no: 3, name: "participants", kind: "message", T: Agent, repeated: true },
    { no: 4, name: "control_areas", kind: "message", T: ControlArea, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AreaSearch {
    return new AreaSearch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AreaSearch {
    return new AreaSearch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AreaSearch {
    return new AreaSearch().fromJsonString(jsonString, options);
  }

  static equals(a: AreaSearch | PlainMessage<AreaSearch> | undefined, b: AreaSearch | PlainMessage<AreaSearch> | undefined): boolean {
    return proto3.util.equals(AreaSearch, a, b);
  }
}

/**
 * Represents intent to search a volume. Maps to the Volume Search Team Task within the Mission Autonomy Task Model.
 *
 * @generated from message anduril.tasks.v2.VolumeSearch
 */
export class VolumeSearch extends Message<VolumeSearch> {
  /**
   * Indicates where to perform the volume search.
   *
   * @generated from field: anduril.tasks.v2.Objective objective = 1;
   */
  objective?: Objective;

  /**
   * Priors that can be used to inform this VolumeSearch.
   *
   * @generated from field: repeated anduril.tasks.v2.Prior priors = 2;
   */
  priors: Prior[] = [];

  /**
   * Agents participating in this VolumeSearch.
   *
   * @generated from field: repeated anduril.tasks.v2.Agent participants = 3;
   */
  participants: Agent[] = [];

  /**
   * Control Area for this VolumeSearch.
   *
   * TODO: populate remaining fields here as we iterate on the VolumeSearch integration.
   *
   * @generated from field: repeated anduril.tasks.v2.ControlArea control_areas = 4;
   */
  controlAreas: ControlArea[] = [];

  constructor(data?: PartialMessage<VolumeSearch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.VolumeSearch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objective", kind: "message", T: Objective },
    { no: 2, name: "priors", kind: "message", T: Prior, repeated: true },
    { no: 3, name: "participants", kind: "message", T: Agent, repeated: true },
    { no: 4, name: "control_areas", kind: "message", T: ControlArea, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VolumeSearch {
    return new VolumeSearch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VolumeSearch {
    return new VolumeSearch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VolumeSearch {
    return new VolumeSearch().fromJsonString(jsonString, options);
  }

  static equals(a: VolumeSearch | PlainMessage<VolumeSearch> | undefined, b: VolumeSearch | PlainMessage<VolumeSearch> | undefined): boolean {
    return proto3.util.equals(VolumeSearch, a, b);
  }
}

/**
 * Task to improve the quality of a track. Maps to the Improve Track Task within the Mission Autonomy Task Model.
 *
 * @generated from message anduril.tasks.v2.ImproveTrackQuality
 */
export class ImproveTrackQuality extends Message<ImproveTrackQuality> {
  /**
   * Indicates the target track that is having its quality improved.
   *
   * @generated from field: anduril.tasks.v2.Objective objective = 1;
   */
  objective?: Objective;

  /**
   * Task will complete when the requested track reaches a TQ >= the termination_track_quality.
   *
   * @generated from field: uint32 termination_track_quality = 2;
   */
  terminationTrackQuality = 0;

  constructor(data?: PartialMessage<ImproveTrackQuality>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.ImproveTrackQuality";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objective", kind: "message", T: Objective },
    { no: 2, name: "termination_track_quality", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImproveTrackQuality {
    return new ImproveTrackQuality().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImproveTrackQuality {
    return new ImproveTrackQuality().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImproveTrackQuality {
    return new ImproveTrackQuality().fromJsonString(jsonString, options);
  }

  static equals(a: ImproveTrackQuality | PlainMessage<ImproveTrackQuality> | undefined, b: ImproveTrackQuality | PlainMessage<ImproveTrackQuality> | undefined): boolean {
    return proto3.util.equals(ImproveTrackQuality, a, b);
  }
}

/**
 * Indicates intent to follow an Objective. Maps to Brevity code SHADOW.
 *
 * @generated from message anduril.tasks.v2.Shadow
 */
export class Shadow extends Message<Shadow> {
  /**
   * Indicates what to follow.
   *
   * @generated from field: anduril.tasks.v2.Objective objective = 1;
   */
  objective?: Objective;

  /**
   * Optional common ISR parameters.
   *
   * @generated from field: anduril.tasks.v2.ISRParameters parameters = 2;
   */
  parameters?: ISRParameters;

  constructor(data?: PartialMessage<Shadow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.Shadow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objective", kind: "message", T: Objective },
    { no: 2, name: "parameters", kind: "message", T: ISRParameters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Shadow {
    return new Shadow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Shadow {
    return new Shadow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Shadow {
    return new Shadow().fromJsonString(jsonString, options);
  }

  static equals(a: Shadow | PlainMessage<Shadow> | undefined, b: Shadow | PlainMessage<Shadow> | undefined): boolean {
    return proto3.util.equals(Shadow, a, b);
  }
}

/**
 * Maps to UCI v2 LoiterType.
 *
 * @generated from message anduril.tasks.v2.LoiterType
 */
export class LoiterType extends Message<LoiterType> {
  /**
   * @generated from oneof anduril.tasks.v2.LoiterType.loiter_type
   */
  loiterType: {
    /**
     * @generated from field: anduril.tasks.v2.OrbitType orbit_type = 1;
     */
    value: OrbitType;
    case: "orbitType";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<LoiterType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.LoiterType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "orbit_type", kind: "message", T: OrbitType, oneof: "loiter_type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoiterType {
    return new LoiterType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoiterType {
    return new LoiterType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoiterType {
    return new LoiterType().fromJsonString(jsonString, options);
  }

  static equals(a: LoiterType | PlainMessage<LoiterType> | undefined, b: LoiterType | PlainMessage<LoiterType> | undefined): boolean {
    return proto3.util.equals(LoiterType, a, b);
  }
}

/**
 * @generated from message anduril.tasks.v2.OrbitType
 */
export class OrbitType extends Message<OrbitType> {
  /**
   * Indicates the direction in which to perform the loiter.
   *
   * @generated from field: anduril.tasks.v2.OrbitDirection direction = 1;
   */
  direction = OrbitDirection.DIRECTION_INVALID;

  /**
   * Indicates the loiter pattern to perform.
   *
   * @generated from field: anduril.tasks.v2.OrbitPattern pattern = 2;
   */
  pattern = OrbitPattern.INVALID;

  /**
   * Indicates the amount of time to be spent in loiter.
   *
   * @generated from field: anduril.tasks.v2.OrbitDuration duration = 3;
   */
  duration?: OrbitDuration;

  constructor(data?: PartialMessage<OrbitType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.OrbitType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "direction", kind: "enum", T: proto3.getEnumType(OrbitDirection) },
    { no: 2, name: "pattern", kind: "enum", T: proto3.getEnumType(OrbitPattern) },
    { no: 3, name: "duration", kind: "message", T: OrbitDuration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrbitType {
    return new OrbitType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrbitType {
    return new OrbitType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrbitType {
    return new OrbitType().fromJsonString(jsonString, options);
  }

  static equals(a: OrbitType | PlainMessage<OrbitType> | undefined, b: OrbitType | PlainMessage<OrbitType> | undefined): boolean {
    return proto3.util.equals(OrbitType, a, b);
  }
}

/**
 * @generated from message anduril.tasks.v2.OrbitDuration
 */
export class OrbitDuration extends Message<OrbitDuration> {
  /**
   * @generated from oneof anduril.tasks.v2.OrbitDuration.duration
   */
  duration: {
    /**
     * @generated from field: anduril.tasks.v2.DurationRange duration_range = 1;
     */
    value: DurationRange;
    case: "durationRange";
  } | {
    /**
     * @generated from field: uint64 num_of_orbits = 2;
     */
    value: bigint;
    case: "numOfOrbits";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<OrbitDuration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.OrbitDuration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "duration_range", kind: "message", T: DurationRange, oneof: "duration" },
    { no: 2, name: "num_of_orbits", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "duration" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrbitDuration {
    return new OrbitDuration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrbitDuration {
    return new OrbitDuration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrbitDuration {
    return new OrbitDuration().fromJsonString(jsonString, options);
  }

  static equals(a: OrbitDuration | PlainMessage<OrbitDuration> | undefined, b: OrbitDuration | PlainMessage<OrbitDuration> | undefined): boolean {
    return proto3.util.equals(OrbitDuration, a, b);
  }
}

/**
 * A Prior that can be used to inform an ISR Task.
 *
 * @generated from message anduril.tasks.v2.Prior
 */
export class Prior extends Message<Prior> {
  /**
   * @generated from oneof anduril.tasks.v2.Prior.prior
   */
  prior: {
    /**
     * Prefer Entity priors whenever the prior is in fact an entity. In other words, don't take position/point
     * out of an entity and pass it as a simple point.
     *
     * @generated from field: string entity_id = 1;
     */
    value: string;
    case: "entityId";
  } | {
    /**
     * Point priors for simple reference points that are not geo entities.
     *
     * @generated from field: anduril.tasks.v2.Point point = 5;
     */
    value: Point;
    case: "point";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Prior>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.Prior";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "prior" },
    { no: 5, name: "point", kind: "message", T: Point, oneof: "prior" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Prior {
    return new Prior().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Prior {
    return new Prior().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Prior {
    return new Prior().fromJsonString(jsonString, options);
  }

  static equals(a: Prior | PlainMessage<Prior> | undefined, b: Prior | PlainMessage<Prior> | undefined): boolean {
    return proto3.util.equals(Prior, a, b);
  }
}

/**
 * Common parameters for ISR Tasks.
 *
 * @generated from message anduril.tasks.v2.ISRParameters
 */
export class ISRParameters extends Message<ISRParameters> {
  /**
   * Indicates the target speed of the asset. DEPRECATION NOTE: deprecated in favor
   * of speed_ms since we might have legacy integrations not conforming to the meters per second units.
   *
   * @generated from field: google.protobuf.FloatValue speed = 1 [deprecated = true];
   * @deprecated
   */
  speed?: number;

  /**
   * Indicates the target speed of the asset. Units are meters per second.
   *
   * @generated from field: google.protobuf.FloatValue speed_m_s = 2;
   */
  speedMS?: number;

  /**
   * Indicates the standoff distance from the objective. The units are in meters.
   *
   * @generated from field: google.protobuf.FloatValue standoff_distance_m = 3;
   */
  standoffDistanceM?: number;

  /**
   * Indicates the standoff distance from the objective. DEPRECATION NOTE: deprecated in favor of standoff_distance_m
   *  since we might have legacy integrations not conforming to the meters unit.
   *
   * @generated from field: google.protobuf.FloatValue standoff_distance = 4 [deprecated = true];
   * @deprecated
   */
  standoffDistance?: number;

  /**
   * Indicates the standoff angle relative to the objective's bearing orientation (defaults to north).
   * In particular, the asset should approach target from this angle. Units in degrees.
   *
   * @generated from field: google.protobuf.FloatValue standoff_angle = 5;
   */
  standoffAngle?: number;

  /**
   * Indicates the amount of time in milliseconds to execute an ISR task before expiring. 0 value indicates no
   * expiration.
   *
   * @generated from field: google.protobuf.UInt64Value expiration_time_ms = 6;
   */
  expirationTimeMs?: bigint;

  constructor(data?: PartialMessage<ISRParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.ISRParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "speed", kind: "message", T: FloatValue },
    { no: 2, name: "speed_m_s", kind: "message", T: FloatValue },
    { no: 3, name: "standoff_distance_m", kind: "message", T: FloatValue },
    { no: 4, name: "standoff_distance", kind: "message", T: FloatValue },
    { no: 5, name: "standoff_angle", kind: "message", T: FloatValue },
    { no: 6, name: "expiration_time_ms", kind: "message", T: UInt64Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ISRParameters {
    return new ISRParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ISRParameters {
    return new ISRParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ISRParameters {
    return new ISRParameters().fromJsonString(jsonString, options);
  }

  static equals(a: ISRParameters | PlainMessage<ISRParameters> | undefined, b: ISRParameters | PlainMessage<ISRParameters> | undefined): boolean {
    return proto3.util.equals(ISRParameters, a, b);
  }
}

/**
 * Gimbal pointing command.
 *
 * @generated from message anduril.tasks.v2.GimbalPoint
 */
export class GimbalPoint extends Message<GimbalPoint> {
  /**
   * @generated from oneof anduril.tasks.v2.GimbalPoint.point_type
   */
  pointType: {
    /**
     * Point the gimbal at and lock on, continuing to look at a specific objective even as the platform moves.
     *
     * @generated from field: anduril.tasks.v2.Objective look_at = 1;
     */
    value: Objective;
    case: "lookAt";
  } | {
    /**
     * Point the gimbal at a fixed azimuth/elevation with respect to the platform frame.
     *
     * @generated from field: anduril.tasks.v2.AzimuthElevationPoint celestial_location = 2;
     */
    value: AzimuthElevationPoint;
    case: "celestialLocation";
  } | {
    /**
     * Point gimbal to an [x, y] location in the video feed.
     *
     * @generated from field: anduril.tasks.v2.FramePoint frame_location = 4;
     */
    value: FramePoint;
    case: "frameLocation";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Optional common ISR parameters.
   *
   * @generated from field: anduril.tasks.v2.ISRParameters parameters = 3;
   */
  parameters?: ISRParameters;

  constructor(data?: PartialMessage<GimbalPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.GimbalPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "look_at", kind: "message", T: Objective, oneof: "point_type" },
    { no: 2, name: "celestial_location", kind: "message", T: AzimuthElevationPoint, oneof: "point_type" },
    { no: 4, name: "frame_location", kind: "message", T: FramePoint, oneof: "point_type" },
    { no: 3, name: "parameters", kind: "message", T: ISRParameters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GimbalPoint {
    return new GimbalPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GimbalPoint {
    return new GimbalPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GimbalPoint {
    return new GimbalPoint().fromJsonString(jsonString, options);
  }

  static equals(a: GimbalPoint | PlainMessage<GimbalPoint> | undefined, b: GimbalPoint | PlainMessage<GimbalPoint> | undefined): boolean {
    return proto3.util.equals(GimbalPoint, a, b);
  }
}

/**
 * Celestial location with respect to a platform frame.
 *
 * @generated from message anduril.tasks.v2.AzimuthElevationPoint
 */
export class AzimuthElevationPoint extends Message<AzimuthElevationPoint> {
  /**
   * @generated from field: double azimuth = 1;
   */
  azimuth = 0;

  /**
   * @generated from field: double elevation = 2;
   */
  elevation = 0;

  constructor(data?: PartialMessage<AzimuthElevationPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.AzimuthElevationPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "azimuth", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "elevation", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AzimuthElevationPoint {
    return new AzimuthElevationPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AzimuthElevationPoint {
    return new AzimuthElevationPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AzimuthElevationPoint {
    return new AzimuthElevationPoint().fromJsonString(jsonString, options);
  }

  static equals(a: AzimuthElevationPoint | PlainMessage<AzimuthElevationPoint> | undefined, b: AzimuthElevationPoint | PlainMessage<AzimuthElevationPoint> | undefined): boolean {
    return proto3.util.equals(AzimuthElevationPoint, a, b);
  }
}

/**
 * Point clicked in the frame of the video feed.
 *
 * @generated from message anduril.tasks.v2.FramePoint
 */
export class FramePoint extends Message<FramePoint> {
  /**
   * Frame-normalized location in frame on the x-axis, range (0, 1).
   * For example, x = 0.3 implies a pixel location of 0.3 * image_width.
   *
   * @generated from field: float x = 1;
   */
  x = 0;

  /**
   * Frame-normalized location in frame on the y-axis, range (0, 1).
   * For example, y = 0.3 implies a pixel location of 0.3 * image_height.
   *
   * @generated from field: float y = 2;
   */
  y = 0;

  /**
   * Timestamp of frame
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<FramePoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.FramePoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "y", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FramePoint {
    return new FramePoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FramePoint {
    return new FramePoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FramePoint {
    return new FramePoint().fromJsonString(jsonString, options);
  }

  static equals(a: FramePoint | PlainMessage<FramePoint> | undefined, b: FramePoint | PlainMessage<FramePoint> | undefined): boolean {
    return proto3.util.equals(FramePoint, a, b);
  }
}

/**
 * Command for setting gimbal zoom levels.
 *
 * @generated from message anduril.tasks.v2.GimbalZoom
 */
export class GimbalZoom extends Message<GimbalZoom> {
  /**
   * @generated from oneof anduril.tasks.v2.GimbalZoom.mode
   */
  mode: {
    /**
     * Set the zoom level to the provided horizontal field of view in degrees.
     *
     * @generated from field: google.protobuf.DoubleValue set_horizontal_fov = 1;
     */
    value: DoubleValue;
    case: "setHorizontalFov";
  } | {
    /**
     * Set the zoom level to the provided zoom level.
     *
     * @generated from field: google.protobuf.FloatValue set_magnification = 2;
     */
    value: FloatValue;
    case: "setMagnification";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GimbalZoom>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.GimbalZoom";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "set_horizontal_fov", kind: "message", T: DoubleValue, oneof: "mode" },
    { no: 2, name: "set_magnification", kind: "message", T: FloatValue, oneof: "mode" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GimbalZoom {
    return new GimbalZoom().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GimbalZoom {
    return new GimbalZoom().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GimbalZoom {
    return new GimbalZoom().fromJsonString(jsonString, options);
  }

  static equals(a: GimbalZoom | PlainMessage<GimbalZoom> | undefined, b: GimbalZoom | PlainMessage<GimbalZoom> | undefined): boolean {
    return proto3.util.equals(GimbalZoom, a, b);
  }
}

/**
 * Maps to BREVITY code ID with type MONITOR. To task assets to maintain sensor awareness
 * on a given objective.
 *
 * @generated from message anduril.tasks.v2.Monitor
 */
export class Monitor extends Message<Monitor> {
  /**
   * Indicates objective to monitor.
   *
   * @generated from field: anduril.tasks.v2.Objective objective = 1;
   */
  objective?: Objective;

  /**
   * Identifies track to monitor.
   *
   * @generated from field: string track_id = 2;
   */
  trackId = "";

  /**
   * AssetId2 of asset that produced track.
   *
   * @generated from field: string track_producer = 3;
   */
  trackProducer = "";

  constructor(data?: PartialMessage<Monitor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.Monitor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objective", kind: "message", T: Objective },
    { no: 2, name: "track_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "track_producer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Monitor {
    return new Monitor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Monitor {
    return new Monitor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Monitor {
    return new Monitor().fromJsonString(jsonString, options);
  }

  static equals(a: Monitor | PlainMessage<Monitor> | undefined, b: Monitor | PlainMessage<Monitor> | undefined): boolean {
    return proto3.util.equals(Monitor, a, b);
  }
}

/**
 * Maps to BREVITY code ID with type SCAN. To task assets to find and report any tracks in a geographic area.
 *
 * @generated from message anduril.tasks.v2.Scan
 */
export class Scan extends Message<Scan> {
  /**
   * Indicates where to scan.
   *
   * @generated from field: anduril.tasks.v2.Objective objective = 1;
   */
  objective?: Objective;

  /**
   * Optional common ISR parameters.
   *
   * @generated from field: anduril.tasks.v2.ISRParameters parameters = 2;
   */
  parameters?: ISRParameters;

  constructor(data?: PartialMessage<Scan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.Scan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objective", kind: "message", T: Objective },
    { no: 2, name: "parameters", kind: "message", T: ISRParameters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Scan {
    return new Scan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Scan {
    return new Scan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Scan {
    return new Scan().fromJsonString(jsonString, options);
  }

  static equals(a: Scan | PlainMessage<Scan> | undefined, b: Scan | PlainMessage<Scan> | undefined): boolean {
    return proto3.util.equals(Scan, a, b);
  }
}

/**
 * Performs a Battle Damage Assessment (BDA). Does not map to any Task in either UCI or BREVITY.
 *
 * @generated from message anduril.tasks.v2.BattleDamageAssessment
 */
export class BattleDamageAssessment extends Message<BattleDamageAssessment> {
  /**
   * Objective to perform BDA on.
   *
   * @generated from field: anduril.tasks.v2.Objective objective = 1;
   */
  objective?: Objective;

  /**
   * Optional common ISR parameters.
   *
   * @generated from field: anduril.tasks.v2.ISRParameters parameters = 2;
   */
  parameters?: ISRParameters;

  constructor(data?: PartialMessage<BattleDamageAssessment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.BattleDamageAssessment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objective", kind: "message", T: Objective },
    { no: 2, name: "parameters", kind: "message", T: ISRParameters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BattleDamageAssessment {
    return new BattleDamageAssessment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BattleDamageAssessment {
    return new BattleDamageAssessment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BattleDamageAssessment {
    return new BattleDamageAssessment().fromJsonString(jsonString, options);
  }

  static equals(a: BattleDamageAssessment | PlainMessage<BattleDamageAssessment> | undefined, b: BattleDamageAssessment | PlainMessage<BattleDamageAssessment> | undefined): boolean {
    return proto3.util.equals(BattleDamageAssessment, a, b);
  }
}

