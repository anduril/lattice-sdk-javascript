// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/tasks/v2/shared/strike.pub.proto (package anduril.tasks.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Empty, Message, proto3 } from "@bufbuild/protobuf";
import { Objective } from "../objective.pub_pb.js";
import { AnglePair, AreaConstraints } from "../common.pub_pb.js";

/**
 * Maps to BREVITY code SMACK.
 *
 * @generated from message anduril.tasks.v2.Smack
 */
export class Smack extends Message<Smack> {
  /**
   * Objective to SMACK.
   *
   * @generated from field: anduril.tasks.v2.Objective objective = 1;
   */
  objective?: Objective;

  /**
   * Optional parameters associated with Strike Tasks.
   *
   * @generated from field: anduril.tasks.v2.StrikeParameters parameters = 2;
   */
  parameters?: StrikeParameters;

  constructor(data?: PartialMessage<Smack>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.Smack";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objective", kind: "message", T: Objective },
    { no: 2, name: "parameters", kind: "message", T: StrikeParameters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Smack {
    return new Smack().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Smack {
    return new Smack().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Smack {
    return new Smack().fromJsonString(jsonString, options);
  }

  static equals(a: Smack | PlainMessage<Smack> | undefined, b: Smack | PlainMessage<Smack> | undefined): boolean {
    return proto3.util.equals(Smack, a, b);
  }
}

/**
 * Maps to UCI StrikeTask.
 *
 * @generated from message anduril.tasks.v2.Strike
 */
export class Strike extends Message<Strike> {
  /**
   * Objective to Strike.
   *
   * @generated from field: anduril.tasks.v2.Objective objective = 1;
   */
  objective?: Objective;

  /**
   * Angle range within which to ingress.
   *
   * @generated from field: anduril.tasks.v2.AnglePair ingress_angle = 2;
   */
  ingressAngle?: AnglePair;

  /**
   * Distance at which to yield flight control to the onboard flight computer rather than
   * higher level autonomy.
   *
   * @generated from field: anduril.tasks.v2.StrikeReleaseConstraint strike_release_constraint = 3;
   */
  strikeReleaseConstraint?: StrikeReleaseConstraint;

  /**
   * Optional parameters associated with the Strike task.
   *
   * @generated from field: anduril.tasks.v2.StrikeParameters parameters = 4;
   */
  parameters?: StrikeParameters;

  constructor(data?: PartialMessage<Strike>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.Strike";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objective", kind: "message", T: Objective },
    { no: 2, name: "ingress_angle", kind: "message", T: AnglePair },
    { no: 3, name: "strike_release_constraint", kind: "message", T: StrikeReleaseConstraint },
    { no: 4, name: "parameters", kind: "message", T: StrikeParameters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Strike {
    return new Strike().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Strike {
    return new Strike().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Strike {
    return new Strike().fromJsonString(jsonString, options);
  }

  static equals(a: Strike | PlainMessage<Strike> | undefined, b: Strike | PlainMessage<Strike> | undefined): boolean {
    return proto3.util.equals(Strike, a, b);
  }
}

/**
 * Maps to UCI StrikeTaskReleaseConstraintsType.
 *
 * @generated from message anduril.tasks.v2.StrikeReleaseConstraint
 */
export class StrikeReleaseConstraint extends Message<StrikeReleaseConstraint> {
  /**
   * @generated from oneof anduril.tasks.v2.StrikeReleaseConstraint.strike_release_constraint
   */
  strikeReleaseConstraint: {
    /**
     * @generated from field: anduril.tasks.v2.AreaConstraints release_area = 1;
     */
    value: AreaConstraints;
    case: "releaseArea";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StrikeReleaseConstraint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.StrikeReleaseConstraint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "release_area", kind: "message", T: AreaConstraints, oneof: "strike_release_constraint" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StrikeReleaseConstraint {
    return new StrikeReleaseConstraint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StrikeReleaseConstraint {
    return new StrikeReleaseConstraint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StrikeReleaseConstraint {
    return new StrikeReleaseConstraint().fromJsonString(jsonString, options);
  }

  static equals(a: StrikeReleaseConstraint | PlainMessage<StrikeReleaseConstraint> | undefined, b: StrikeReleaseConstraint | PlainMessage<StrikeReleaseConstraint> | undefined): boolean {
    return proto3.util.equals(StrikeReleaseConstraint, a, b);
  }
}

/**
 * @generated from message anduril.tasks.v2.StrikeParameters
 */
export class StrikeParameters extends Message<StrikeParameters> {
  /**
   * @generated from field: repeated anduril.tasks.v2.PayloadConfiguration payloads_to_employ = 1;
   */
  payloadsToEmploy: PayloadConfiguration[] = [];

  /**
   * GPS time at which the strike should be performed.
   *
   * @generated from field: google.protobuf.Duration desired_impact_time = 2;
   */
  desiredImpactTime?: Duration;

  /**
   * Bearing at which to perform the run in for a strike.
   *
   * @generated from field: double run_in_bearing = 3;
   */
  runInBearing = 0;

  /**
   * Angle which to glide into the run in for a strike.
   *
   * @generated from field: double glide_slope_angle = 4;
   */
  glideSlopeAngle = 0;

  constructor(data?: PartialMessage<StrikeParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.StrikeParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "payloads_to_employ", kind: "message", T: PayloadConfiguration, repeated: true },
    { no: 2, name: "desired_impact_time", kind: "message", T: Duration },
    { no: 3, name: "run_in_bearing", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "glide_slope_angle", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StrikeParameters {
    return new StrikeParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StrikeParameters {
    return new StrikeParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StrikeParameters {
    return new StrikeParameters().fromJsonString(jsonString, options);
  }

  static equals(a: StrikeParameters | PlainMessage<StrikeParameters> | undefined, b: StrikeParameters | PlainMessage<StrikeParameters> | undefined): boolean {
    return proto3.util.equals(StrikeParameters, a, b);
  }
}

/**
 * Individual payload configuration, can represent a munition such as a missile, a gun, or a non-kinetic effect.
 *
 * @generated from message anduril.tasks.v2.PayloadConfiguration
 */
export class PayloadConfiguration extends Message<PayloadConfiguration> {
  /**
   * Unique ID or descriptor for the capability.
   *
   * @generated from field: string capability_id = 1;
   */
  capabilityId = "";

  /**
   * @generated from field: uint32 quantity = 2;
   */
  quantity = 0;

  constructor(data?: PartialMessage<PayloadConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.PayloadConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "capability_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quantity", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PayloadConfiguration {
    return new PayloadConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PayloadConfiguration {
    return new PayloadConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PayloadConfiguration {
    return new PayloadConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: PayloadConfiguration | PlainMessage<PayloadConfiguration> | undefined, b: PayloadConfiguration | PlainMessage<PayloadConfiguration> | undefined): boolean {
    return proto3.util.equals(PayloadConfiguration, a, b);
  }
}

/**
 * Releases a payload from the vehicle
 *
 * @generated from message anduril.tasks.v2.ReleasePayload
 */
export class ReleasePayload extends Message<ReleasePayload> {
  /**
   * The payload(s) that will be released
   *
   * @generated from field: repeated anduril.tasks.v2.PayloadConfiguration payloads = 1;
   */
  payloads: PayloadConfiguration[] = [];

  /**
   * Optional objective, of where the payload should be dropped. If omitted the payload will drop the current location
   *
   * @generated from field: anduril.tasks.v2.Objective objective = 2;
   */
  objective?: Objective;

  /**
   * @generated from oneof anduril.tasks.v2.ReleasePayload.release_method
   */
  releaseMethod: {
    /**
     * Attempt to place the payload delicately from a standstill
     *
     * @generated from field: google.protobuf.Empty precision_release = 3;
     */
    value: Empty;
    case: "precisionRelease";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ReleasePayload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.ReleasePayload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "payloads", kind: "message", T: PayloadConfiguration, repeated: true },
    { no: 2, name: "objective", kind: "message", T: Objective },
    { no: 3, name: "precision_release", kind: "message", T: Empty, oneof: "release_method" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReleasePayload {
    return new ReleasePayload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReleasePayload {
    return new ReleasePayload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReleasePayload {
    return new ReleasePayload().fromJsonString(jsonString, options);
  }

  static equals(a: ReleasePayload | PlainMessage<ReleasePayload> | undefined, b: ReleasePayload | PlainMessage<ReleasePayload> | undefined): boolean {
    return proto3.util.equals(ReleasePayload, a, b);
  }
}

