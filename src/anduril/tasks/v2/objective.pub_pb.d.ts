// @generated by protoc-gen-es v1.7.2 with parameter "js_import_style=legacy_commonjs"
// @generated from file anduril/tasks/v2/objective.pub.proto (package anduril.tasks.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { LLA } from "../../type/coords.pub_pb.js";

/**
 * Describes the objective of a task.
 *
 * @generated from message anduril.tasks.v2.Objective
 */
export declare class Objective extends Message<Objective> {
  /**
   * @generated from oneof anduril.tasks.v2.Objective.objective
   */
  objective: {
    /**
     * Prefer Entity Objectives whenever the objective is in fact an entity. In other words, don't take position/point
     * out of an entity and pass it as a simple point.
     *
     * @generated from field: string entity_id = 1;
     */
    value: string;
    case: "entityId";
  } | {
    /**
     * Point objectives for simple reference points that are not geo entities.
     *
     * @generated from field: anduril.tasks.v2.Point point = 5;
     */
    value: Point;
    case: "point";
  } | { case: undefined; value?: undefined };

  /**
   * the asset (if known) which produced the objective (useful for time-series lookups of historical objectives).
   *
   * @generated from field: string produced_by_asset_id = 2;
   */
  producedByAssetId: string;

  constructor(data?: PartialMessage<Objective>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.tasks.v2.Objective";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Objective;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Objective;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Objective;

  static equals(a: Objective | PlainMessage<Objective> | undefined, b: Objective | PlainMessage<Objective> | undefined): boolean;
}

/**
 * Describes a single point location.
 *
 * @generated from message anduril.tasks.v2.Point
 */
export declare class Point extends Message<Point> {
  /**
   * A human readable name for the point.
   *
   * @generated from field: string reference_name = 1;
   */
  referenceName: string;

  /**
   * Indicates the objective is the provided location.
   *
   * @generated from field: anduril.type.LLA lla = 2;
   */
  lla?: LLA;

  /**
   * An optional entity id that is provided for reverse lookup purposes. This may be used any time the UI might
   * have to convert a geoentity to statically defined LLA.
   *
   * @generated from field: string backing_entity_id = 3;
   */
  backingEntityId: string;

  constructor(data?: PartialMessage<Point>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "anduril.tasks.v2.Point";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Point;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Point;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Point;

  static equals(a: Point | PlainMessage<Point> | undefined, b: Point | PlainMessage<Point> | undefined): boolean;
}

