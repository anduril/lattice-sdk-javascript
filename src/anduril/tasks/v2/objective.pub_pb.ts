// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file anduril/tasks/v2/objective.pub.proto (package anduril.tasks.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { LLA } from "../../type/coords.pub_pb.js";

/**
 * Describes the objective of a task.
 *
 * @generated from message anduril.tasks.v2.Objective
 */
export class Objective extends Message<Objective> {
  /**
   * @generated from oneof anduril.tasks.v2.Objective.objective
   */
  objective: {
    /**
     * Prefer Entity Objectives whenever the objective is in fact an entity. In other words, don't take position/point
     * out of an entity and pass it as a simple point.
     *
     * @generated from field: string entity_id = 1;
     */
    value: string;
    case: "entityId";
  } | {
    /**
     * Point objectives for simple reference points that are not geo entities.
     *
     * @generated from field: anduril.tasks.v2.Point point = 5;
     */
    value: Point;
    case: "point";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * the asset (if known) which produced the objective (useful for time-series lookups of historical objectives).
   *
   * @generated from field: string produced_by_asset_id = 2;
   */
  producedByAssetId = "";

  constructor(data?: PartialMessage<Objective>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.Objective";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entity_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "objective" },
    { no: 5, name: "point", kind: "message", T: Point, oneof: "objective" },
    { no: 2, name: "produced_by_asset_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Objective {
    return new Objective().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Objective {
    return new Objective().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Objective {
    return new Objective().fromJsonString(jsonString, options);
  }

  static equals(a: Objective | PlainMessage<Objective> | undefined, b: Objective | PlainMessage<Objective> | undefined): boolean {
    return proto3.util.equals(Objective, a, b);
  }
}

/**
 * Describes a single point location.
 *
 * @generated from message anduril.tasks.v2.Point
 */
export class Point extends Message<Point> {
  /**
   * A human readable name for the point.
   *
   * @generated from field: string reference_name = 1;
   */
  referenceName = "";

  /**
   * Indicates the objective is the provided location.
   *
   * @generated from field: anduril.type.LLA lla = 2;
   */
  lla?: LLA;

  /**
   * An optional entity id that is provided for reverse lookup purposes. This may be used any time the UI might
   * have to convert a geoentity to statically defined LLA.
   *
   * @generated from field: string backing_entity_id = 3;
   */
  backingEntityId = "";

  constructor(data?: PartialMessage<Point>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "anduril.tasks.v2.Point";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reference_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "lla", kind: "message", T: LLA },
    { no: 3, name: "backing_entity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Point {
    return new Point().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Point {
    return new Point().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Point {
    return new Point().fromJsonString(jsonString, options);
  }

  static equals(a: Point | PlainMessage<Point> | undefined, b: Point | PlainMessage<Point> | undefined): boolean {
    return proto3.util.equals(Point, a, b);
  }
}

